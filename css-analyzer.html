<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Customer Success Score Analyzer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.umd.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel" data-presets="react" src="js/TechnicalHealthTreeDiagram.jsx"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --primary: #0ea5e9;
      --success: #15803d;
      --warning: #b45309;
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #64748b;
      --border: rgba(148, 163, 184, 0.35);
      --shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    body {
      background: linear-gradient(160deg, #e2e8f0, #f8fafc 45%, #ffffff 100%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    .page-header {
      padding: 3rem 5vw 1.5rem;
      display: grid;
      gap: 1.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .page-header h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 700;
    }

    .page-header p {
      color: var(--muted);
      max-width: 900px;
      line-height: 1.6;
    }

    .reference-month {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--muted);
    }

    main {
      padding: 0 5vw;
      display: grid;
      gap: 2.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .panel {
      background: var(--surface);
      border-radius: 1.25rem;
      padding: 1.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }

    .panel h2 {
      font-size: 1.35rem;
      margin-bottom: 1rem;
      color: var(--text);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.25rem;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 1.35rem;
      color: var(--text);
    }

    .export-button {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--surface-alt);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 999px;
      padding: 0.5rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }

    .export-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
    }

    .export-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .data-loader {
      display: grid;
      gap: 1.25rem;
    }

    .form-grid {
      display: grid;
      gap: 1.25rem;
    }

    @media (min-width: 720px) {
      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: end;
      }
    }

    .form-group {
      display: grid;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text);
    }

    .form-group select,
    .form-group input[type="file"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .load-button {
      justify-self: start;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    .load-button:disabled {
      background: var(--surface-alt);
      color: var(--muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    .helper-text {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .account-overview-list {
      display: grid;
      gap: 1rem;
      padding: 0;
      margin: 0;
    }

    .account-overview-item {
      display: grid;
      gap: 0.35rem;
      padding: 0 0 1rem;
      border-bottom: 1px solid var(--border);
    }

    .account-overview-item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .account-overview-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--muted);
    }

    .account-overview-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
    }

    .account-overview-subtitle {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .key-metric {
      border-radius: 1rem;
      padding: 1.5rem;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.12), rgba(148, 163, 184, 0.08));
      display: grid;
      gap: 0.75rem;
    }

    .key-metric h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .key-metric strong {
      display: block;
      font-size: 2.2rem;
      font-weight: 700;
      color: var(--text);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.85rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-weight: 600;
      color: var(--text);
      background: rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }

    .badge.up {
      color: var(--success);
      background: rgba(21, 128, 61, 0.12);
    }

    .badge.down {
      color: var(--danger);
      background: rgba(185, 28, 28, 0.12);
    }

    .signal-list {
      display: grid;
      gap: 1rem;
    }

    details.accordion {
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      overflow: hidden;
    }

    details.accordion + details.accordion {
      margin-top: 1rem;
    }

    details.accordion summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 1.1rem 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    details.accordion summary::-webkit-details-marker {
      display: none;
    }

    details.accordion summary::after {
      content: '+';
      font-size: 1.2rem;
      transition: transform 0.2s ease;
      color: var(--muted);
    }

    details.accordion[open] summary::after {
      content: 'âˆ’';
      color: var(--primary);
    }

    .accordion-title {
      flex: 1 1 auto;
      min-width: 0;
      font-size: 1rem;
    }

    details.accordion summary .score-pill {
      margin-left: auto;
    }

    .accordion-content {
      padding: 0 1.25rem 1.25rem;
      border-top: 1px solid var(--border);
    }

    .accordion-content .signal-list {
      margin-top: 1rem;
    }

    .all-signals-controls {
      margin-bottom: 1.5rem;
    }

    .signal-item {
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      display: grid;
      gap: 0.35rem;
    }

    .signal-item header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
      margin-bottom: 0.25rem;
    }

    .signal-item h4 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .signal-definition {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 0.35rem;
      line-height: 1.4;
    }

    .signal-category {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .signal-metrics {
      display: grid;
      gap: 0.65rem;
      margin-top: 0.5rem;
    }

    .score-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .metric-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.8rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .metric-pill strong {
      font-size: 0.85rem;
      color: inherit;
    }

    .score-pill {
      justify-self: flex-start;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .score-high {
      background: rgba(21, 128, 61, 0.15);
      color: var(--success);
    }

    .score-medium {
      background: rgba(234, 179, 8, 0.18);
      color: #b45309;
    }

    .score-low {
      background: rgba(185, 28, 28, 0.15);
      color: var(--danger);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .filters input,
    .filters select {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      color: var(--text);
      min-width: 200px;
      font-size: 0.95rem;
    }

    .filters input::placeholder {
      color: var(--muted);
    }

    .empty-state {
      padding: 1rem;
      color: var(--muted);
      font-style: italic;
    }

    .score-summary-grid {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .score-summary {
      border-radius: 1.1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      padding: 1.25rem 1.5rem;
      display: grid;
      gap: 0.75rem;
    }

    .score-summary-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .score-summary .badge {
      justify-self: flex-start;
    }

    .score-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .score-tree-heading {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-top: 0.5rem;
    }

    #technicalHealthTreeMount {
      margin-top: 1.5rem;
    }

    #technicalHealthTreeMount .technical-health-tree-card {
      width: 100%;
      border-radius: 1.5rem;
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 1.5rem;
    }

    @media (min-width: 768px) {
      #technicalHealthTreeMount .technical-health-tree-card {
        padding: 2rem;
      }
    }

    #technicalHealthTreeMount .technical-health-tree-header {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    @media (min-width: 768px) {
      #technicalHealthTreeMount .technical-health-tree-header {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
    }

    #technicalHealthTreeMount .technical-health-tree-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text);
    }

    #technicalHealthTreeMount .technical-health-tree-subtitle {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 0.35rem;
    }

    #technicalHealthTreeMount .technical-health-tree-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 600;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    #technicalHealthTreeMount .technical-health-tree-toggle.is-active {
      background: #0f172a;
      color: #ffffff;
      box-shadow: 0 18px 32px rgba(15, 23, 42, 0.25);
    }

    #technicalHealthTreeMount .technical-health-tree-toggle:not(.is-active):hover {
      background: rgba(148, 163, 184, 0.3);
    }

    #technicalHealthTreeMount .technical-health-tree-toggle:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.35);
    }

    #technicalHealthTreeMount .technical-health-tree-canvas {
      margin-top: 1.5rem;
      overflow-x: auto;
      position: relative;
    }

    #technicalHealthTreeMount .technical-health-tree-svg {
      display: block;
      margin: 0 auto;
      min-width: 520px;
    }

    #technicalHealthTreeMount .technical-health-tree-node text {
      font-family: 'Inter', system-ui, sans-serif;
    }

    #technicalHealthTreeMount .technical-health-tree-node-title {
      font-size: 0.95rem;
      font-weight: 600;
      fill: #0f172a;
    }

    #technicalHealthTreeMount .technical-health-tree-node-weight {
      font-size: 0.75rem;
      font-weight: 500;
      fill: #64748b;
    }

    #technicalHealthTreeMount .technical-health-tree-node-score {
      font-size: 0.95rem;
      font-weight: 600;
      fill: #0f172a;
    }

    #technicalHealthTreeMount .technical-health-tree-node-group {
      cursor: pointer;
    }

    #technicalHealthTreeMount .technical-health-tree-tooltip {
      position: absolute;
      pointer-events: none;
      z-index: 20;
      max-width: 320px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.6);
      border-radius: 0.9rem;
      padding: 1rem;
      box-shadow: 0 18px 38px rgba(15, 23, 42, 0.2);
      backdrop-filter: blur(6px);
      font-size: 0.8rem;
      color: #475569;
    }

    #technicalHealthTreeMount .technical-health-tree-tooltip-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: #0f172a;
      margin-bottom: 0.35rem;
    }

    #technicalHealthTreeMount .technical-health-tree-tooltip-line {
      margin: 0.25rem 0;
      color: #475569;
      line-height: 1.45;
    }

    #technicalHealthTreeMount .technical-health-tree-tooltip-value {
      font-weight: 600;
      color: #0f172a;
    }

    #technicalHealthTreeMount .technical-health-tree-tooltip-formula {
      font-style: italic;
    }

    .score-tree {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 1rem;
    }

    .score-tree > li {
      padding-left: 0.5rem;
    }

    .score-tree-node {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(148, 163, 184, 0.08);
      padding: 0.85rem 1rem;
      position: relative;
    }

    .score-tree-node::before {
      content: '';
      position: absolute;
      width: 0.6rem;
      height: 0.6rem;
      border-radius: 50%;
      background: var(--primary);
      left: -0.85rem;
      top: 50%;
      transform: translateY(-50%);
      box-shadow: 0 0 0 2px var(--surface);
    }

    .score-tree-category {
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.15), rgba(148, 163, 184, 0.08));
      border-color: rgba(14, 165, 233, 0.25);
    }

    .score-tree-subcategory {
      background: var(--surface);
    }

    .score-tree-subcategory::before {
      background: var(--muted);
    }

    .score-tree-label {
      font-weight: 600;
      color: var(--text);
      flex: 1 1 200px;
      min-width: 160px;
    }

    .score-tree-placeholder {
      border-style: dashed;
      background: rgba(148, 163, 184, 0.05);
    }

    .score-tree-placeholder .score-tree-label {
      color: var(--muted);
      font-weight: 500;
    }

    .score-tree-placeholder::before {
      background: rgba(148, 163, 184, 0.6);
    }

    .score-tree-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-left: auto;
    }

    .score-tree-children {
      list-style: none;
      margin: 0.75rem 0 0;
      padding-left: 1.75rem;
      border-left: 2px solid rgba(148, 163, 184, 0.35);
      display: grid;
      gap: 0.75rem;
    }

    .score-tree-children > li {
      position: relative;
    }

    .score-tree-children > li::before {
      content: '';
      position: absolute;
      left: -1.75rem;
      top: 1rem;
      width: 1.75rem;
      height: 1px;
      background: rgba(148, 163, 184, 0.35);
    }

    @media (max-width: 640px) {
      .page-header,
      main {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <div>
      <h1>Customer Success Score Analyzer</h1>
      <p>
        Explore key metrics, trends, and scored signals for your customer success score. Upload a CSV export, pick a snapshot date,
        and use the interactive filters to uncover opportunities and risks faster.
      </p>
    </div>
    <div class="reference-month">Reference month: <strong id="selectedMonth">Not selected</strong></div>
    <div class="reference-month">Account: <strong id="selectedAccount">Not selected</strong></div>
  </header>
  <main>
    <section class="panel" id="dataLoaderPanel">
      <h2>Load customer success score</h2>
      <div class="data-loader">
        <div class="form-grid">
          <div class="form-group">
            <label for="referenceMonth">Snapshot date</label>
            <select id="referenceMonth">
              <option value="" disabled selected>Upload a file to populate dates</option>
            </select>
          </div>
          <div class="form-group">
            <label for="tenantTypeFilter">Tenant type</label>
            <select id="tenantTypeFilter" disabled>
              <option value="" disabled selected>Select a snapshot date first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="accountFilter">Account name</label>
            <select id="accountFilter" disabled>
              <option value="" disabled selected>Select a snapshot date first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="scoreUpload">Upload Customer Success Score export</label>
            <input
              type="file"
              id="scoreUpload"
              accept=".csv,text/csv,.xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel"
            >
          </div>
        </div>
        <button class="load-button" type="button" id="loadScoreBtn" disabled>Load score</button>
        <p class="helper-text">
          Upload a CSV or XLSX export from Customer Success Score. The file is not sent anywhere; parsing happens in your
          browser. Use the selectors to choose the snapshot date and account you want to analyze.
        </p>
      </div>
    </section>

    <section class="panel" id="account-overview">
      <h2>Account overview</h2>
      <div class="account-overview-list" id="accountOverview"></div>
    </section>

    <section class="panel" id="overall-scores">
      <div class="panel-header">
        <h2>Overall score summary</h2>
        <button class="export-button" type="button" id="exportOverallJson" disabled>Export to JSON</button>
      </div>
      <div class="score-summary-grid" id="overallScoreGrid"></div>
    </section>

    <section class="panel" id="all-scored-signals">
      <div class="panel-header">
        <h2>All scored signals</h2>
        <button class="export-button" type="button" id="exportSignalsJson" disabled>Export to JSON</button>
      </div>
      <p class="helper-text">Every scored signal for the selected snapshot is listed below and respects the filters above.</p>
      <div class="filters all-signals-controls">
        <input type="search" class="signal-search" id="allSignalsSearch" placeholder="Search a signal..." />
        <select id="allSignalsCategoryFilter" class="category-filter">
          <option value="all">Category: all</option>
        </select>
        <select id="allSignalsSubcategoryFilter" disabled>
          <option value="all">Subcategory: all</option>
        </select>
        <select id="allSignalsCapabilityFilter" disabled>
          <option value="all">Capability: all</option>
        </select>
      </div>
      <div id="allSignalsList"></div>
    </section>

  </main>

  <template id="signalTemplate">
    <article class="signal-item">
      <header>
        <div style="display:flex; flex-direction:column; gap:0.25rem;">
          <h4 data-field="signal"></h4>
          <p class="signal-definition" data-field="definition"></p>
        </div>
        <span class="badge" data-field="change"></span>
      </header>
      <p class="signal-category" data-field="category"></p>
      <div class="signal-metrics">
        <div class="score-group">
          <span data-field="score"></span>
          <span class="badge" data-field="rating"></span>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:0.5rem;">
          <span class="metric-pill" data-field="value"></span>
          <span class="metric-pill" data-field="benchmark"></span>
          <span class="metric-pill" data-field="mom"></span>
          <span class="metric-pill" data-field="qoq"></span>
        </div>
      </div>
    </article>
  </template>

  <script>
    const scoreClass = (score) => {
      if (Number.isFinite(score)) {
        if (score >= 80) return 'score-high';
        if (score >= 50) return 'score-medium';
        return 'score-low';
      }
      return 'score-medium';
    };

    const formatScore = (score, fallback) => {
      if (Number.isFinite(score)) {
        const options = Number.isInteger(score)
          ? { maximumFractionDigits: 0 }
          : { maximumFractionDigits: 2 };
        return new Intl.NumberFormat('en-US', options).format(score);
      }
      if (fallback !== undefined && fallback !== null && `${fallback}`.trim()) {
        return `${fallback}`.trim();
      }
      if (typeof score === 'string' && score.trim()) return score.trim();
      return '-';
    };

    const TECHNICAL_HEALTH_TREE_MOUNT_ID = 'technicalHealthTreeMount';
    let technicalHealthTreeRoot = null;
    let technicalHealthTreeMount = null;
    let pendingTechnicalHealthTreeData = null;

    window.addEventListener('technical-health-tree-ready', () => {
      if (pendingTechnicalHealthTreeData) {
        const dataToRender = pendingTechnicalHealthTreeData;
        pendingTechnicalHealthTreeData = null;
        renderTechnicalHealthTree(dataToRender);
      }
    });

    const unmountTechnicalHealthTree = () => {
      if (technicalHealthTreeRoot && typeof technicalHealthTreeRoot.unmount === 'function') {
        technicalHealthTreeRoot.unmount();
      } else if (technicalHealthTreeMount && window.ReactDOM?.unmountComponentAtNode) {
        window.ReactDOM.unmountComponentAtNode(technicalHealthTreeMount);
      }
      technicalHealthTreeRoot = null;
      technicalHealthTreeMount = null;
    };

    const renderTechnicalHealthTree = (data) => {
      if (!window.React || !window.ReactDOM || !data) {
        return;
      }
      const mount = document.getElementById(TECHNICAL_HEALTH_TREE_MOUNT_ID);
      if (!mount) {
        return;
      }
      if (!window.TechnicalHealthTreeDiagram) {
        pendingTechnicalHealthTreeData = data;
        return;
      }
      if (!technicalHealthTreeRoot || technicalHealthTreeMount !== mount) {
        unmountTechnicalHealthTree();
        if (typeof window.ReactDOM.createRoot === 'function') {
          technicalHealthTreeRoot = window.ReactDOM.createRoot(mount);
        } else if (typeof window.ReactDOM.render === 'function') {
          technicalHealthTreeRoot = {
            render: (element) => window.ReactDOM.render(element, mount),
            unmount: () => window.ReactDOM.unmountComponentAtNode(mount),
          };
        } else {
          console.warn('ReactDOM is not available to render the TechnicalHealthTreeDiagram.');
          return;
        }
        technicalHealthTreeMount = mount;
      }
      const element = window.React.createElement(window.TechnicalHealthTreeDiagram, { data });
      technicalHealthTreeRoot.render(element);
    };

    const createScoreBadge = (score, fallback) => {
      const span = document.createElement('span');
      span.className = `score-pill ${scoreClass(score)}`;
      span.textContent = `Score ${formatScore(score, fallback)}`;
      return span;
    };

    const formatNumber = (value, options = {}) => {
      if (!Number.isFinite(value)) return '';
      const formatter = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 2,
        ...options,
      });
      return formatter.format(value);
    };

    const cloneForExport = (value) => {
      if (value === null || value === undefined) return value;
      if (typeof structuredClone === 'function') {
        try {
          return structuredClone(value);
        } catch (error) {
          // structuredClone may throw for unsupported types; fall back to JSON cloning.
        }
      }
      return JSON.parse(JSON.stringify(value));
    };

    const slugify = (value) => {
      if (value === null || value === undefined) return '';
      return String(value)
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .slice(0, 60);
    };

    const parseNumber = (value) => {
      if (value === null || value === undefined) return null;
      const str = String(value).trim();
      if (!str) return null;
      const sanitized = str.replace(/\s|%/g, '');
      const match = sanitized.match(/[-+]?\d+[.,]?\d*(?:[.,]\d+)?/);
      if (!match) return null;
      let numeric = match[0];
      const lastComma = numeric.lastIndexOf(',');
      const lastDot = numeric.lastIndexOf('.');
      if (lastComma > lastDot) {
        numeric = numeric.replace(/\./g, '').replace(',', '.');
      } else if (lastDot > lastComma) {
        numeric = numeric.replace(/,/g, '');
      } else {
        numeric = numeric.replace(/[.,]/g, '');
      }
      const parsed = Number(numeric);
      return Number.isFinite(parsed) ? parsed : null;
    };

    const normalizeKey = (value) => {
      if (value === null || value === undefined) return '';
      return String(value).trim().toLowerCase().replace(/\s+/g, ' ');
    };

    const TECH_HEALTH_SCORED_STRUCTURE = [
      {
        name: 'Efficiency',
        weight: 0.52,
        capabilities: [
          {
            name: 'User Experience Efficiency',
            signals: [
              { name: 'EPT Page Load Time', aliases: ['experience page time (ept)', 'average page load time'] },
              { name: 'Concurrent UI Errors' },
            ],
          },
          {
            name: 'Integration Efficiency',
            signals: [
              { name: 'Concurrent API Errors' },
              { name: 'API performance', aliases: ['api performance score', 'api performance index'] },
            ],
          },
          {
            name: 'Transaction Efficiency',
            signals: [
              { name: 'Concurrent Apex Errors' },
              { name: 'CPU Timeout Errors', aliases: ['apex cpu time out errors', 'apex cpu timeout errors'] },
              { name: 'Rowlock Errors', aliases: ['rowlock error rates', 'row lock errors'] },
            ],
          },
          {
            name: 'Data Efficiency',
            signals: [{ name: 'Heap Size Errors', aliases: ['apex heap size errors'] }],
          },
        ],
      },
      {
        name: 'Operational Excellence',
        weight: 0.28,
        capabilities: [
          {
            name: 'Tech Debt',
            signals: [
              { name: 'Process Builder Workflows' },
              { name: 'Workflow Rules' },
            ],
          },
          {
            name: 'Best Practices',
            signals: [{ name: 'Core Deployed on Hyperforce' }],
          },
        ],
      },
      {
        name: 'Customization',
        weight: 0.1,
        capabilities: [
          {
            name: 'Org Security',
            signals: [
              { name: 'SSO Enabled', aliases: ['single sign-on (sso) enabled'] },
              { name: 'Core MFA Enabled', aliases: ['mfa enabled', 'mfa enforcement'] },
              { name: 'Maximum Invalid Login Attempts' },
              { name: 'Minimum Password Length' },
              { name: 'Minimum Password Lifetime Requirement' },
              { name: 'Password Complexity Requirement' },
              { name: 'Password Expiration' },
              { name: 'Password History Restriction' },
              { name: 'Password Lockout Period' },
              { name: 'Password Question Requirement' },
              { name: 'Obscure Secret Answer for Password' },
            ],
          },
          {
            name: 'Security configurations',
            signals: [
              { name: 'Prompt Injection Detection Enabled' },
              { name: 'Toxicity Detection in Prompts Enabled' },
            ],
          },
        ],
      },
      {
        name: 'Observability',
        weight: 0.1,
        capabilities: [
          {
            name: 'Monitoring',
            signals: [{ name: 'ProM Enabled' }],
          },
          {
            name: 'Diagnostics',
            signals: [
              { name: 'Scale Center Adoption' },
              { name: 'ApexGuru Adoption', aliases: ['apex guru adoption'] },
            ],
          },
        ],
      },
    ];

    const TECH_HEALTH_CAPABILITY_LOOKUP = (() => {
      const capabilityMap = new Map();
      TECH_HEALTH_SCORED_STRUCTURE.forEach((subcategory) => {
        subcategory.capabilities.forEach((capability) => {
          const capabilityKey = normalizeKey(capability.name);
          if (!capabilityKey) return;
          if (!capabilityMap.has(capabilityKey)) {
            capabilityMap.set(capabilityKey, {
              name: capability.name,
              subcategoryName: subcategory.name,
              subcategoryWeight: subcategory.weight,
              signals: new Set(),
            });
          }
          const entry = capabilityMap.get(capabilityKey);
          capability.signals.forEach((signal) => {
            const descriptor = typeof signal === 'string' ? { name: signal } : signal;
            const primary = normalizeKey(descriptor.name);
            if (primary) entry.signals.add(primary);
            if (Array.isArray(descriptor.aliases)) {
              descriptor.aliases.forEach((alias) => {
                const normalizedAlias = normalizeKey(alias);
                if (normalizedAlias) entry.signals.add(normalizedAlias);
              });
            }
          });
        });
      });
      return capabilityMap;
    })();

    const classifySignal = (row) => {
      const categoryKey = normalizeKey(row.categoryName);
      if (categoryKey !== 'technical health') {
        return { type: 'scored' };
      }

      const capabilityKey = normalizeKey(row.capabilityName);
      const signalKey = normalizeKey(row.signalName);
      if (!capabilityKey || !signalKey) {
        return { type: 'informational' };
      }

      const capability = TECH_HEALTH_CAPABILITY_LOOKUP.get(capabilityKey);
      if (!capability) {
        return { type: 'informational' };
      }

      const isScored = capability.signals.has(signalKey);
      return {
        type: isScored ? 'scored' : 'informational',
        subcategoryName: capability.subcategoryName,
        subcategoryWeight: capability.subcategoryWeight,
        capabilityName: capability.name,
      };
    };

    const normalizeDateValue = (value) => {
      if (value === null || value === undefined || value === '') return '';
      if (value instanceof Date && !Number.isNaN(value.getTime())) {
        return value.toISOString().split('T')[0];
      }
      if (typeof value === 'number' && Number.isFinite(value)) {
        if (window.XLSX?.SSF?.parse_date_code) {
          const parsed = window.XLSX.SSF.parse_date_code(value);
          if (parsed) {
            const date = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d));
            if (!Number.isNaN(date.getTime())) {
              return date.toISOString().split('T')[0];
            }
          }
        }
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        const date = new Date(excelEpoch.getTime() + value * 86400000);
        if (!Number.isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
      }
      if (typeof value === 'string') {
        return value.trim();
      }
      return value;
    };

    const ratingFromScore = (score) => {
      if (!Number.isFinite(score)) return '';
      if (score >= 61) return 'Excellent';
      if (score >= 31) return 'Good';
      return 'Fair';
    };

    const formatSigned = (value) => {
      if (!Number.isFinite(value)) return '';
      if (value === 0) return '0';
      const formatted = formatNumber(Math.abs(value));
      return `${value > 0 ? '+' : '-'}${formatted}`;
    };

    const changePiece = (value, label) => {
      if (!Number.isFinite(value)) return null;
      const formatted = formatNumber(Math.abs(value));
      const direction = value > 0 ? 'â†‘' : value < 0 ? 'â†“' : 'â†’';
      return `${direction} ${formatted} ${label}`;
    };

    const buildChangeLabel = (mom, qoq) => {
      return [changePiece(mom, 'MoM'), changePiece(qoq, 'QoQ')]
        .filter(Boolean)
        .join(' â€¢ ');
    };

    const evaluateBenchmark = (valueNumeric, benchmarkRaw) => {
      if (!Number.isFinite(valueNumeric)) return null;
      if (!benchmarkRaw) return null;
      const cleaned = benchmarkRaw.replace(/\s/g, '');
      const match = cleaned.match(/(<=|>=|<|>|=)\s*([-+]?\d+[.,]?\d*(?:[.,]\d+)?)/);
      if (!match) return null;
      const operator = match[1];
      const threshold = parseNumber(match[2]);
      if (!Number.isFinite(threshold)) return null;
      switch (operator) {
        case '<=':
          return valueNumeric <= threshold ? 'met' : 'missed';
        case '>=':
          return valueNumeric >= threshold ? 'met' : 'missed';
        case '<':
          return valueNumeric < threshold ? 'met' : 'missed';
        case '>':
          return valueNumeric > threshold ? 'met' : 'missed';
        case '=':
          return valueNumeric === threshold ? 'met' : 'missed';
        default:
          return null;
      }
    };

    const splitCSVLine = (line) => {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const char = line[i];
        if (char === '"') {
          const next = line[i + 1];
          if (inQuotes && next === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    };

    const parseCSV = (text) => {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = [];
      let buffer = '';
      let inQuotes = false;
      for (let i = 0; i < normalized.length; i += 1) {
        const char = normalized[i];
        if (char === '"') {
          const next = normalized[i + 1];
          if (inQuotes && next === '"') {
            buffer += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === '\n' && !inQuotes) {
          lines.push(buffer);
          buffer = '';
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        lines.push(buffer);
      }
      const filtered = lines.filter((line) => line.trim().length);
      if (!filtered.length) return [];
      const headerCells = splitCSVLine(filtered.shift());
      if (!headerCells.length) return [];
      headerCells[0] = headerCells[0].replace(/^\uFEFF/, '');
      const headers = headerCells.map((cell) => cell.trim());
      const rows = [];
      for (const line of filtered) {
        const cells = splitCSVLine(line).map((cell) => cell.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = cells[index] ?? '';
        });
        const hasData = Object.values(row).some((value) => value && `${value}`.trim().length);
        if (hasData) {
          rows.push(row);
        }
      }
      return rows;
    };

    const SIGNAL_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      'Subcategory Name': 'subcategoryName',
      'Capability Name': 'capabilityName',
      'Signal Name': 'signalName',
      Definition: 'definition',
      Score: 'scoreRaw',
      Value: 'value',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
      Benchmark: 'benchmark',
    };

    const OVERALL_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Score Name': 'scoreName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const CATEGORY_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const SUBCATEGORY_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      'Subcategory Name': 'subcategoryName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const normalizeSignalRow = (row) => {
      const normalized = {};
      for (const [column, key] of Object.entries(SIGNAL_COLUMN_MAP)) {
        const value = row[column] ?? row[column.replace(/\s+/g, ' ')] ?? '';
        if (key === 'snapshotDate') {
          normalized[key] = normalizeDateValue(value);
        } else if (typeof value === 'string') {
          normalized[key] = value.trim();
        } else {
          normalized[key] = value;
        }
      }
      normalized.score = parseNumber(normalized.scoreRaw);
      normalized.valueNumeric = parseNumber(normalized.value);
      normalized.moMChange = parseNumber(normalized.moMChangeRaw);
      normalized.qoQChange = parseNumber(normalized.qoQChangeRaw);
      return normalized;
    };

    const normalizeScoreRow = (row, columnMap) => {
      const normalized = {};
      for (const [column, key] of Object.entries(columnMap)) {
        const value = row[column] ?? row[column.replace(/\s+/g, ' ')] ?? '';
        if (key === 'snapshotDate') {
          normalized[key] = normalizeDateValue(value);
        } else if (typeof value === 'string') {
          normalized[key] = value.trim();
        } else {
          normalized[key] = value;
        }
      }
      normalized.score = parseNumber(normalized.scoreRaw);
      normalized.moMChange = parseNumber(normalized.moMChangeRaw);
      normalized.qoQChange = parseNumber(normalized.qoQChangeRaw);
      return normalized;
    };

    const formatChangeDisplay = (value, raw) => {
      const formatted = formatSigned(value);
      if (formatted) return formatted;
      if (typeof raw === 'string' && raw.trim()) return raw.trim();
      return '';
    };

    const transformSignalRow = (row) => {
      const processed = { ...row };
      const classification = classifySignal(row);
      processed.signalType = classification.type;
      processed.isScored = classification.type === 'scored';
      processed.isInformational = classification.type === 'informational';
      if (classification.subcategoryName) {
        processed.technicalHealthSubcategory = classification.subcategoryName;
      }
      if (typeof classification.subcategoryWeight === 'number') {
        processed.technicalHealthSubcategoryWeight = classification.subcategoryWeight;
      }
      if (classification.capabilityName) {
        processed.technicalHealthCapability = classification.capabilityName;
      }
      processed.rating = ratingFromScore(row.score);
      processed.categoryDescription = [row.categoryName, row.subcategoryName, row.capabilityName]
        .filter(Boolean)
        .join(' â€¢ ');
      processed.changeText = buildChangeLabel(row.moMChange, row.qoQChange);
      processed.changeDirection =
        row.moMChange > 0 || row.qoQChange > 0
          ? 'up'
          : row.moMChange < 0 || row.qoQChange < 0
          ? 'down'
          : 'flat';
      processed.momText = formatChangeDisplay(row.moMChange, row.moMChangeRaw);
      processed.qoqText = formatChangeDisplay(row.qoQChange, row.qoQChangeRaw);
      processed.valueDisplay =
        row.value && `${row.value}`.length
          ? row.value
          : Number.isFinite(row.valueNumeric)
          ? formatNumber(row.valueNumeric)
          : '';
      const benchmarkStatus = evaluateBenchmark(row.valueNumeric, row.benchmark);
      processed.benchmarkStatus = benchmarkStatus;
      processed.benchmarkDisplay = row.benchmark
        ? `${row.benchmark}${benchmarkStatus ? ` â€¢ ${benchmarkStatus}` : ''}`
        : '';
      return processed;
    };

    const decorateSummaryRow = (row) => {
      const decorated = { ...row };
      decorated.rating = ratingFromScore(row.score);
      decorated.changeText = buildChangeLabel(row.moMChange, row.qoQChange);
      decorated.momText = formatChangeDisplay(row.moMChange, row.moMChangeRaw);
      decorated.qoqText = formatChangeDisplay(row.qoQChange, row.qoQChangeRaw);
      return decorated;
    };

    const average = (values) => {
      const valid = values.filter((value) => Number.isFinite(value));
      if (!valid.length) return null;
      return valid.reduce((sum, value) => sum + value, 0) / valid.length;
    };

    const buildTechnicalHealthTreeDataset = (overallRows, categoryBreakdown = []) => {
      if (!Array.isArray(categoryBreakdown) || !categoryBreakdown.length) {
        return null;
      }

      const categoryWeightMap = new Map();
      TECH_HEALTH_SCORED_STRUCTURE.forEach((entry) => {
        const key = normalizeKey(entry.name);
        if (key) {
          categoryWeightMap.set(key, Number(entry.weight) * 100);
        }
      });

      const fallbackCategoryWeight = categoryBreakdown.length ? 100 / categoryBreakdown.length : 0;

      const categoryNodes = categoryBreakdown.map((category) => {
        const normalizedName = normalizeKey(category.name);
        const baseSubcategories = Array.isArray(category.subcategories) ? category.subcategories : [];
        let subcategories = baseSubcategories;
        if (!subcategories.length && Array.isArray(category.capabilities) && category.capabilities.length) {
          subcategories = category.capabilities.map((capability) => ({
            name: capability.name,
            score: capability.score,
            capabilities: [capability],
          }));
        }
        const subcategoryWeight = subcategories.length ? 100 / subcategories.length : 100;

        const subcategoryNodes = subcategories.map((subcategory) => {
          const capabilities = Array.isArray(subcategory.capabilities) ? subcategory.capabilities : [];
          const capabilityWeight = capabilities.length ? 100 / capabilities.length : 100;

          const capabilityNodes = capabilities.map((capability) => {
            const signals = Array.isArray(capability.signals) ? capability.signals : [];
            const capabilityScore = Number.isFinite(capability.score)
              ? capability.score
              : average(signals.map((signal) => signal.score));

            const signalNodes = signals.map((signal) => ({
              name: signal.signalName || signal.name || signal.metricName || signal.title || 'Signal',
              score: Number.isFinite(signal.score) ? signal.score : 0,
            }));

            return {
              name: capability.name || 'Capability',
              weight: capabilityWeight,
              score: Number.isFinite(capabilityScore) ? capabilityScore : 0,
              signals: signalNodes,
            };
          });

          const subcategoryScore = Number.isFinite(subcategory.score)
            ? subcategory.score
            : average(capabilityNodes.map((node) => node.score));

          return {
            name: subcategory.name || 'Subcategory',
            weight: subcategoryWeight,
            score: Number.isFinite(subcategoryScore) ? subcategoryScore : 0,
            children: capabilityNodes,
          };
        });

        const categoryScore = Number.isFinite(category.score)
          ? category.score
          : average(subcategoryNodes.map((node) => node.score));

        return {
          name: category.name || 'Category',
          weight: categoryWeightMap.get(normalizedName) ?? fallbackCategoryWeight,
          score: Number.isFinite(categoryScore) ? categoryScore : 0,
          children: subcategoryNodes,
        };
      });

      const technicalHealthScoreRow = (overallRows || []).find((row) => {
        const key = normalizeKey(row.scoreName || row.categoryName || row.name || '');
        return key.includes('technical health');
      });

      const overallScoreCandidates = [];
      if (technicalHealthScoreRow && Number.isFinite(technicalHealthScoreRow.score)) {
        overallScoreCandidates.push(technicalHealthScoreRow.score);
      }
      const categoryAverage = average(categoryNodes.map((node) => node.score));
      if (Number.isFinite(categoryAverage)) {
        overallScoreCandidates.push(categoryAverage);
      }

      const overallScore = overallScoreCandidates.length ? overallScoreCandidates[0] : 0;

      return {
        category: 'Technical Health',
        weight: 100,
        score: Number.isFinite(overallScore) ? overallScore : 0,
        children: categoryNodes,
      };
    };

    const buildCategoryHierarchy = (signals, categorySummaries = [], subcategorySummaries = []) => {
      const categoryMap = new Map();

      const ensureCategory = (name) => {
        const key = name || 'Uncategorized';
        if (!categoryMap.has(key)) {
          categoryMap.set(key, {
            name: key,
            score: null,
            scoreRaw: null,
            moMChange: null,
            moMChangeRaw: null,
            qoQChange: null,
            qoQChangeRaw: null,
            changeText: '',
            rating: '',
            momText: '',
            qoqText: '',
            scores: [],
            moms: [],
            qoqs: [],
            subcategories: new Map(),
          });
        }
        return categoryMap.get(key);
      };

      const ensureSubcategory = (category, name) => {
        const key = name || 'General';
        if (!category.subcategories.has(key)) {
          category.subcategories.set(key, {
            name: key,
            score: null,
            scoreRaw: null,
            moMChange: null,
            moMChangeRaw: null,
            qoQChange: null,
            qoQChangeRaw: null,
            changeText: '',
            rating: '',
            momText: '',
            qoqText: '',
            scores: [],
            moms: [],
            qoqs: [],
            capabilities: new Map(),
          });
        }
        return category.subcategories.get(key);
      };

      const ensureCapability = (subcategory, name) => {
        const key = name || 'General';
        if (!subcategory.capabilities.has(key)) {
          subcategory.capabilities.set(key, {
            name: key,
            scores: [],
            moms: [],
            qoqs: [],
            signals: [],
          });
        }
        return subcategory.capabilities.get(key);
      };

      signals.forEach((signal) => {
        const category = ensureCategory(signal.categoryName);
        const subcategory = ensureSubcategory(category, signal.subcategoryName);
        const capability = ensureCapability(subcategory, signal.capabilityName);
        capability.signals.push(signal);
        if (Number.isFinite(signal.score)) capability.scores.push(signal.score);
        if (Number.isFinite(signal.moMChange)) capability.moms.push(signal.moMChange);
        if (Number.isFinite(signal.qoQChange)) capability.qoqs.push(signal.qoQChange);

        if (Number.isFinite(signal.score)) subcategory.scores.push(signal.score);
        if (Number.isFinite(signal.moMChange)) subcategory.moms.push(signal.moMChange);
        if (Number.isFinite(signal.qoQChange)) subcategory.qoqs.push(signal.qoQChange);

        if (Number.isFinite(signal.score)) category.scores.push(signal.score);
        if (Number.isFinite(signal.moMChange)) category.moms.push(signal.moMChange);
        if (Number.isFinite(signal.qoQChange)) category.qoqs.push(signal.qoQChange);
      });

      categorySummaries.forEach((summary) => {
        const decorated = decorateSummaryRow(summary);
        const category = ensureCategory(decorated.categoryName);
        if (Number.isFinite(decorated.score)) category.score = decorated.score;
        category.scoreRaw = decorated.scoreRaw ?? category.scoreRaw;
        if (Number.isFinite(decorated.moMChange)) category.moMChange = decorated.moMChange;
        category.moMChangeRaw = decorated.moMChangeRaw ?? category.moMChangeRaw;
        if (Number.isFinite(decorated.qoQChange)) category.qoQChange = decorated.qoQChange;
        category.qoQChangeRaw = decorated.qoQChangeRaw ?? category.qoQChangeRaw;
        category.changeText = decorated.changeText || category.changeText;
        category.rating = decorated.rating || category.rating;
        category.momText = decorated.momText || category.momText;
        category.qoqText = decorated.qoqText || category.qoqText;
      });

      subcategorySummaries.forEach((summary) => {
        const decorated = decorateSummaryRow(summary);
        const category = ensureCategory(decorated.categoryName);
        const subcategory = ensureSubcategory(category, decorated.subcategoryName);
        if (Number.isFinite(decorated.score)) subcategory.score = decorated.score;
        subcategory.scoreRaw = decorated.scoreRaw ?? subcategory.scoreRaw;
        if (Number.isFinite(decorated.moMChange)) subcategory.moMChange = decorated.moMChange;
        subcategory.moMChangeRaw = decorated.moMChangeRaw ?? subcategory.moMChangeRaw;
        if (Number.isFinite(decorated.qoQChange)) subcategory.qoQChange = decorated.qoQChange;
        subcategory.qoQChangeRaw = decorated.qoQChangeRaw ?? subcategory.qoQChangeRaw;
        subcategory.changeText = decorated.changeText || subcategory.changeText;
        subcategory.rating = decorated.rating || subcategory.rating;
        subcategory.momText = decorated.momText || subcategory.momText;
        subcategory.qoqText = decorated.qoqText || subcategory.qoqText;
      });

      const categories = [];
      for (const category of categoryMap.values()) {
        if (!Number.isFinite(category.score)) category.score = average(category.scores);
        if (!Number.isFinite(category.moMChange)) category.moMChange = average(category.moms);
        if (!Number.isFinite(category.qoQChange)) category.qoQChange = average(category.qoqs);
        category.rating = category.rating || ratingFromScore(category.score);
        category.changeText = category.changeText || buildChangeLabel(category.moMChange, category.qoQChange);
        category.momText = category.momText || formatSigned(category.moMChange);
        category.qoqText = category.qoqText || formatSigned(category.qoQChange);

        const subcategories = [];
        for (const subcategory of category.subcategories.values()) {
          if (!Number.isFinite(subcategory.score)) subcategory.score = average(subcategory.scores);
          if (!Number.isFinite(subcategory.moMChange)) subcategory.moMChange = average(subcategory.moms);
          if (!Number.isFinite(subcategory.qoQChange)) subcategory.qoQChange = average(subcategory.qoqs);
          subcategory.rating = subcategory.rating || ratingFromScore(subcategory.score);
          subcategory.changeText = subcategory.changeText || buildChangeLabel(subcategory.moMChange, subcategory.qoQChange);
          subcategory.momText = subcategory.momText || formatSigned(subcategory.moMChange);
          subcategory.qoqText = subcategory.qoqText || formatSigned(subcategory.qoQChange);

          const capabilities = [];
          for (const capability of subcategory.capabilities.values()) {
            const score = average(capability.scores);
            const mom = average(capability.moms);
            const qoq = average(capability.qoqs);
            capabilities.push({
              name: capability.name,
              score,
              rating: ratingFromScore(score),
              changeText: buildChangeLabel(mom, qoq),
              momChange: mom,
              qoQChange: qoq,
              signals: capability.signals,
            });
          }

          subcategories.push({
            name: subcategory.name,
            score: subcategory.score,
            rating: subcategory.rating,
            changeText: subcategory.changeText,
            momChange: subcategory.moMChange,
            qoQChange: subcategory.qoQChange,
            momText: subcategory.momText,
            qoqText: subcategory.qoqText,
            capabilities: capabilities.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity)),
          });
        }

        categories.push({
          name: category.name,
          score: category.score,
          rating: category.rating,
          changeText: category.changeText,
          momChange: category.moMChange,
          qoQChange: category.qoQChange,
          momText: category.momText,
          qoqText: category.qoqText,
          subcategories: subcategories.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity)),
        });
      }

      return categories.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity));
    };

    const createInfoCard = (title, main, subtitle) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'account-overview-item';

      const label = document.createElement('span');
      label.className = 'account-overview-label';
      label.textContent = title;

      const value = document.createElement('span');
      value.className = 'account-overview-value';
      value.textContent = main;

      wrapper.append(label, value);

      if (subtitle) {
        const subtitleEl = document.createElement('span');
        subtitleEl.className = 'account-overview-subtitle';
        subtitleEl.textContent = subtitle;
        wrapper.appendChild(subtitleEl);
      }

      return wrapper;
    };

    const formatSnapshotMonth = (snapshotDate) => {
      if (!snapshotDate) {
        return 'N/A';
      }

      const trimmed = `${snapshotDate}`.trim();
      const isoMatch = trimmed.match(/^(\d{4})-(\d{1,2})(?:-(\d{1,2}))?$/);
      let parsed = null;

      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        parsed = new Date(Number(year), Number(month) - 1, Number(day || 1));
      } else {
        const attempt = new Date(trimmed);
        if (!Number.isNaN(attempt.getTime())) {
          parsed = attempt;
        }
      }

      if ((!parsed || Number.isNaN(parsed.getTime())) && trimmed.includes('/')) {
        const parts = trimmed.split('/').map((part) => part.trim());
        if (parts.length === 3) {
          if (parts[0].length === 4) {
            const [year, month, day] = parts.map((part) => Number.parseInt(part, 10));
            parsed = new Date(year, (month || 1) - 1, day || 1);
          } else if (parts[2].length === 4) {
            const [first, second, year] = parts.map((part) => Number.parseInt(part, 10));
            const month = Number.isFinite(first) ? first : 1;
            parsed = new Date(year, (month || 1) - 1, Number.isFinite(second) ? second : 1);
          }
        }
      }

      if (!parsed || Number.isNaN(parsed.getTime())) {
        return snapshotDate;
      }

      return parsed.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    };

    const populateAccountOverview = (info, snapshotDate, accountName) => {
      const container = document.getElementById('accountOverview');
      container.innerHTML = '';
      const details = info || {};
      const overviewEntries = [];
      const appendEntry = (label, value, subtitle) => {
        let normalizedValue = value;
        if (normalizedValue === undefined || normalizedValue === null) {
          normalizedValue = 'N/A';
        } else if (typeof normalizedValue === 'string' && normalizedValue.trim() === '') {
          normalizedValue = 'N/A';
        }
        const entry = { label, value: normalizedValue };
        if (subtitle) entry.subtitle = subtitle;
        overviewEntries.push(entry);
        container.appendChild(createInfoCard(label, normalizedValue, subtitle));
      };

      const primaryAccountName = accountName || details.accountName || 'N/A';
      appendEntry('Company', details.companyName || 'N/A');
      appendEntry('Account name', primaryAccountName);

      const localName = details.accountLocalName;
      if (localName && localName !== primaryAccountName) {
        appendEntry('Account local name', localName);
      }

      const formattedSnapshot = formatSnapshotMonth(snapshotDate);
      appendEntry('Snapshot date', formattedSnapshot);

      if (details.successPlan) {
        appendEntry('Success plan', details.successPlan);
      }

      if (details.tenantType) {
        appendEntry('Tenant type', details.tenantType);
      }

      currentAccountContext = {
        entries: overviewEntries,
        accountName: primaryAccountName,
        accountLocalName: localName || '',
        companyName: details.companyName || 'N/A',
        snapshotDateRaw: snapshotDate || '',
        snapshotDateFormatted: formattedSnapshot,
        successPlan: details.successPlan || '',
        tenantType: details.tenantType || '',
      };
    };

    const createMetricPill = (label, value) => {
      if (value === null || value === undefined || `${value}`.trim() === '') return null;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      pill.innerHTML = `<strong>${label}</strong> ${value}`;
      return pill;
    };

    const createSignalItem = (item) => {
      const clone = document.getElementById('signalTemplate').content.firstElementChild.cloneNode(true);
      clone.querySelector('[data-field="signal"]').textContent = item.signalName;
      const definitionElement = clone.querySelector('[data-field="definition"]');
      if (item.definition) {
        definitionElement.textContent = item.definition;
      } else {
        definitionElement.remove();
      }
      const categoryElement = clone.querySelector('[data-field="category"]');
      categoryElement.textContent = item.categoryDescription || item.categoryName || '';

      const changeSpan = clone.querySelector('[data-field="change"]');
      if (item.changeText) {
        changeSpan.textContent = item.changeText;
        if (item.moMChange > 0 || item.qoQChange > 0) {
          changeSpan.classList.add('up');
        } else if (item.moMChange < 0 || item.qoQChange < 0) {
          changeSpan.classList.add('down');
        }
      } else {
        changeSpan.remove();
      }

      const scorePlaceholder = clone.querySelector('[data-field="score"]');
      const scoreBadge = createScoreBadge(item.score, item.scoreRaw);
      scorePlaceholder.replaceWith(scoreBadge);

      const ratingBadge = clone.querySelector('[data-field="rating"]');
      if (item.rating) {
        ratingBadge.textContent = item.rating;
      } else {
        ratingBadge.remove();
      }

      const valuePill = clone.querySelector('[data-field="value"]');
      if (item.valueDisplay) {
        valuePill.innerHTML = `<strong>Value</strong> ${item.valueDisplay}`;
      } else {
        valuePill.remove();
      }

      const benchmarkPill = clone.querySelector('[data-field="benchmark"]');
      if (item.benchmarkDisplay) {
        benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmarkDisplay}`;
      } else if (item.benchmark) {
        benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmark}`;
      } else {
        benchmarkPill.remove();
      }

      const momPill = clone.querySelector('[data-field="mom"]');
      if (item.momText) {
        momPill.innerHTML = `<strong>MoM</strong> ${item.momText}`;
      } else {
        momPill.remove();
      }

      const qoqPill = clone.querySelector('[data-field="qoq"]');
      if (item.qoqText) {
        qoqPill.innerHTML = `<strong>QoQ</strong> ${item.qoqText}`;
      } else {
        qoqPill.remove();
      }

      return clone;
    };

    const populateGroupedSignals = (signals, container) => {
      container.innerHTML = '';
      if (!signals.length) {
        const empty = document.createElement('p');
        empty.className = 'empty-state';
        empty.textContent = 'No signals match the current filters.';
        container.appendChild(empty);
        return;
      }

      const map = new Map();
      for (const signal of signals) {
        const category = signal.categoryName || 'Uncategorized';
        if (!map.has(category)) {
          map.set(category, []);
        }
        map.get(category).push(signal);
      }

      for (const [category, items] of map) {
        const accordion = document.createElement('details');
        accordion.className = 'accordion';
        const summary = document.createElement('summary');
        const title = document.createElement('span');
        title.className = 'accordion-title';
        title.textContent = category;
        summary.appendChild(title);
        summary.appendChild(createScoreBadge(average(items.map((item) => item.score))));
        accordion.appendChild(summary);

        const content = document.createElement('div');
        content.className = 'accordion-content';
        const list = document.createElement('div');
        list.className = 'signal-list';
        items.forEach((item) => list.appendChild(createSignalItem(item)));
        content.appendChild(list);
        accordion.appendChild(content);
        container.appendChild(accordion);
      }
    };

    const populateOverallScores = (overallRows, categoryBreakdown = []) => {
      const container = document.getElementById('overallScoreGrid');
      unmountTechnicalHealthTree();
      container.innerHTML = '';

      const summaries = [];
      overallRows.forEach((row) => {
        const decorated = decorateSummaryRow(row);
        summaries.push({ ...decorated, title: row.scoreName || 'Overall score' });
      });

      const hasCategories = Array.isArray(categoryBreakdown) && categoryBreakdown.length > 0;
      const technicalHealthTreeData = hasCategories
        ? buildTechnicalHealthTreeDataset(overallRows, categoryBreakdown)
        : null;

      if (!summaries.length && !hasCategories) {
        currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
        if (exportOverallButton) exportOverallButton.disabled = true;
        container.innerHTML = '<p class="empty-state">No overall scores available for the current selection.</p>';
        return;
      }

      currentOverallSummaryData = {
        summaries: cloneForExport(summaries),
        categoryBreakdown: hasCategories ? cloneForExport(categoryBreakdown) : [],
      };
      if (exportOverallButton) {
        exportOverallButton.disabled = false;
      }

      const cardsToRender = summaries.length ? summaries : [{ title: 'Category breakdown' }];

      cardsToRender.forEach((row, index) => {
        const card = document.createElement('article');
        card.className = 'score-summary';

        const header = document.createElement('div');
        header.className = 'score-summary-header';
        const title = document.createElement('h3');
        title.textContent = row.title;
        header.appendChild(title);
        if (Number.isFinite(row.score)) {
          header.appendChild(createScoreBadge(row.score));
        }
        card.appendChild(header);

        if (row.rating) {
          const ratingBadge = document.createElement('span');
          ratingBadge.className = 'badge';
          ratingBadge.textContent = row.rating;
          card.appendChild(ratingBadge);
        }

        if (row.changeText) {
          const changeBadge = document.createElement('span');
          const direction =
            (Number.isFinite(row.moMChange) && row.moMChange > 0) || (Number.isFinite(row.qoQChange) && row.qoQChange > 0)
              ? 'up'
              : (Number.isFinite(row.moMChange) && row.moMChange < 0) || (Number.isFinite(row.qoQChange) && row.qoQChange < 0)
              ? 'down'
              : '';
          changeBadge.className = `badge ${direction}`.trim();
          changeBadge.textContent = row.changeText;
          card.appendChild(changeBadge);
        }

        const metrics = document.createElement('div');
        metrics.className = 'score-metrics';
        const momPill = createMetricPill('MoM', row.momText);
        if (momPill) metrics.appendChild(momPill);
        const qoqPill = createMetricPill('QoQ', row.qoqText);
        if (qoqPill) metrics.appendChild(qoqPill);
        if (metrics.children.length) {
          card.appendChild(metrics);
        }

        if (hasCategories && index === 0) {
          if (technicalHealthTreeData) {
            const treeLabel = document.createElement('p');
            treeLabel.className = 'score-tree-heading';
            treeLabel.textContent = 'Technical health calculation breakdown';
            card.appendChild(treeLabel);

            const treeMount = document.createElement('div');
            treeMount.id = TECHNICAL_HEALTH_TREE_MOUNT_ID;
            card.appendChild(treeMount);
          }
        }

        container.appendChild(card);

        if (technicalHealthTreeData && index === 0) {
          renderTechnicalHealthTree(technicalHealthTreeData);
        }
      });
    };

    const populateCategoryOptions = (categories) => {
      const uniqueCategories = Array.from(new Set(categories)).filter(Boolean).sort();
      document.querySelectorAll('.category-filter').forEach((select) => {
        select.innerHTML = '<option value="all">Category: all</option>';
        for (const name of uniqueCategories) {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          select.appendChild(option);
        }
        select.value = 'all';
      });
    };

    const selectedMonthLabel = document.getElementById('selectedMonth');
    const selectedAccountLabel = document.getElementById('selectedAccount');
    const referenceMonthSelect = document.getElementById('referenceMonth');
    const tenantTypeFilterSelect = document.getElementById('tenantTypeFilter');
    const accountFilterSelect = document.getElementById('accountFilter');
    const scoreUploadInput = document.getElementById('scoreUpload');
    const loadScoreBtn = document.getElementById('loadScoreBtn');
    const allSignalsSearchInput = document.getElementById('allSignalsSearch');
    const searchInputs = [allSignalsSearchInput].filter(Boolean);
    const allSignalsCategoryFilter = document.getElementById('allSignalsCategoryFilter');
    const allSignalsSubcategoryFilter = document.getElementById('allSignalsSubcategoryFilter');
    const allSignalsCapabilityFilter = document.getElementById('allSignalsCapabilityFilter');
    const categoryFilters = [allSignalsCategoryFilter].filter(Boolean);
    const allSignalsListContainer = document.getElementById('allSignalsList');
    const exportOverallButton = document.getElementById('exportOverallJson');
    const exportSignalsButton = document.getElementById('exportSignalsJson');

    let parsedDataset = null;
    let allScoredSignals = [];

    const initialAccountContext = () => ({
      entries: [],
      accountName: '',
      accountLocalName: '',
      companyName: '',
      snapshotDateRaw: '',
      snapshotDateFormatted: '',
      successPlan: '',
      tenantType: '',
    });

    let currentAccountContext = initialAccountContext();
    let currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
    let currentFilteredSignals = [];
    let currentAllSignalsFilters = {
      searchTerm: '',
      category: 'all',
      subcategory: 'all',
      capability: 'all',
    };

    const resetSignalsFiltersState = () => {
      currentAllSignalsFilters = {
        searchTerm: '',
        category: 'all',
        subcategory: 'all',
        capability: 'all',
      };
    };

    const clearVisualizations = (message) => {
      allScoredSignals = [];
      currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
      currentFilteredSignals = [];
      currentAccountContext = initialAccountContext();
      resetSignalsFiltersState();

      unmountTechnicalHealthTree();

      if (exportOverallButton) exportOverallButton.disabled = true;
      if (exportSignalsButton) exportSignalsButton.disabled = true;

      const accountOverview = document.getElementById('accountOverview');
      if (accountOverview) accountOverview.innerHTML = '';
      const overallGrid = document.getElementById('overallScoreGrid');
      if (overallGrid) overallGrid.innerHTML = `<p class="empty-state">${message}</p>`;
      if (allSignalsListContainer) {
        allSignalsListContainer.innerHTML = `<p class="empty-state">${message}</p>`;
      }
      document.querySelectorAll('.signal-search').forEach((input) => {
        input.value = '';
      });
      if (allSignalsSubcategoryFilter) {
        allSignalsSubcategoryFilter.innerHTML = '<option value="all">Subcategory: all</option>';
        allSignalsSubcategoryFilter.value = 'all';
        allSignalsSubcategoryFilter.disabled = true;
      }
      if (allSignalsCapabilityFilter) {
        allSignalsCapabilityFilter.innerHTML = '<option value="all">Capability: all</option>';
        allSignalsCapabilityFilter.value = 'all';
        allSignalsCapabilityFilter.disabled = true;
      }
      document.querySelectorAll('.category-filter').forEach((select) => {
        select.innerHTML = '<option value="all">Category: all</option>';
        select.value = 'all';
      });
    };

    const buildAccountOverviewPayload = () => {
      const { entries, ...meta } = currentAccountContext;
      const sanitizedMeta = {};
      Object.entries(meta).forEach(([key, value]) => {
        if (value === null || value === undefined) return;
        if (typeof value === 'string' && value.trim() === '') return;
        sanitizedMeta[key] = value;
      });
      return {
        ...sanitizedMeta,
        entries: cloneForExport(entries),
      };
    };

    const buildExportFilename = (base) => {
      const accountSlug = slugify(currentAccountContext.accountName) || 'account';
      const snapshotSource =
        currentAccountContext.snapshotDateRaw || currentAccountContext.snapshotDateFormatted || 'snapshot';
      const snapshotSlug = slugify(snapshotSource) || 'snapshot';
      return `${base}-${accountSlug}-${snapshotSlug}.json`;
    };

    const triggerJsonDownload = (filename, payload) => {
      const blob = new Blob([`${JSON.stringify(payload, null, 2)}\n`], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };

    const populateReferenceOptions = (dates) => {
      referenceMonthSelect.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      placeholder.textContent = dates.length ? '-- Select snapshot date --' : 'Upload a file to populate dates';
      referenceMonthSelect.appendChild(placeholder);
      for (const date of dates) {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = date;
        referenceMonthSelect.appendChild(option);
      }
    };

    const resetTenantTypeSelect = (message) => {
      if (!tenantTypeFilterSelect) return;
      tenantTypeFilterSelect.innerHTML = `<option value="" disabled selected>${message}</option>`;
      tenantTypeFilterSelect.disabled = true;
    };

    const resetAccountSelect = (message) => {
      accountFilterSelect.innerHTML = `<option value="" disabled selected>${message}</option>`;
      accountFilterSelect.disabled = true;
    };

    const syncSearchInputs = (source) => {
      const value = source.value;
      searchInputs.forEach((input) => {
        if (input !== source && input.value !== value) {
          input.value = value;
        }
      });
      applyFilters();
    };

    const syncCategoryFilters = (source) => {
      const value = source.value;
      categoryFilters.forEach((select) => {
        if (select !== source && select.value !== value) {
          select.value = value;
        }
      });
      updateAllSignalsFilterOptions({ resetSubcategory: true, resetCapability: true });
      applyFilters();
    };

    const applyFilters = () => {
      if (!allSignalsListContainer) return;
      const rawSearchTerm = searchInputs[0]?.value || '';
      const searchTerm = rawSearchTerm.toLowerCase();
      const categoryValue = categoryFilters[0]?.value || 'all';
      const subcategoryValue =
        allSignalsSubcategoryFilter && !allSignalsSubcategoryFilter.disabled
          ? allSignalsSubcategoryFilter.value
          : 'all';
      const capabilityValue =
        allSignalsCapabilityFilter && !allSignalsCapabilityFilter.disabled
          ? allSignalsCapabilityFilter.value
          : 'all';

      const matchesFilters = (signal) => {
        const matchesSearch =
          !searchTerm ||
          signal.signalName?.toLowerCase().includes(searchTerm) ||
          signal.definition?.toLowerCase().includes(searchTerm);
        const matchesCategory =
          categoryValue === 'all' ||
          signal.categoryName === categoryValue ||
          signal.categoryDescription?.startsWith(`${categoryValue}`);
        const matchesSubcategory = subcategoryValue === 'all' || signal.subcategoryName === subcategoryValue;
        const matchesCapability = capabilityValue === 'all' || signal.capabilityName === capabilityValue;
        return matchesSearch && matchesCategory && matchesSubcategory && matchesCapability;
      };

      const filteredSignals = allScoredSignals.filter(matchesFilters);
      currentFilteredSignals = cloneForExport(filteredSignals);
      currentAllSignalsFilters = {
        searchTerm: rawSearchTerm,
        category: categoryValue,
        subcategory: subcategoryValue,
        capability: capabilityValue,
      };
      if (exportSignalsButton) {
        exportSignalsButton.disabled = allScoredSignals.length === 0;
      }
      populateGroupedSignals(filteredSignals, allSignalsListContainer);
    };

    const updateAllSignalsFilterOptions = ({ resetSubcategory = false, resetCapability = false } = {}) => {
      if (!allSignalsSubcategoryFilter || !allSignalsCapabilityFilter) return;

      const categoryValue = allSignalsCategoryFilter ? allSignalsCategoryFilter.value : 'all';
      const relevantSignals =
        categoryValue === 'all'
          ? allScoredSignals
          : allScoredSignals.filter((signal) => signal.categoryName === categoryValue);

      const previousSubValue = resetSubcategory ? 'all' : allSignalsSubcategoryFilter.value || 'all';
      const subcategories = new Set();
      relevantSignals.forEach((signal) => {
        if (signal.subcategoryName) {
          subcategories.add(signal.subcategoryName);
        }
      });
      const sortedSubs = Array.from(subcategories).sort((a, b) => a.localeCompare(b));

      allSignalsSubcategoryFilter.innerHTML = '';
      const defaultSub = document.createElement('option');
      defaultSub.value = 'all';
      defaultSub.textContent = 'Subcategory: all';
      allSignalsSubcategoryFilter.appendChild(defaultSub);
      sortedSubs.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        allSignalsSubcategoryFilter.appendChild(option);
      });

      const newSubValue = sortedSubs.includes(previousSubValue) ? previousSubValue : 'all';
      allSignalsSubcategoryFilter.value = newSubValue;
      const subcategoryChanged = newSubValue !== previousSubValue;

      const previousCapValue =
        resetCapability || subcategoryChanged ? 'all' : allSignalsCapabilityFilter.value || 'all';
      const capabilitySignals = relevantSignals.filter(
        (signal) => newSubValue === 'all' || signal.subcategoryName === newSubValue
      );
      const capabilities = new Set();
      capabilitySignals.forEach((signal) => {
        if (signal.capabilityName) {
          capabilities.add(signal.capabilityName);
        }
      });
      const sortedCaps = Array.from(capabilities).sort((a, b) => a.localeCompare(b));

      allSignalsCapabilityFilter.innerHTML = '';
      const defaultCap = document.createElement('option');
      defaultCap.value = 'all';
      defaultCap.textContent = 'Capability: all';
      allSignalsCapabilityFilter.appendChild(defaultCap);
      sortedCaps.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        allSignalsCapabilityFilter.appendChild(option);
      });

      const newCapValue = sortedCaps.includes(previousCapValue) ? previousCapValue : 'all';
      allSignalsCapabilityFilter.value = newCapValue;

      const hasSignals = allScoredSignals.length > 0;
      allSignalsSubcategoryFilter.disabled = !hasSignals;
      allSignalsCapabilityFilter.disabled = !hasSignals;
    };

    const populateAccountOptions = (snapshotDate, tenantTypeValue = 'all') => {
      if (!parsedDataset || !snapshotDate) {
        resetAccountSelect(snapshotDate ? 'No accounts for selected date' : 'Select a snapshot date first');
        updateLoadButtonState();
        return;
      }

      const accounts = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (parsedDataset[key] || []).forEach((row) => {
          const matchesTenant =
            tenantTypeValue === 'all' || !tenantTypeValue || (row.tenantType || '') === tenantTypeValue;
          if (row.snapshotDate === snapshotDate && row.accountName && matchesTenant) {
            accounts.add(row.accountName);
          }
        });
      });

      const sorted = Array.from(accounts).sort((a, b) => a.localeCompare(b));
      accountFilterSelect.innerHTML = '';

      if (!sorted.length) {
        const option = document.createElement('option');
        option.value = '';
        option.disabled = true;
        option.selected = true;
        option.textContent = tenantTypeValue && tenantTypeValue !== 'all' ? 'No accounts for selected tenant type' : 'No accounts for selected date';
        accountFilterSelect.appendChild(option);
        accountFilterSelect.disabled = true;
        updateLoadButtonState();
        return;
      }

      if (sorted.length > 1) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.disabled = true;
        placeholder.selected = true;
        placeholder.textContent = '-- Select account --';
        accountFilterSelect.appendChild(placeholder);
      }

      sorted.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        accountFilterSelect.appendChild(option);
      });

      accountFilterSelect.disabled = false;
      accountFilterSelect.value = sorted.length === 1 ? sorted[0] : '';
      updateLoadButtonState();
    };

    const populateTenantTypeOptions = (snapshotDate) => {
      if (!tenantTypeFilterSelect) return;
      if (!parsedDataset || !snapshotDate) {
        resetTenantTypeSelect(snapshotDate ? 'No tenant types for selected date' : 'Select a snapshot date first');
        return;
      }

      const types = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (parsedDataset[key] || []).forEach((row) => {
          if (row.snapshotDate === snapshotDate && row.tenantType) {
            types.add(row.tenantType);
          }
        });
      });

      const sorted = Array.from(types).sort((a, b) => a.localeCompare(b));

      if (!sorted.length) {
        tenantTypeFilterSelect.innerHTML = '<option value="all">Tenant type: all</option>';
        tenantTypeFilterSelect.value = 'all';
        tenantTypeFilterSelect.disabled = true;
        return;
      }

      tenantTypeFilterSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'Tenant type: all';
      tenantTypeFilterSelect.appendChild(allOption);
      sorted.forEach((type) => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        tenantTypeFilterSelect.appendChild(option);
      });

      tenantTypeFilterSelect.disabled = false;
      tenantTypeFilterSelect.value = sorted.length === 1 ? sorted[0] : 'all';
    };

    const collectSnapshotDates = (dataset) => {
      if (!dataset) return [];
      const values = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (dataset[key] || []).forEach((row) => {
          if (row.snapshotDate) {
            values.add(row.snapshotDate);
          }
        });
      });
      return Array.from(values).sort((a, b) => {
        const dateA = new Date(a);
        const dateB = new Date(b);
        if (!Number.isNaN(dateA) && !Number.isNaN(dateB)) {
          return dateB - dateA;
        }
        return `${b}`.localeCompare(`${a}`);
      });
    };

    const refreshDashboard = (dataset, snapshotDate, accountName, tenantTypeValue = '') => {
      if (!dataset) return;
      const activeTenantType = tenantTypeValue && tenantTypeValue !== 'all' ? tenantTypeValue : '';
      const filterBySelection = (row) =>
        row.snapshotDate === snapshotDate &&
        (!activeTenantType || (row.tenantType || '') === activeTenantType) &&
        (!accountName || row.accountName === accountName);

      const overallRows = (dataset.overall || []).filter(filterBySelection);
      const categoryRows = (dataset.categories || []).filter(filterBySelection);
      const subcategoryRows = (dataset.subcategories || []).filter(filterBySelection);
      const signalRows = (dataset.signals || []).filter(filterBySelection);

      const processed = signalRows.map(transformSignalRow);
      const scoredSignals = processed.filter((signal) => signal.isScored);
      const accountInfo = signalRows[0] || categoryRows[0] || subcategoryRows[0] || overallRows[0] || {};

      selectedMonthLabel.textContent = snapshotDate ? formatSnapshotMonth(snapshotDate) : 'Not selected';
      selectedAccountLabel.textContent = accountName || accountInfo.accountName || 'Not selected';

      populateAccountOverview({ ...accountInfo, accountName: accountInfo.accountName || accountName }, snapshotDate, accountName);

      const categories = buildCategoryHierarchy(scoredSignals, categoryRows, subcategoryRows);
      populateOverallScores(overallRows, categories);

      allScoredSignals = scoredSignals;

      const categoryNames = [
        ...new Set([
          ...scoredSignals.map((signal) => signal.categoryName),
          ...categoryRows.map((row) => row.categoryName),
        ].filter(Boolean)),
      ];

      populateCategoryOptions(categoryNames);
      updateAllSignalsFilterOptions({ resetSubcategory: true, resetCapability: true });
      applyFilters();
    };

    const updateLoadButtonState = () => {
      loadScoreBtn.disabled = !(parsedDataset && referenceMonthSelect.value && accountFilterSelect.value);
    };

    const resetDashboard = () => {
      parsedDataset = null;
      selectedMonthLabel.textContent = 'Not selected';
      selectedAccountLabel.textContent = 'Not selected';
      populateReferenceOptions([]);
      resetTenantTypeSelect('Select a snapshot date first');
      resetAccountSelect('Select a snapshot date first');
      scoreUploadInput.value = '';
      loadScoreBtn.disabled = true;
      clearVisualizations('Upload a file to begin the analysis.');
    };

    const isExcelFile = (file) => {
      if (!file) return false;
      const name = (file.name || '').toLowerCase();
      if (name.endsWith('.xlsx') || name.endsWith('.xlsm') || name.endsWith('.xls')) return true;
      const type = file.type || '';
      return (
        type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
        type === 'application/vnd.ms-excel'
      );
    };

    const parseWorkbook = (arrayBuffer) => {
      if (typeof XLSX === 'undefined') {
        throw new Error('XLSX library is not available');
      }
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const extractSheet = (sheetName) => {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return [];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        if (!rows.length) return [];
        const headerIndex = rows.findIndex(
          (row) => Array.isArray(row) && row.some((cell) => `${cell}`.trim().toLowerCase() === 'snapshot date')
        );
        if (headerIndex === -1) return [];
        const headers = rows[headerIndex].map((cell) => `${cell}`.trim());
        const records = [];
        for (let i = headerIndex + 1; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || row.every((cell) => `${cell ?? ''}`.trim() === '')) continue;
          const record = {};
          headers.forEach((header, index) => {
            const value = row[index];
            if (value === undefined || value === null) {
              record[header] = '';
            } else if (typeof value === 'string') {
              record[header] = value.trim();
            } else {
              record[header] = value;
            }
          });
          const hasData = Object.values(record).some((value) => `${value}`.trim().length);
          if (hasData) {
            records.push(record);
          }
        }
        return records;
      };

      const overall = extractSheet('Overall Scores').map((row) => normalizeScoreRow(row, OVERALL_COLUMN_MAP));
      const categories = extractSheet('Category Scores').map((row) => normalizeScoreRow(row, CATEGORY_COLUMN_MAP));
      const subcategories = extractSheet('Subcategory Scores').map((row) => normalizeScoreRow(row, SUBCATEGORY_COLUMN_MAP));
      const signals = extractSheet('Signal Scores').map((row) => normalizeSignalRow(row));

      if (!overall.length && !categories.length && !subcategories.length && !signals.length) {
        throw new Error('The workbook does not contain score data.');
      }

      return { overall, categories, subcategories, signals };
    };

    scoreUploadInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) {
        resetDashboard();
        return;
      }

      if (isExcelFile(file)) {
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            parsedDataset = parseWorkbook(loadEvent.target.result);
            const dates = collectSnapshotDates(parsedDataset);
            populateReferenceOptions(dates);
            resetTenantTypeSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            resetAccountSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            clearVisualizations('Select a snapshot date and account, then click "Load score".');
            selectedMonthLabel.textContent = 'Not selected';
            selectedAccountLabel.textContent = 'Not selected';
            updateLoadButtonState();
          } catch (error) {
            console.error('Unable to parse Excel file', error);
            alert('The uploaded file is not a valid Customer Success Score export.');
            resetDashboard();
          }
        };
        reader.readAsArrayBuffer(file);
      } else {
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            const rawRows = parseCSV(loadEvent.target.result);
            const signals = rawRows.map(normalizeSignalRow);
            if (!signals.length) {
              alert('The uploaded file does not contain any records.');
              resetDashboard();
              return;
            }
            parsedDataset = {
              overall: [],
              categories: [],
              subcategories: [],
              signals,
            };
            const dates = collectSnapshotDates(parsedDataset);
            populateReferenceOptions(dates);
            resetTenantTypeSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            resetAccountSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            clearVisualizations('Select a snapshot date and account, then click "Load score".');
            selectedMonthLabel.textContent = 'Not selected';
            selectedAccountLabel.textContent = 'Not selected';
            updateLoadButtonState();
          } catch (error) {
            console.error('Unable to parse CSV file', error);
            alert('The uploaded file is not a valid Customer Success Score export.');
            resetDashboard();
          }
        };
        reader.readAsText(file);
      }
    });

    referenceMonthSelect.addEventListener('change', () => {
      populateTenantTypeOptions(referenceMonthSelect.value);
      const tenantValue =
        tenantTypeFilterSelect && !tenantTypeFilterSelect.disabled ? tenantTypeFilterSelect.value || 'all' : 'all';
      populateAccountOptions(referenceMonthSelect.value, tenantValue);
      selectedAccountLabel.textContent = 'Not selected';
      updateLoadButtonState();
    });

    if (tenantTypeFilterSelect) {
      tenantTypeFilterSelect.addEventListener('change', () => {
        const tenantValue = tenantTypeFilterSelect.disabled ? 'all' : tenantTypeFilterSelect.value || 'all';
        populateAccountOptions(referenceMonthSelect.value, tenantValue);
        selectedAccountLabel.textContent = 'Not selected';
        updateLoadButtonState();
      });
    }

    accountFilterSelect.addEventListener('change', () => {
      updateLoadButtonState();
    });

    loadScoreBtn.addEventListener('click', () => {
      const snapshotDate = referenceMonthSelect.value;
      const accountName = accountFilterSelect.value;
      if (!snapshotDate || !parsedDataset || !accountName) return;
      const tenantValue = tenantTypeFilterSelect && !tenantTypeFilterSelect.disabled ? tenantTypeFilterSelect.value : '';
      refreshDashboard(parsedDataset, snapshotDate, accountName, tenantValue);
    });

    searchInputs.forEach((input) => {
      input.addEventListener('input', (event) => syncSearchInputs(event.target));
    });
    categoryFilters.forEach((select) => {
      select.addEventListener('change', (event) => syncCategoryFilters(event.target));
    });

    if (allSignalsSubcategoryFilter) {
      allSignalsSubcategoryFilter.addEventListener('change', () => {
        updateAllSignalsFilterOptions({ resetCapability: true });
        applyFilters();
      });
    }

    if (allSignalsCapabilityFilter) {
      allSignalsCapabilityFilter.addEventListener('change', applyFilters);
    }

    if (exportOverallButton) {
      exportOverallButton.addEventListener('click', () => {
        if (exportOverallButton.disabled) return;
        const payload = {
          accountOverview: buildAccountOverviewPayload(),
          overallSummary: cloneForExport(currentOverallSummaryData.summaries),
        };
        if (currentOverallSummaryData.categoryBreakdown.length) {
          payload.categoryBreakdown = cloneForExport(currentOverallSummaryData.categoryBreakdown);
        }
        triggerJsonDownload(buildExportFilename('overall-score-summary'), payload);
      });
    }

    if (exportSignalsButton) {
      exportSignalsButton.addEventListener('click', () => {
        if (exportSignalsButton.disabled) return;
        const payload = {
          accountOverview: buildAccountOverviewPayload(),
          filters: { ...currentAllSignalsFilters },
          signals: cloneForExport(currentFilteredSignals),
        };
        triggerJsonDownload(buildExportFilename('all-scored-signals'), payload);
      });
    }

    resetDashboard();
  </script>

</body>
</html>
