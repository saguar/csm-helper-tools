<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Customer Success Score Analyzer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --primary: #0ea5e9;
      --success: #15803d;
      --warning: #b45309;
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #64748b;
      --border: rgba(148, 163, 184, 0.35);
      --shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    body {
      background: linear-gradient(160deg, #e2e8f0, #f8fafc 45%, #ffffff 100%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    .page-header {
      padding: 3rem 5vw 1.5rem;
      display: grid;
      gap: 1.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .page-header h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 700;
    }

    .page-header p {
      color: var(--muted);
      max-width: 900px;
      line-height: 1.6;
    }

    .reference-month {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--muted);
    }

    main {
      padding: 0 5vw;
      display: grid;
      gap: 2.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .panel {
      background: var(--surface);
      border-radius: 1.25rem;
      padding: 1.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }

    .panel h2 {
      font-size: 1.35rem;
      margin-bottom: 1rem;
      color: var(--text);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.25rem;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 1.35rem;
      color: var(--text);
    }

    .export-button {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--surface-alt);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 999px;
      padding: 0.5rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }

    .export-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
    }

    .export-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .data-loader {
      display: grid;
      gap: 1.25rem;
    }

    .form-grid {
      display: grid;
      gap: 1.25rem;
    }

    @media (min-width: 720px) {
      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: end;
      }
    }

    .form-group {
      display: grid;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text);
    }

    .form-group select,
    .form-group input[type="file"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .load-button {
      justify-self: start;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    .load-button:disabled {
      background: var(--surface-alt);
      color: var(--muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    .helper-text {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .account-overview-list {
      display: grid;
      gap: 1rem;
      padding: 0;
      margin: 0;
    }

    .tab-container {
      display: grid;
      gap: 1.5rem;
    }

    .tab-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--surface-alt);
      border-radius: 0.85rem;
      border: 1px solid var(--border);
    }

    .tab-button {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--muted);
      font-weight: 600;
      font-size: 0.95rem;
      padding: 0.6rem 1.2rem;
      border-radius: 0.75rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    .tab-button:hover,
    .tab-button:focus-visible {
      background: rgba(14, 165, 233, 0.12);
      color: var(--text);
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
      outline: none;
    }

    .tab-button.active {
      background: var(--surface);
      color: var(--text);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.16);
    }

    .tab-panel-section {
      display: none;
      gap: 1.5rem;
    }

    .tab-panel-section.active {
      display: grid;
    }

    .account-overview-item {
      display: grid;
      gap: 0.35rem;
      padding: 0 0 1rem;
      border-bottom: 1px solid var(--border);
    }

    .account-overview-item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .account-overview-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--muted);
    }

    .account-overview-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
    }

    .account-overview-subtitle {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .key-metric {
      border-radius: 1rem;
      padding: 1.5rem;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.12), rgba(148, 163, 184, 0.08));
      display: grid;
      gap: 0.75rem;
    }

    .key-metric h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .key-metric strong {
      display: block;
      font-size: 2.2rem;
      font-weight: 700;
      color: var(--text);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.85rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-weight: 600;
      color: var(--text);
      background: rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }

    .badge.up {
      color: var(--success);
      background: rgba(21, 128, 61, 0.12);
    }

    .badge.down {
      color: var(--danger);
      background: rgba(185, 28, 28, 0.12);
    }

    .signal-list {
      display: grid;
      gap: 1rem;
    }

    details.accordion {
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      overflow: hidden;
    }

    details.accordion + details.accordion {
      margin-top: 1rem;
    }

    details.accordion summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 1.1rem 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    details.accordion summary::-webkit-details-marker {
      display: none;
    }

    details.accordion summary::after {
      content: '+';
      font-size: 1.2rem;
      transition: transform 0.2s ease;
      color: var(--muted);
    }

    details.accordion[open] summary::after {
      content: '−';
      color: var(--primary);
    }

    .accordion-title {
      flex: 1 1 auto;
      min-width: 0;
      font-size: 1rem;
    }

    details.accordion summary .score-pill {
      margin-left: auto;
    }

    .accordion-content {
      padding: 0 1.25rem 1.25rem;
      border-top: 1px solid var(--border);
    }

    .accordion-content .signal-list {
      margin-top: 1rem;
    }

    .all-signals-controls {
      margin-bottom: 1.5rem;
    }

    .signal-item {
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      display: grid;
      gap: 0.35rem;
    }

    .signal-item header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
      margin-bottom: 0.25rem;
    }

    .signal-item h4 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .signal-definition {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 0.35rem;
      line-height: 1.4;
    }

    .signal-category {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .signal-metrics {
      display: grid;
      gap: 0.65rem;
      margin-top: 0.5rem;
    }

    .score-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .metric-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.8rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .metric-pill strong {
      font-size: 0.85rem;
      color: inherit;
    }

    .score-pill {
      justify-self: flex-start;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .score-high {
      background: rgba(21, 128, 61, 0.15);
      color: var(--success);
    }

    .score-medium {
      background: rgba(234, 179, 8, 0.18);
      color: #b45309;
    }

    .score-low {
      background: rgba(185, 28, 28, 0.15);
      color: var(--danger);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .filters input,
    .filters select {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      color: var(--text);
      min-width: 200px;
      font-size: 0.95rem;
    }

    .filters input::placeholder {
      color: var(--muted);
    }

    .empty-state {
      padding: 1rem;
      color: var(--muted);
      font-style: italic;
    }

    .technical-health-overview {
      display: grid;
      gap: 1.25rem;
    }

    .technical-health-actions {
      display: flex;
      justify-content: flex-start;
    }

    .technical-health-add-button {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.55rem 1.4rem;
      border-radius: 999px;
      border: 1px solid transparent;
      background: var(--primary);
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .technical-health-add-button:hover,
    .technical-health-add-button:focus-visible {
      background: var(--primary-dark, #2563eb);
      box-shadow: 0 12px 28px rgba(37, 99, 235, 0.35);
      color: #fff;
    }

    .technical-health-add-button:focus-visible {
      outline: 2px solid rgba(37, 99, 235, 0.65);
      outline-offset: 2px;
    }

    .technical-health-title {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .technical-health-grid {
      display: grid;
      gap: 2rem;
    }

    .technical-health-subcategory-group {
      display: grid;
      gap: 1rem;
      grid-column: 1 / -1;
    }

    .technical-health-subcategory-heading {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .technical-health-subcategory-heading::after {
      content: '';
      height: 1px;
      background: rgba(148, 163, 184, 0.35);
      flex: 1;
    }

    .technical-health-subcategory-grid {
      display: grid;
      gap: 1.25rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .technical-health-card {
      background: var(--surface-alt);
      border-radius: 1rem;
      padding: 1.25rem 1.35rem;
      border: 1px solid var(--border);
      box-shadow: 0 16px 30px rgba(15, 23, 42, 0.08);
      display: grid;
      gap: 0.75rem;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .technical-health-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 22px 40px rgba(15, 23, 42, 0.12);
    }

    .technical-health-card.high {
      border-color: rgba(21, 128, 61, 0.3);
    }

    .technical-health-card.high .technical-health-score {
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .technical-health-card.medium {
      border-color: rgba(234, 179, 8, 0.35);
    }

    .technical-health-card.low {
      border-color: rgba(185, 28, 28, 0.3);
    }

    .technical-health-card.low .technical-health-score {
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .technical-health-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: none;
    }

    .technical-health-score {
      display: flex;
      align-items: baseline;
      gap: 0.65rem;
      flex-wrap: wrap;
    }

    .technical-health-value {
      font-size: 2rem;
      font-weight: 700;
      line-height: 1;
    }

    .technical-health-card.high .technical-health-value {
      color: var(--success);
    }

    .technical-health-card.medium .technical-health-value {
      color: #b45309;
    }

    .technical-health-card.low .technical-health-value {
      color: var(--danger);
    }

    .technical-health-unit {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--muted);
      flex-basis: 100%;
      display: block;
      margin-top: 0.35rem;
    }

    .technical-health-trend {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .technical-health-trend.up {
      color: var(--success);
    }

    .technical-health-trend.down {
      color: var(--danger);
    }

    .technical-health-trend.flat {
      color: var(--muted);
    }

    .technical-health-meta {
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .technical-health-deep-dive-link {
      font-size: 0.8rem;
      color: var(--primary);
      font-weight: 600;
      letter-spacing: 0.06em;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 0;
      width: fit-content;
      justify-self: end;
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
    }

    .technical-health-deep-dive-link::after {
      content: '↗';
      font-size: 0.9em;
    }

    .technical-health-deep-dive-link:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    .technical-health-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .technical-health-modal.is-open {
      display: flex;
    }

    .technical-health-modal-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
    }

    .technical-health-modal-dialog {
      position: relative;
      background: var(--surface);
      border-radius: 1rem;
      padding: 2rem;
      width: min(90vw, 520px);
      box-shadow: 0 20px 55px rgba(15, 23, 42, 0.3);
      display: grid;
      gap: 1.25rem;
      z-index: 1;
    }

    .technical-health-modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .technical-health-modal-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin: 0;
    }

    .technical-health-modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      line-height: 1;
      cursor: pointer;
      color: var(--muted);
    }

    .technical-health-modal-body {
      font-size: 0.95rem;
      line-height: 1.6;
      color: var(--text);
    }

    .technical-health-modal-context {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 0.5rem;
    }

    .technical-health-modal-definition {
      margin-bottom: 1.25rem;
    }

    .technical-health-modal-actions {
      display: flex;
      justify-content: center;
      margin-top: 1.5rem;
    }

    .technical-health-modal-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.65rem 1.75rem;
      border-radius: 999px;
      border: none;
      background: var(--primary);
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      text-decoration: none;
      transition: background 0.2s ease, box-shadow 0.2s ease;
      cursor: pointer;
    }

    .technical-health-modal-button:hover,
    .technical-health-modal-button:focus-visible {
      background: var(--primary-dark, #2563eb);
      box-shadow: 0 12px 28px rgba(37, 99, 235, 0.35);
      color: #fff;
    }

    .technical-health-modal-button:focus-visible {
      outline: 2px solid rgba(37, 99, 235, 0.65);
      outline-offset: 2px;
    }

    .technical-health-custom-form {
      display: grid;
      gap: 1.25rem;
    }

    .technical-health-form-description {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .technical-health-form-error {
      margin: 0;
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      background: rgba(185, 28, 28, 0.12);
      color: var(--danger);
      font-weight: 600;
      font-size: 0.9rem;
    }

    .technical-health-form-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .technical-health-form-group {
      display: grid;
      gap: 0.4rem;
    }

    .technical-health-form-group--full {
      grid-column: 1 / -1;
    }

    .technical-health-form-group label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .technical-health-form-group input,
    .technical-health-form-group select,
    .technical-health-form-group textarea {
      width: 100%;
      padding: 0.65rem 0.85rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      color: var(--text);
      font-size: 0.95rem;
    }

    .technical-health-form-group textarea {
      resize: vertical;
      min-height: 120px;
    }

    .technical-health-form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .technical-health-form-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      padding: 0.6rem 1.5rem;
      border-radius: 999px;
      border: 1px solid transparent;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .technical-health-form-button.primary {
      background: var(--primary);
      color: #fff;
    }

    .technical-health-form-button.primary:hover,
    .technical-health-form-button.primary:focus-visible {
      background: var(--primary-dark, #2563eb);
      box-shadow: 0 12px 28px rgba(37, 99, 235, 0.35);
      color: #fff;
    }

    .technical-health-form-button.secondary {
      background: transparent;
      color: var(--muted);
      border-color: var(--border);
    }

    .technical-health-form-button.secondary:hover,
    .technical-health-form-button.secondary:focus-visible {
      color: var(--text);
      border-color: var(--primary);
    }

    body.technical-health-modal-open {
      overflow: hidden;
    }

    .score-summary-grid {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .score-summary {
      border-radius: 1.1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      padding: 1.25rem 1.5rem;
      display: grid;
      gap: 0.75rem;
    }

    .score-summary-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .score-summary .badge {
      justify-self: flex-start;
    }

    .score-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .score-tree-heading {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-top: 0.5rem;
    }

    .score-tree {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 1rem;
    }

    .score-tree > li {
      padding-left: 0.5rem;
    }

    .score-tree-node {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(148, 163, 184, 0.08);
      padding: 0.85rem 1rem;
      position: relative;
    }

    .score-tree-node::before {
      content: '';
      position: absolute;
      width: 0.6rem;
      height: 0.6rem;
      border-radius: 50%;
      background: var(--primary);
      left: -0.85rem;
      top: 50%;
      transform: translateY(-50%);
      box-shadow: 0 0 0 2px var(--surface);
    }

    .score-tree-category {
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.15), rgba(148, 163, 184, 0.08));
      border-color: rgba(14, 165, 233, 0.25);
    }

    .score-tree-subcategory {
      background: var(--surface);
    }

    .score-tree-subcategory::before {
      background: var(--muted);
    }

    .score-tree-label {
      font-weight: 600;
      color: var(--text);
      flex: 1 1 200px;
      min-width: 160px;
    }

    .score-tree-placeholder {
      border-style: dashed;
      background: rgba(148, 163, 184, 0.05);
    }

    .score-tree-placeholder .score-tree-label {
      color: var(--muted);
      font-weight: 500;
    }

    .score-tree-placeholder::before {
      background: rgba(148, 163, 184, 0.6);
    }

    .score-tree-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-left: auto;
    }

    .score-tree-children {
      list-style: none;
      margin: 0.75rem 0 0;
      padding-left: 1.75rem;
      border-left: 2px solid rgba(148, 163, 184, 0.35);
      display: grid;
      gap: 0.75rem;
    }

    .score-tree-children > li {
      position: relative;
    }

    .score-tree-children > li::before {
      content: '';
      position: absolute;
      left: -1.75rem;
      top: 1rem;
      width: 1.75rem;
      height: 1px;
      background: rgba(148, 163, 184, 0.35);
    }

    @media (max-width: 640px) {
      .page-header,
      main {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <div>
      <h1>Customer Success Score Analyzer</h1>
      <p>
        Explore key metrics, trends, and scored signals for your customer success score. Upload a CSV export, pick a snapshot date,
        and use the interactive filters to uncover opportunities and risks faster.
      </p>
    </div>
    <div class="reference-month">Reference month: <strong id="selectedMonth">Not selected</strong></div>
    <div class="reference-month">Account: <strong id="selectedAccount">Not selected</strong></div>
  </header>
  <main>
    <section class="panel" id="dataLoaderPanel">
      <h2>Load customer success score</h2>
      <div class="data-loader">
        <div class="form-grid">
          <div class="form-group">
            <label for="referenceMonth">Snapshot date</label>
            <select id="referenceMonth">
              <option value="" disabled selected>Upload a file to populate dates</option>
            </select>
          </div>
          <div class="form-group">
            <label for="tenantTypeFilter">Tenant type</label>
            <select id="tenantTypeFilter" disabled>
              <option value="" disabled selected>Select a snapshot date first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="accountFilter">Account name</label>
            <select id="accountFilter" disabled>
              <option value="" disabled selected>Select a snapshot date first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="scoreUpload">Upload Customer Success Score export</label>
            <input
              type="file"
              id="scoreUpload"
              accept=".csv,text/csv,.xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel"
            >
          </div>
        </div>
        <button class="load-button" type="button" id="loadScoreBtn" disabled>Load score</button>
        <p class="helper-text">
          Upload a CSV or XLSX export from Customer Success Score. The file is not sent anywhere; parsing happens in your
          browser. Use the selectors to choose the snapshot date and account you want to analyze.
        </p>
      </div>
    </section>

    <section class="panel" id="account-overview">
      <h2>Account overview</h2>
      <div class="account-overview-list" id="accountOverview"></div>
    </section>

    <section class="panel" id="analysis-tabs">
      <div class="tab-container">
        <div class="tab-list" role="tablist" aria-label="Score insights">
          <button
            type="button"
            class="tab-button active"
            role="tab"
            aria-selected="true"
            aria-controls="overall-scores"
            id="tab-overall-scores"
            data-tab-target="overall-scores"
          >Overall score summary</button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            aria-selected="false"
            aria-controls="all-scored-signals"
            id="tab-all-signals"
            data-tab-target="all-scored-signals"
          >All signals</button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            aria-selected="false"
            aria-controls="technical-health-analysis"
            id="tab-technical-health"
            data-tab-target="technical-health-analysis"
          >Technical Health Analysis</button>
        </div>

        <section
          class="tab-panel-section active"
          id="overall-scores"
          role="tabpanel"
          tabindex="0"
          aria-labelledby="tab-overall-scores"
        >
          <div class="panel-header">
            <h2>Overall score summary</h2>
            <button class="export-button" type="button" id="exportOverallJson" disabled>Export to JSON</button>
          </div>
          <div class="score-summary-grid" id="overallScoreGrid"></div>
        </section>

        <section
          class="tab-panel-section"
          id="all-scored-signals"
          role="tabpanel"
          tabindex="0"
          aria-labelledby="tab-all-signals"
          hidden
        >
          <div class="panel-header">
            <h2>All scored signals</h2>
            <button class="export-button" type="button" id="exportSignalsJson" disabled>Export to JSON</button>
          </div>
          <p class="helper-text">Use the filters to explore scored or informational signals for the selected snapshot.</p>
          <div class="filters all-signals-controls">
            <select id="signalTypeFilter">
              <option value="scored" selected>Signal type: scored</option>
              <option value="informational">Signal type: informational</option>
            </select>
            <input type="search" class="signal-search" id="allSignalsSearch" placeholder="Search a signal..." />
            <select id="allSignalsCategoryFilter" class="category-filter">
              <option value="all">Category: all</option>
            </select>
            <select id="allSignalsSubcategoryFilter" disabled>
              <option value="all">Subcategory: all</option>
            </select>
            <select id="allSignalsCapabilityFilter" disabled>
              <option value="all">Capability: all</option>
            </select>
            <select id="allSignalsRatingFilter" disabled>
              <option value="all">Rating: all</option>
            </select>
          </div>
          <div id="allSignalsList"></div>
        </section>

        <section
          class="tab-panel-section"
          id="technical-health-analysis"
          role="tabpanel"
          tabindex="0"
          aria-labelledby="tab-technical-health"
          hidden
        >
          <div class="panel-header">
            <h2 class="technical-health-title">Technical Health Overview</h2>
          </div>
          <div class="technical-health-overview" id="technicalHealthOverview">
            <p class="helper-text">
              Technical Health Score metrics for the selected account and snapshot.
              Use this
              <a
                href="https://notebooklm.google.com/notebook/856445b9-ce54-46dc-b918-ba07117cb9a0"
                target="_blank"
                rel="noopener noreferrer"
              >
                NotebookLM resource
              </a>
              to get futher details on the THS signals and the scoring calculation logic.
            </p>
            <div class="technical-health-actions">
              <button
                type="button"
                class="technical-health-add-button"
                id="addCustomTechnicalHealthSignalButton"
              >
                Add custom Signal
              </button>
            </div>
            <div class="technical-health-grid" id="technicalHealthGrid" aria-live="polite"></div>
            <p class="empty-state" id="technicalHealthEmpty">Upload a file to begin the analysis.</p>
          </div>
        </section>
      </div>
    </section>

  </main>

  <div
    class="technical-health-modal"
    id="technicalHealthDeepDiveModal"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="technicalHealthDeepDiveTitle"
    tabindex="-1"
  >
    <div class="technical-health-modal-overlay" data-modal-close></div>
    <div class="technical-health-modal-dialog" role="document">
      <div class="technical-health-modal-header">
        <h2 class="technical-health-modal-title" id="technicalHealthDeepDiveTitle">Deep dive guidance</h2>
        <button class="technical-health-modal-close" type="button" data-modal-close aria-label="Close deep dive">
          ×
        </button>
      </div>
      <div class="technical-health-modal-body" id="technicalHealthDeepDiveBody">
        <p>Specific deep dive instructions for this metric will appear here.</p>
      </div>
    </div>
  </div>

  <div
    class="technical-health-modal"
    id="customTechnicalHealthModal"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="customTechnicalHealthModalTitle"
    tabindex="-1"
  >
    <div class="technical-health-modal-overlay" data-custom-modal-close></div>
    <div class="technical-health-modal-dialog" role="document">
      <form class="technical-health-custom-form" id="customTechnicalHealthForm">
        <div class="technical-health-modal-header">
          <h2 class="technical-health-modal-title" id="customTechnicalHealthModalTitle">
            Add custom technical health signal
          </h2>
          <button
            class="technical-health-modal-close"
            type="button"
            data-custom-modal-close
            aria-label="Close custom technical health signal dialog"
          >
            ×
          </button>
        </div>

        <p class="technical-health-form-description">
          Provide the same data points that appear on standard technical health cards. All fields are optional except for the
          signal name.
        </p>

        <p class="technical-health-form-error" id="customTechnicalHealthError" role="alert" hidden></p>

        <div class="technical-health-form-grid">
          <div class="technical-health-form-group">
            <label for="customSignalName">Signal name<span aria-hidden="true">*</span></label>
            <input type="text" id="customSignalName" name="customSignalName" required />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalSubcategory">Subcategory</label>
            <input type="text" id="customSignalSubcategory" name="customSignalSubcategory" placeholder="e.g., Adoption" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalCapability">Capability</label>
            <input type="text" id="customSignalCapability" name="customSignalCapability" placeholder="e.g., Usage depth" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalScore">Score</label>
            <input type="text" id="customSignalScore" name="customSignalScore" placeholder="e.g., 75" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalValue">Value (displayed next to the score)</label>
            <input type="text" id="customSignalValue" name="customSignalValue" placeholder="e.g., 250 active users" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalBenchmark">Benchmark</label>
            <input type="text" id="customSignalBenchmark" name="customSignalBenchmark" placeholder="e.g., Target ≥ 200" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalMoM">Month-over-month change</label>
            <input type="text" id="customSignalMoM" name="customSignalMoM" placeholder="e.g., +5" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalQoQ">Quarter-over-quarter change</label>
            <input type="text" id="customSignalQoQ" name="customSignalQoQ" placeholder="e.g., -2" />
          </div>

          <div class="technical-health-form-group">
            <label for="customSignalChangeDirection">Change direction override</label>
            <select id="customSignalChangeDirection" name="customSignalChangeDirection">
              <option value="auto" selected>Automatic (based on MoM/QoQ)</option>
              <option value="up">Up</option>
              <option value="down">Down</option>
              <option value="flat">Flat</option>
            </select>
          </div>

          <div class="technical-health-form-group technical-health-form-group--full">
            <label for="customSignalChangeText">Change description</label>
            <input type="text" id="customSignalChangeText" name="customSignalChangeText" placeholder="e.g., ▲ 5 MoM" />
          </div>
        </div>

        <div class="technical-health-form-group technical-health-form-group--full">
          <label for="customSignalDefinition">Definition / notes</label>
          <textarea
            id="customSignalDefinition"
            name="customSignalDefinition"
            rows="3"
            placeholder="Add context that will appear in the deep dive dialog"
          ></textarea>
        </div>

        <div class="technical-health-form-actions">
          <button type="button" class="technical-health-form-button secondary" data-custom-modal-close>Cancel</button>
          <button type="submit" class="technical-health-form-button primary">Save signal</button>
        </div>
      </form>
    </div>
  </div>

  <template id="signalTemplate">
    <article class="signal-item">
      <header>
        <div style="display:flex; flex-direction:column; gap:0.25rem;">
          <h4 data-field="signal"></h4>
          <p class="signal-definition" data-field="definition"></p>
        </div>
        <span class="badge" data-field="change"></span>
      </header>
      <p class="signal-category" data-field="category"></p>
      <div class="signal-metrics">
        <div class="score-group">
          <span data-field="score"></span>
          <span class="badge" data-field="rating"></span>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:0.5rem;">
          <span class="metric-pill" data-field="value"></span>
          <span class="metric-pill" data-field="benchmark"></span>
          <span class="metric-pill" data-field="mom"></span>
          <span class="metric-pill" data-field="qoq"></span>
        </div>
      </div>
    </article>
  </template>

  <script>
    const scoreClass = (score) => {
      if (Number.isFinite(score)) {
        if (score >= 80) return 'score-high';
        if (score >= 50) return 'score-medium';
        return 'score-low';
      }
      return 'score-medium';
    };

    const formatScore = (score, fallback) => {
      if (Number.isFinite(score)) {
        const options = Number.isInteger(score)
          ? { maximumFractionDigits: 0 }
          : { maximumFractionDigits: 2 };
        return new Intl.NumberFormat('en-US', options).format(score);
      }
      if (fallback !== undefined && fallback !== null && `${fallback}`.trim()) {
        return `${fallback}`.trim();
      }
      if (typeof score === 'string' && score.trim()) return score.trim();
      return '-';
    };

    const createScoreBadge = (score, fallback) => {
      const span = document.createElement('span');
      span.className = `score-pill ${scoreClass(score)}`;
      span.textContent = `Score ${formatScore(score, fallback)}`;
      return span;
    };

    const formatNumber = (value, options = {}) => {
      if (!Number.isFinite(value)) return '';
      const formatter = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 2,
        ...options,
      });
      return formatter.format(value);
    };

    const isNumericLikeString = (value) => {
      if (typeof value !== 'string') return false;
      const trimmed = value.trim();
      if (!trimmed) return false;
      const sanitized = trimmed.replace(/,/g, '');
      return /^[-+]?\d*(?:\.\d+)?$/.test(sanitized);
    };

    const formatNumberWithThousandSuffix = (value, options = {}) => {
      if (!Number.isFinite(value)) return '';
      const absolute = Math.abs(value);
      const sign = value < 0 ? '-' : '';
      if (absolute >= 1_000_000) {
        const formattedMillions = formatNumber(absolute / 1_000_000, {
          maximumFractionDigits: 1,
          minimumFractionDigits: 0,
        });
        return `${sign}${formattedMillions} M`;
      }
      if (absolute >= 1000) {
        const formattedThousands = formatNumber(absolute / 1000, {
          maximumFractionDigits: 1,
          minimumFractionDigits: 0,
        });
        return `${sign}${formattedThousands} K`;
      }
      return formatNumber(value, options);
    };

    const cloneForExport = (value) => {
      if (value === null || value === undefined) return value;
      if (typeof structuredClone === 'function') {
        try {
          return structuredClone(value);
        } catch (error) {
          // structuredClone may throw for unsupported types; fall back to JSON cloning.
        }
      }
      return JSON.parse(JSON.stringify(value));
    };

    const slugify = (value) => {
      if (value === null || value === undefined) return '';
      return String(value)
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .slice(0, 60);
    };

    const parseNumber = (value) => {
      if (value === null || value === undefined) return null;
      const str = String(value).trim();
      if (!str) return null;
      const sanitized = str.replace(/\s|%/g, '');
      const match = sanitized.match(/[-+]?\d+[.,]?\d*(?:[.,]\d+)?/);
      if (!match) return null;
      let numeric = match[0];
      const lastComma = numeric.lastIndexOf(',');
      const lastDot = numeric.lastIndexOf('.');
      if (lastComma > lastDot) {
        numeric = numeric.replace(/\./g, '').replace(',', '.');
      } else if (lastDot > lastComma) {
        numeric = numeric.replace(/,/g, '');
      } else {
        numeric = numeric.replace(/[.,]/g, '');
      }
      const parsed = Number(numeric);
      return Number.isFinite(parsed) ? parsed : null;
    };

    const normalizeKey = (value) => {
      if (value === null || value === undefined) return '';
      return String(value).trim().toLowerCase().replace(/\s+/g, ' ');
    };

    const createValueBandScorer = (bands) => (value) => {
      if (!Number.isFinite(value)) return null;
      for (const band of bands) {
        if (value <= band.max) {
          return band.score;
        }
      }
      return null;
    };

    const GOVERNOR_LIMITS_CALIBRATED_SCORE = createValueBandScorer([
      { max: 2950, score: 95 },
      { max: 14750, score: 85 },
      { max: 29500, score: 75 },
      { max: 59000, score: 65 },
      { max: 147500, score: 50 },
      { max: Infinity, score: 25 },
    ]);

    const UNHANDLED_EXCEPTIONS_CALIBRATED_SCORE = createValueBandScorer([
      { max: 5900, score: 95 },
      { max: 17700, score: 85 },
      { max: 35400, score: 75 },
      { max: 59000, score: 65 },
      { max: 118000, score: 50 },
      { max: Infinity, score: 25 },
    ]);

    const FAILED_LOGINS_CALIBRATED_SCORE = createValueBandScorer([
      { max: 113000, score: 95 },
      { max: 339000, score: 75 },
      { max: 565000, score: 45 },
      { max: Infinity, score: 15 },
    ]);

    const CONCURRENT_UI_ERRORS_CALIBRATED_SCORE = createValueBandScorer([
      { max: 5900, score: 95 },
      { max: 29500, score: 75 },
      { max: 59000, score: 45 },
      { max: Infinity, score: 15 },
    ]);

    const FAILED_CALLOUTS_CALIBRATED_SCORE = createValueBandScorer([
      { max: 11800, score: 95 },
      { max: 59000, score: 75 },
      { max: 118000, score: 45 },
      { max: Infinity, score: 15 },
    ]);

    const BATCH_FAILURES_CALIBRATED_SCORE = createValueBandScorer([
      { max: 590, score: 95 },
      { max: 2950, score: 75 },
      { max: 5900, score: 45 },
      { max: Infinity, score: 15 },
    ]);

    const SPECIAL_SIGNAL_SCORE_RULES = [
      {
        aliases: ['governor limits (gacks)'],
        scorer: GOVERNOR_LIMITS_CALIBRATED_SCORE,
      },
      {
        aliases: ['unhandled exceptions'],
        scorer: UNHANDLED_EXCEPTIONS_CALIBRATED_SCORE,
      },
      {
        aliases: ['failed logins', 'failed login attempts'],
        scorer: FAILED_LOGINS_CALIBRATED_SCORE,
      },
      {
        aliases: ['concurrent ui errors'],
        scorer: CONCURRENT_UI_ERRORS_CALIBRATED_SCORE,
      },
      {
        aliases: ['failed callouts'],
        scorer: FAILED_CALLOUTS_CALIBRATED_SCORE,
      },
      {
        aliases: ['batch failures'],
        scorer: BATCH_FAILURES_CALIBRATED_SCORE,
      },
    ];

    const computeSpecialSignalScore = (signal) => {
      if (!signal) return null;
      const normalizedName = normalizeKey(signal.signalName || signal.metricName || '');
      const rule = SPECIAL_SIGNAL_SCORE_RULES.find((entry) =>
        entry.aliases.some((alias) => normalizedName === alias || normalizedName.startsWith(`${alias} `))
      );
      if (!rule) return null;
      return rule.scorer(signal.valueNumeric);
    };

    const TECH_HEALTH_SCORED_STRUCTURE = [
      {
        name: 'Efficiency',
        weight: 0.52,
        capabilities: [
          {
            name: 'User Experience Efficiency',
            signals: [
              { name: 'EPT Page Load Time', aliases: ['experience page time (ept)', 'average page load time'] },
              { name: 'Concurrent UI Errors' },
              { name: 'Logins' },
              { name: 'Failed Logins' },
            ],
          },
          {
            name: 'Integration Efficiency',
            signals: [
              { name: 'Concurrent API Errors' },
              { name: 'API performance', aliases: ['api performance score', 'api performance index'] },
              { name: 'Failed Callouts' },
            ],
          },
          {
            name: 'Transaction Efficiency',
            signals: [
              { name: 'Governor Limits (GACKS)', aliases: ['governor limits'] },
              { name: 'Concurrent Apex Errors' },
              { name: 'CPU Timeout Errors', aliases: ['apex cpu time out errors', 'apex cpu timeout errors'] },
              { name: 'Unhandled Exceptions' },
              { name: 'Rowlock Errors', aliases: ['rowlock error rates', 'row lock errors'] },
              { name: 'Batch Failures' },
              { name: 'Transactions' },
            ],
          },
          {
            name: 'Data Efficiency',
            signals: [{ name: 'Heap Size Errors', aliases: ['apex heap size errors'] }],
          },
        ],
      },
      {
        name: 'Operational Excellence',
        weight: 0.28,
        capabilities: [
          {
            name: 'Tech Debt',
            signals: [
              { name: 'Process Builder Workflows' },
              { name: 'Workflow Rules' },
            ],
          },
          {
            name: 'Best Practices',
            signals: [{ name: 'Core Deployed on Hyperforce' }],
          },
        ],
      },
      {
        name: 'Customization',
        weight: 0.1,
        capabilities: [
          {
            name: 'Org Security',
            signals: [
              { name: 'SSO Enabled', aliases: ['single sign-on (sso) enabled'] },
              { name: 'Core MFA Enabled', aliases: ['mfa enabled', 'mfa enforcement'] },
              { name: 'Maximum Invalid Login Attempts' },
              { name: 'Minimum Password Length' },
              { name: 'Minimum Password Lifetime Requirement' },
              { name: 'Password Complexity Requirement' },
              { name: 'Password Expiration' },
              { name: 'Password History Restriction' },
              { name: 'Password Lockout Period' },
              { name: 'Password Question Requirement' },
              { name: 'Obscure Secret Answer for Password' },
            ],
          },
          {
            name: 'Security configurations',
            signals: [
              { name: 'Prompt Injection Detection Enabled' },
              { name: 'Toxicity Detection in Prompts Enabled' },
            ],
          },
        ],
      },
      {
        name: 'Observability',
        weight: 0.1,
        capabilities: [
          {
            name: 'Monitoring',
            signals: [{ name: 'ProM Enabled' }],
          },
          {
            name: 'Diagnostics',
            signals: [
              { name: 'Scale Center Adoption' },
              { name: 'ApexGuru Adoption', aliases: ['apex guru adoption'] },
            ],
          },
        ],
      },
    ];

    const TECH_HEALTH_INFORMATIONAL_SUBCATEGORY = 'Informational Signals';
    const TECH_HEALTH_DEFAULT_SCORE_SIGNALS = new Set(['transactions', 'logins']);

    const { capabilityMap: TECH_HEALTH_CAPABILITY_LOOKUP, signalMap: TECH_HEALTH_SIGNAL_LOOKUP } = (() => {
      const capabilityMap = new Map();
      const signalMap = new Map();

      const registerSignal = (entry, signalName) => {
        const key = normalizeKey(signalName);
        if (!key) return;
        if (!signalMap.has(key)) {
          signalMap.set(key, {
            capabilityName: entry.name,
            subcategoryName: entry.subcategoryName,
            subcategoryWeight: entry.subcategoryWeight,
          });
        }
      };

      TECH_HEALTH_SCORED_STRUCTURE.forEach((subcategory) => {
        subcategory.capabilities.forEach((capability) => {
          const capabilityKey = normalizeKey(capability.name);
          if (!capabilityKey) return;

          const baseEntry = {
            name: capability.name,
            subcategoryName: subcategory.name,
            subcategoryWeight: subcategory.weight,
          };

          capabilityMap.set(capabilityKey, baseEntry);

          capability.signals.forEach((signal) => {
            const descriptor = typeof signal === 'string' ? { name: signal } : signal;
            registerSignal(baseEntry, descriptor.name);
            if (Array.isArray(descriptor.aliases)) {
              descriptor.aliases.forEach((alias) => registerSignal(baseEntry, alias));
            }
          });
        });
      });

      return { capabilityMap, signalMap };
    })();

    const usesDefaultTechnicalHealthScore = (signal) => {
      if (!signal) return false;
      const nameKey = normalizeKey(signal.signalName || signal.metricName || '');
      if (!nameKey) return false;
      return TECH_HEALTH_DEFAULT_SCORE_SIGNALS.has(nameKey);
    };

    const getTechnicalHealthScoreValue = (signal) => {
      if (usesDefaultTechnicalHealthScore(signal)) return 100;
      return signal?.score;
    };

    const getTechnicalHealthScoreFallback = (signal, scoreValue) => {
      if (usesDefaultTechnicalHealthScore(signal)) {
        if (Number.isFinite(scoreValue)) return scoreValue;
        return '100';
      }
      return signal?.scoreRaw ?? signal?.score;
    };

    const classifySignal = (row) => {
      const categoryKey = normalizeKey(row.categoryName);
      if (categoryKey !== 'technical health') {
        return { type: 'scored' };
      }

      const capabilityKey = normalizeKey(row.capabilityName);
      const signalKey = normalizeKey(row.signalName);

      if (signalKey && TECH_HEALTH_SIGNAL_LOOKUP.has(signalKey)) {
        const match = TECH_HEALTH_SIGNAL_LOOKUP.get(signalKey);
        return {
          type: 'scored',
          subcategoryName: match.subcategoryName || row.subcategoryName,
          subcategoryWeight: match.subcategoryWeight,
          capabilityName: match.capabilityName || row.capabilityName,
        };
      }

      if (capabilityKey && TECH_HEALTH_CAPABILITY_LOOKUP.has(capabilityKey)) {
        const capability = TECH_HEALTH_CAPABILITY_LOOKUP.get(capabilityKey);
        return {
          type: 'informational',
          subcategoryName: capability.subcategoryName || row.subcategoryName,
          subcategoryWeight: capability.subcategoryWeight,
          capabilityName: capability.name || row.capabilityName,
        };
      }

      return {
        type: 'informational',
        subcategoryName: TECH_HEALTH_INFORMATIONAL_SUBCATEGORY,
        capabilityName:
          row.capabilityName ||
          row.subcategoryName ||
          TECH_HEALTH_INFORMATIONAL_SUBCATEGORY,
      };
    };

    const normalizeDateValue = (value) => {
      if (value === null || value === undefined || value === '') return '';
      if (value instanceof Date && !Number.isNaN(value.getTime())) {
        return value.toISOString().split('T')[0];
      }
      if (typeof value === 'number' && Number.isFinite(value)) {
        if (window.XLSX?.SSF?.parse_date_code) {
          const parsed = window.XLSX.SSF.parse_date_code(value);
          if (parsed) {
            const date = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d));
            if (!Number.isNaN(date.getTime())) {
              return date.toISOString().split('T')[0];
            }
          }
        }
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        const date = new Date(excelEpoch.getTime() + value * 86400000);
        if (!Number.isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
      }
      if (typeof value === 'string') {
        return value.trim();
      }
      return value;
    };

    const ratingFromScore = (score) => {
      if (!Number.isFinite(score)) return '';
      if (score >= 61) return 'Excellent';
      if (score >= 31) return 'Good';
      return 'Fair';
    };

    const formatSigned = (value) => {
      if (!Number.isFinite(value)) return '';
      if (value === 0) return '0';
      const formatted = formatNumber(Math.abs(value));
      return `${value > 0 ? '+' : '-'}${formatted}`;
    };

    const changePiece = (value, label) => {
      if (!Number.isFinite(value)) return null;
      const formatted = formatNumber(Math.abs(value));
      const direction = value > 0 ? '↑' : value < 0 ? '↓' : '→';
      return `${direction} ${formatted} ${label}`;
    };

    const buildChangeLabel = (mom, qoq) => {
      return [changePiece(mom, 'MoM'), changePiece(qoq, 'QoQ')]
        .filter(Boolean)
        .join(' • ');
    };

    const evaluateBenchmark = (valueNumeric, benchmarkRaw) => {
      if (!Number.isFinite(valueNumeric)) return null;
      if (!benchmarkRaw) return null;
      const cleaned = benchmarkRaw.replace(/\s/g, '');
      const match = cleaned.match(/(<=|>=|<|>|=)\s*([-+]?\d+[.,]?\d*(?:[.,]\d+)?)/);
      if (!match) return null;
      const operator = match[1];
      const threshold = parseNumber(match[2]);
      if (!Number.isFinite(threshold)) return null;
      switch (operator) {
        case '<=':
          return valueNumeric <= threshold ? 'met' : 'missed';
        case '>=':
          return valueNumeric >= threshold ? 'met' : 'missed';
        case '<':
          return valueNumeric < threshold ? 'met' : 'missed';
        case '>':
          return valueNumeric > threshold ? 'met' : 'missed';
        case '=':
          return valueNumeric === threshold ? 'met' : 'missed';
        default:
          return null;
      }
    };

    const splitCSVLine = (line) => {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const char = line[i];
        if (char === '"') {
          const next = line[i + 1];
          if (inQuotes && next === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    };

    const parseCSV = (text) => {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = [];
      let buffer = '';
      let inQuotes = false;
      for (let i = 0; i < normalized.length; i += 1) {
        const char = normalized[i];
        if (char === '"') {
          const next = normalized[i + 1];
          if (inQuotes && next === '"') {
            buffer += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === '\n' && !inQuotes) {
          lines.push(buffer);
          buffer = '';
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        lines.push(buffer);
      }
      const filtered = lines.filter((line) => line.trim().length);
      if (!filtered.length) return [];
      const headerCells = splitCSVLine(filtered.shift());
      if (!headerCells.length) return [];
      headerCells[0] = headerCells[0].replace(/^\uFEFF/, '');
      const headers = headerCells.map((cell) => cell.trim());
      const rows = [];
      for (const line of filtered) {
        const cells = splitCSVLine(line).map((cell) => cell.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = cells[index] ?? '';
        });
        const hasData = Object.values(row).some((value) => value && `${value}`.trim().length);
        if (hasData) {
          rows.push(row);
        }
      }
      return rows;
    };

    const SIGNAL_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      'Subcategory Name': 'subcategoryName',
      'Capability Name': 'capabilityName',
      'Signal Name': 'signalName',
      Definition: 'definition',
      Score: 'scoreRaw',
      Value: 'value',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
      Benchmark: 'benchmark',
    };

    const OVERALL_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Score Name': 'scoreName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const CATEGORY_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const SUBCATEGORY_COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      'Subcategory Name': 'subcategoryName',
      Score: 'scoreRaw',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
    };

    const normalizeSignalRow = (row) => {
      const normalized = {};
      for (const [column, key] of Object.entries(SIGNAL_COLUMN_MAP)) {
        const value = row[column] ?? row[column.replace(/\s+/g, ' ')] ?? '';
        if (key === 'snapshotDate') {
          normalized[key] = normalizeDateValue(value);
        } else if (typeof value === 'string') {
          normalized[key] = value.trim();
        } else {
          normalized[key] = value;
        }
      }
      normalized.score = parseNumber(normalized.scoreRaw);
      normalized.valueNumeric = parseNumber(normalized.value);
      normalized.moMChange = parseNumber(normalized.moMChangeRaw);
      normalized.qoQChange = parseNumber(normalized.qoQChangeRaw);
      if (!Number.isFinite(normalized.score)) {
        const calibratedScore = computeSpecialSignalScore(normalized);
        if (Number.isFinite(calibratedScore)) {
          normalized.score = calibratedScore;
          normalized.scoreRaw = formatScore(calibratedScore);
        }
      }
      return normalized;
    };

    const normalizeScoreRow = (row, columnMap) => {
      const normalized = {};
      for (const [column, key] of Object.entries(columnMap)) {
        const value = row[column] ?? row[column.replace(/\s+/g, ' ')] ?? '';
        if (key === 'snapshotDate') {
          normalized[key] = normalizeDateValue(value);
        } else if (typeof value === 'string') {
          normalized[key] = value.trim();
        } else {
          normalized[key] = value;
        }
      }
      normalized.score = parseNumber(normalized.scoreRaw);
      normalized.moMChange = parseNumber(normalized.moMChangeRaw);
      normalized.qoQChange = parseNumber(normalized.qoQChangeRaw);
      return normalized;
    };

    const formatChangeDisplay = (value, raw) => {
      const formatted = formatSigned(value);
      if (formatted) return formatted;
      if (typeof raw === 'string' && raw.trim()) return raw.trim();
      return '';
    };

    const transformSignalRow = (row) => {
      const processed = { ...row };
      const classification = classifySignal(row);
      processed.signalType = classification.type;
      processed.isScored = classification.type === 'scored';
      processed.isInformational = classification.type === 'informational';
      if (classification.subcategoryName) {
        processed.technicalHealthSubcategory = classification.subcategoryName;
      }
      if (typeof classification.subcategoryWeight === 'number') {
        processed.technicalHealthSubcategoryWeight = classification.subcategoryWeight;
      }
      if (classification.capabilityName) {
        processed.technicalHealthCapability = classification.capabilityName;
      }
      processed.rating = ratingFromScore(row.score);
      processed.categoryDescription = [row.categoryName, row.subcategoryName, row.capabilityName]
        .filter(Boolean)
        .join(' • ');
      processed.changeText = buildChangeLabel(row.moMChange, row.qoQChange);
      processed.changeDirection =
        row.moMChange > 0 || row.qoQChange > 0
          ? 'up'
          : row.moMChange < 0 || row.qoQChange < 0
          ? 'down'
          : 'flat';
      processed.momText = formatChangeDisplay(row.moMChange, row.moMChangeRaw);
      processed.qoqText = formatChangeDisplay(row.qoQChange, row.qoQChangeRaw);
      processed.valueDisplay = (() => {
        const rawValue = row.value && `${row.value}`.trim();
        if (rawValue) {
          if (Number.isFinite(row.valueNumeric) && isNumericLikeString(rawValue)) {
            return formatNumberWithThousandSuffix(row.valueNumeric);
          }
          return rawValue;
        }
        if (Number.isFinite(row.valueNumeric)) {
          return formatNumberWithThousandSuffix(row.valueNumeric);
        }
        return '';
      })();
      const benchmarkStatus = evaluateBenchmark(row.valueNumeric, row.benchmark);
      processed.benchmarkStatus = benchmarkStatus;
      processed.benchmarkDisplay = row.benchmark
        ? `${row.benchmark}${benchmarkStatus ? ` • ${benchmarkStatus}` : ''}`
        : '';
      return processed;
    };

    const decorateSummaryRow = (row) => {
      const decorated = { ...row };
      decorated.rating = ratingFromScore(row.score);
      decorated.changeText = buildChangeLabel(row.moMChange, row.qoQChange);
      decorated.momText = formatChangeDisplay(row.moMChange, row.moMChangeRaw);
      decorated.qoqText = formatChangeDisplay(row.qoQChange, row.qoQChangeRaw);
      return decorated;
    };

    const buildCategoryHierarchy = (signals, categorySummaries = [], subcategorySummaries = []) => {
      const categoryMap = new Map();

      const ensureCategory = (name) => {
        const key = name || 'Uncategorized';
        if (!categoryMap.has(key)) {
          categoryMap.set(key, {
            name: key,
            score: null,
            scoreRaw: null,
            moMChange: null,
            moMChangeRaw: null,
            qoQChange: null,
            qoQChangeRaw: null,
            changeText: '',
            rating: '',
            momText: '',
            qoqText: '',
            subcategories: new Map(),
          });
        }
        return categoryMap.get(key);
      };

      const ensureSubcategory = (category, name) => {
        const key = name || 'General';
        if (!category.subcategories.has(key)) {
          category.subcategories.set(key, {
            name: key,
            score: null,
            scoreRaw: null,
            moMChange: null,
            moMChangeRaw: null,
            qoQChange: null,
            qoQChangeRaw: null,
            changeText: '',
            rating: '',
            momText: '',
            qoqText: '',
            capabilities: new Map(),
          });
        }
        return category.subcategories.get(key);
      };

      const ensureCapability = (subcategory, name) => {
        const key = name || 'General';
        if (!subcategory.capabilities.has(key)) {
          subcategory.capabilities.set(key, {
            name: key,
            score: null,
            scoreRaw: null,
            moMChange: null,
            moMChangeRaw: null,
            qoQChange: null,
            qoQChangeRaw: null,
            changeText: '',
            rating: '',
            momText: '',
            qoqText: '',
            signals: [],
          });
        }
        return subcategory.capabilities.get(key);
      };

      signals.forEach((signal) => {
        const category = ensureCategory(signal.categoryName);
        const subcategory = ensureSubcategory(category, signal.subcategoryName);
        const capability = ensureCapability(subcategory, signal.capabilityName);
        capability.signals.push(signal);
      });

      categorySummaries.forEach((summary) => {
        const decorated = decorateSummaryRow(summary);
        const category = ensureCategory(decorated.categoryName);
        if (Number.isFinite(decorated.score)) category.score = decorated.score;
        category.scoreRaw = decorated.scoreRaw ?? category.scoreRaw;
        if (Number.isFinite(decorated.moMChange)) category.moMChange = decorated.moMChange;
        category.moMChangeRaw = decorated.moMChangeRaw ?? category.moMChangeRaw;
        if (Number.isFinite(decorated.qoQChange)) category.qoQChange = decorated.qoQChange;
        category.qoQChangeRaw = decorated.qoQChangeRaw ?? category.qoQChangeRaw;
        category.changeText = decorated.changeText || category.changeText;
        category.rating = decorated.rating || category.rating;
        category.momText = decorated.momText || category.momText;
        category.qoqText = decorated.qoqText || category.qoqText;
      });

      subcategorySummaries.forEach((summary) => {
        const decorated = decorateSummaryRow(summary);
        const category = ensureCategory(decorated.categoryName);
        const subcategory = ensureSubcategory(category, decorated.subcategoryName);
        if (Number.isFinite(decorated.score)) subcategory.score = decorated.score;
        subcategory.scoreRaw = decorated.scoreRaw ?? subcategory.scoreRaw;
        if (Number.isFinite(decorated.moMChange)) subcategory.moMChange = decorated.moMChange;
        subcategory.moMChangeRaw = decorated.moMChangeRaw ?? subcategory.moMChangeRaw;
        if (Number.isFinite(decorated.qoQChange)) subcategory.qoQChange = decorated.qoQChange;
        subcategory.qoQChangeRaw = decorated.qoQChangeRaw ?? subcategory.qoQChangeRaw;
        subcategory.changeText = decorated.changeText || subcategory.changeText;
        subcategory.rating = decorated.rating || subcategory.rating;
        subcategory.momText = decorated.momText || subcategory.momText;
        subcategory.qoqText = decorated.qoqText || subcategory.qoqText;
      });

      const categories = [];
      for (const category of categoryMap.values()) {
        category.rating = category.rating || ratingFromScore(category.score);
        category.changeText = category.changeText || buildChangeLabel(category.moMChange, category.qoQChange);
        category.momText = category.momText || formatSigned(category.moMChange);
        category.qoqText = category.qoqText || formatSigned(category.qoQChange);

        const subcategories = [];
        for (const subcategory of category.subcategories.values()) {
          subcategory.rating = subcategory.rating || ratingFromScore(subcategory.score);
          subcategory.changeText = subcategory.changeText || buildChangeLabel(subcategory.moMChange, subcategory.qoQChange);
          subcategory.momText = subcategory.momText || formatSigned(subcategory.moMChange);
          subcategory.qoqText = subcategory.qoqText || formatSigned(subcategory.qoQChange);

          const capabilities = [];
          for (const capability of subcategory.capabilities.values()) {
            const representativeSignal = capability.signals.find((signal) => signal.isScored) || capability.signals[0];
            const score = Number.isFinite(capability.score)
              ? capability.score
              : representativeSignal?.score ?? null;
            const scoreRaw = capability.scoreRaw ?? representativeSignal?.scoreRaw ?? null;
            const mom = Number.isFinite(capability.moMChange)
              ? capability.moMChange
              : representativeSignal?.moMChange ?? null;
            const qoq = Number.isFinite(capability.qoQChange)
              ? capability.qoQChange
              : representativeSignal?.qoQChange ?? null;
            capabilities.push({
              name: capability.name,
              score,
              scoreRaw,
              rating: capability.rating || ratingFromScore(score),
              changeText: capability.changeText || representativeSignal?.changeText || '',
              momChange: mom,
              qoQChange: qoq,
              momText: capability.momText || representativeSignal?.momText || '',
              qoqText: capability.qoqText || representativeSignal?.qoqText || '',
              signals: capability.signals,
            });
          }

          subcategories.push({
            name: subcategory.name,
            score: subcategory.score,
            scoreRaw: subcategory.scoreRaw,
            rating: subcategory.rating,
            changeText: subcategory.changeText,
            momChange: subcategory.moMChange,
            qoQChange: subcategory.qoQChange,
            momText: subcategory.momText,
            qoqText: subcategory.qoqText,
            capabilities: capabilities.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity)),
          });
        }

        categories.push({
          name: category.name,
          score: category.score,
          scoreRaw: category.scoreRaw,
          rating: category.rating,
          changeText: category.changeText,
          momChange: category.moMChange,
          qoQChange: category.qoQChange,
          momText: category.momText,
          qoqText: category.qoqText,
          subcategories: subcategories.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity)),
        });
      }

      return categories.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity));
    };

    const createInfoCard = (title, main, subtitle) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'account-overview-item';

      const label = document.createElement('span');
      label.className = 'account-overview-label';
      label.textContent = title;

      const value = document.createElement('span');
      value.className = 'account-overview-value';
      value.textContent = main;

      wrapper.append(label, value);

      if (subtitle) {
        const subtitleEl = document.createElement('span');
        subtitleEl.className = 'account-overview-subtitle';
        subtitleEl.textContent = subtitle;
        wrapper.appendChild(subtitleEl);
      }

      return wrapper;
    };

    const formatSnapshotMonth = (snapshotDate) => {
      if (!snapshotDate) {
        return 'N/A';
      }

      const trimmed = `${snapshotDate}`.trim();
      const isoMatch = trimmed.match(/^(\d{4})-(\d{1,2})(?:-(\d{1,2}))?$/);
      let parsed = null;

      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        parsed = new Date(Number(year), Number(month) - 1, Number(day || 1));
      } else {
        const attempt = new Date(trimmed);
        if (!Number.isNaN(attempt.getTime())) {
          parsed = attempt;
        }
      }

      if ((!parsed || Number.isNaN(parsed.getTime())) && trimmed.includes('/')) {
        const parts = trimmed.split('/').map((part) => part.trim());
        if (parts.length === 3) {
          if (parts[0].length === 4) {
            const [year, month, day] = parts.map((part) => Number.parseInt(part, 10));
            parsed = new Date(year, (month || 1) - 1, day || 1);
          } else if (parts[2].length === 4) {
            const [first, second, year] = parts.map((part) => Number.parseInt(part, 10));
            const month = Number.isFinite(first) ? first : 1;
            parsed = new Date(year, (month || 1) - 1, Number.isFinite(second) ? second : 1);
          }
        }
      }

      if (!parsed || Number.isNaN(parsed.getTime())) {
        return snapshotDate;
      }

      return parsed.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    };

    const populateAccountOverview = (info, snapshotDate, accountName) => {
      const container = document.getElementById('accountOverview');
      container.innerHTML = '';
      const details = info || {};
      const overviewEntries = [];
      const appendEntry = (label, value, subtitle) => {
        let normalizedValue = value;
        if (normalizedValue === undefined || normalizedValue === null) {
          normalizedValue = 'N/A';
        } else if (typeof normalizedValue === 'string' && normalizedValue.trim() === '') {
          normalizedValue = 'N/A';
        }
        const entry = { label, value: normalizedValue };
        if (subtitle) entry.subtitle = subtitle;
        overviewEntries.push(entry);
        container.appendChild(createInfoCard(label, normalizedValue, subtitle));
      };

      const primaryAccountName = accountName || details.accountName || 'N/A';
      appendEntry('Company', details.companyName || 'N/A');
      appendEntry('Account name', primaryAccountName);

      const localName = details.accountLocalName;
      if (localName && localName !== primaryAccountName) {
        appendEntry('Account local name', localName);
      }

      const formattedSnapshot = formatSnapshotMonth(snapshotDate);
      appendEntry('Snapshot date', formattedSnapshot);

      if (details.successPlan) {
        appendEntry('Success plan', details.successPlan);
      }

      if (details.tenantType) {
        appendEntry('Tenant type', details.tenantType);
      }

      currentAccountContext = {
        entries: overviewEntries,
        accountName: primaryAccountName,
        accountLocalName: localName || '',
        companyName: details.companyName || 'N/A',
        snapshotDateRaw: snapshotDate || '',
        snapshotDateFormatted: formattedSnapshot,
        successPlan: details.successPlan || '',
        tenantType: details.tenantType || '',
      };
    };

    const createMetricPill = (label, value) => {
      if (value === null || value === undefined || `${value}`.trim() === '') return null;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      pill.innerHTML = `<strong>${label}</strong> ${value}`;
      return pill;
    };

    const createChangeBadge = (changeText, momChange, qoQChange) => {
      if (!changeText) return null;
      const direction =
        (Number.isFinite(momChange) && momChange > 0) || (Number.isFinite(qoQChange) && qoQChange > 0)
          ? 'up'
          : (Number.isFinite(momChange) && momChange < 0) || (Number.isFinite(qoQChange) && qoQChange < 0)
          ? 'down'
          : '';
      const badge = document.createElement('span');
      badge.className = ['badge', direction].filter(Boolean).join(' ');
      badge.textContent = changeText;
      return badge;
    };

    const buildTreeMetrics = (entry) => {
      const metrics = document.createElement('div');
      metrics.className = 'score-tree-metrics';
      const parts = [];

      if (Number.isFinite(entry.score) || (entry.scoreRaw && `${entry.scoreRaw}`.trim())) {
        parts.push(createScoreBadge(entry.score, entry.scoreRaw ?? entry.score));
      }

      if (entry.rating) {
        const ratingBadge = document.createElement('span');
        ratingBadge.className = 'badge';
        ratingBadge.textContent = entry.rating;
        parts.push(ratingBadge);
      }

      const changeBadge = createChangeBadge(entry.changeText, entry.momChange, entry.qoQChange);
      if (changeBadge) {
        parts.push(changeBadge);
      }

      const momLabel = entry.momText ?? formatSigned(entry.momChange);
      const momPill = createMetricPill('MoM', momLabel);
      if (momPill) {
        parts.push(momPill);
      }

      const qoqLabel = entry.qoqText ?? formatSigned(entry.qoQChange);
      const qoqPill = createMetricPill('QoQ', qoqLabel);
      if (qoqPill) {
        parts.push(qoqPill);
      }

      if (!parts.length) return null;
      parts.forEach((part) => metrics.appendChild(part));
      return metrics;
    };

    const createScoreTreeNode = (entry = {}, level = 'category') => {
      const wrapper = document.createElement('div');
      wrapper.className = 'score-tree-node';

      if (level === 'category') {
        wrapper.classList.add('score-tree-category');
      } else if (level === 'subcategory') {
        wrapper.classList.add('score-tree-subcategory');
      }

      const label = document.createElement('span');
      label.className = 'score-tree-label';
      const fallbackLabel =
        level === 'category' ? 'Category' : level === 'subcategory' ? 'Subcategory' : 'Capability';
      label.textContent = entry.title || entry.name || fallbackLabel;
      wrapper.appendChild(label);

      const metrics = buildTreeMetrics(entry);
      if (metrics) {
        wrapper.appendChild(metrics);
      }

      const hasMetrics = Boolean(metrics);
      if (!hasMetrics || entry.isPlaceholder || entry.placeholder) {
        wrapper.classList.add('score-tree-placeholder');
      }

      return wrapper;
    };

    const createTreeNodeWrapper = (entry, level) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'score-tree-node';
      if (level === 'category') {
        wrapper.classList.add('score-tree-category');
      } else if (level === 'subcategory') {
        wrapper.classList.add('score-tree-subcategory');
      }
      if (!Number.isFinite(entry.score) && !(entry.scoreRaw && `${entry.scoreRaw}`.trim())) {
        wrapper.classList.add('score-tree-placeholder');
      }

      const label = document.createElement('span');
      label.className = 'score-tree-label';
      if (entry && entry.name) {
        label.textContent = entry.name;
      } else if (level === 'category') {
        label.textContent = 'Category';
      } else if (level === 'subcategory') {
        label.textContent = 'Subcategory';
      } else {
        label.textContent = 'Capability';
      }
      wrapper.appendChild(label);

      const metrics = buildTreeMetrics(entry || {});
      if (metrics) {
        wrapper.appendChild(metrics);
      }

      return wrapper;
    };

    const createSignalTreeItem = (signal) => {
      const item = document.createElement('li');
      const wrapper = document.createElement('div');
      wrapper.className = 'score-tree-node score-tree-placeholder';

      const label = document.createElement('span');
      label.className = 'score-tree-label';
      label.textContent =
        (signal && (signal.signalName || signal.name || signal.metricName || signal.title)) || 'Signal';
      wrapper.appendChild(label);

      if (Number.isFinite(signal?.score)) {
        const metrics = document.createElement('div');
        metrics.className = 'score-tree-metrics';
        metrics.appendChild(createScoreBadge(signal.score, signal.scoreRaw));
        wrapper.appendChild(metrics);
      }

      item.appendChild(wrapper);
      return item;
    };

    const createCapabilityTreeItem = (capability) => {
      const item = document.createElement('li');
      item.appendChild(createTreeNodeWrapper(capability || {}, 'capability'));

      if (Array.isArray(capability?.signals) && capability.signals.length) {
        const signalsList = document.createElement('ul');
        signalsList.className = 'score-tree-children';
        capability.signals.forEach((signal) => {
          signalsList.appendChild(createSignalTreeItem(signal));
        });
        item.appendChild(signalsList);
      }

      return item;
    };

    const createSubcategoryTreeItem = (subcategory) => {
      const item = document.createElement('li');
      item.appendChild(createTreeNodeWrapper(subcategory || {}, 'subcategory'));

      if (Array.isArray(subcategory?.capabilities) && subcategory.capabilities.length) {
        const capabilitiesList = document.createElement('ul');
        capabilitiesList.className = 'score-tree-children';
        subcategory.capabilities.forEach((capability) => {
          capabilitiesList.appendChild(createCapabilityTreeItem(capability));
        });
        item.appendChild(capabilitiesList);
      }

      return item;
    };

    const createCategoryTreeItem = (category) => {
      const item = document.createElement('li');
      item.appendChild(createTreeNodeWrapper(category || {}, 'category'));

      if (Array.isArray(category?.subcategories) && category.subcategories.length) {
        const subcategoryList = document.createElement('ul');
        subcategoryList.className = 'score-tree-children';
        category.subcategories.forEach((subcategory) => {
          subcategoryList.appendChild(createSubcategoryTreeItem(subcategory));
        });
        item.appendChild(subcategoryList);
      }

      return item;
    };

    const createScoreTree = (categories = []) => {
      if (!Array.isArray(categories) || !categories.length) return null;
      const tree = document.createElement('ul');
      tree.className = 'score-tree';
      categories.forEach((category) => {
        tree.appendChild(createCategoryTreeItem(category));
      });
      return tree;
    };

    const createSignalItem = (item) => {
      const clone = document.getElementById('signalTemplate').content.firstElementChild.cloneNode(true);
      clone.querySelector('[data-field="signal"]').textContent = item.signalName;
      const definitionElement = clone.querySelector('[data-field="definition"]');
      if (item.definition) {
        definitionElement.textContent = item.definition;
      } else {
        definitionElement.remove();
      }
      const categoryElement = clone.querySelector('[data-field="category"]');
      categoryElement.textContent = item.categoryDescription || item.categoryName || '';

      const changeSpan = clone.querySelector('[data-field="change"]');
      if (item.changeText) {
        changeSpan.textContent = item.changeText;
        if (item.moMChange > 0 || item.qoQChange > 0) {
          changeSpan.classList.add('up');
        } else if (item.moMChange < 0 || item.qoQChange < 0) {
          changeSpan.classList.add('down');
        }
      } else {
        changeSpan.remove();
      }

      const scorePlaceholder = clone.querySelector('[data-field="score"]');
      const scoreBadge = createScoreBadge(item.score, item.scoreRaw);
      scorePlaceholder.replaceWith(scoreBadge);

      const ratingBadge = clone.querySelector('[data-field="rating"]');
      if (item.rating) {
        ratingBadge.textContent = item.rating;
      } else {
        ratingBadge.remove();
      }

      const valuePill = clone.querySelector('[data-field="value"]');
      if (item.valueDisplay) {
        valuePill.innerHTML = `<strong>Value</strong> ${item.valueDisplay}`;
      } else {
        valuePill.remove();
      }

      const benchmarkPill = clone.querySelector('[data-field="benchmark"]');
      if (item.benchmarkDisplay) {
        benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmarkDisplay}`;
      } else if (item.benchmark) {
        benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmark}`;
      } else {
        benchmarkPill.remove();
      }

      const momPill = clone.querySelector('[data-field="mom"]');
      if (item.momText) {
        momPill.innerHTML = `<strong>MoM</strong> ${item.momText}`;
      } else {
        momPill.remove();
      }

      const qoqPill = clone.querySelector('[data-field="qoq"]');
      if (item.qoqText) {
        qoqPill.innerHTML = `<strong>QoQ</strong> ${item.qoqText}`;
      } else {
        qoqPill.remove();
      }

      return clone;
    };

    const populateGroupedSignals = (signals, container) => {
      container.innerHTML = '';
      if (!signals.length) {
        const empty = document.createElement('p');
        empty.className = 'empty-state';
        empty.textContent = 'No signals match the current filters.';
        container.appendChild(empty);
        return;
      }

      const map = new Map();
      for (const signal of signals) {
        const category = signal.categoryName || 'Uncategorized';
        if (!map.has(category)) {
          map.set(category, []);
        }
        map.get(category).push(signal);
      }

      for (const [category, items] of map) {
        const accordion = document.createElement('details');
        accordion.className = 'accordion';
        const summary = document.createElement('summary');
        const title = document.createElement('span');
        title.className = 'accordion-title';
        title.textContent = category;
        summary.appendChild(title);
        const categorySummary = currentCategorySummaries.get(category);
        const representativeSignal =
          items.find((item) => Number.isFinite(item.score)) || items.find((item) => item.scoreRaw);
        const badgeScore = categorySummary?.score ?? representativeSignal?.score ?? null;
        const badgeFallback =
          categorySummary?.scoreRaw ?? representativeSignal?.scoreRaw ?? categorySummary?.score ?? representativeSignal?.score;
        summary.appendChild(createScoreBadge(badgeScore, badgeFallback));
        accordion.appendChild(summary);

        const content = document.createElement('div');
        content.className = 'accordion-content';
        const list = document.createElement('div');
        list.className = 'signal-list';
        items.forEach((item) => list.appendChild(createSignalItem(item)));
        content.appendChild(list);
        accordion.appendChild(content);
        container.appendChild(accordion);
      }
    };

    const populateOverallScores = (overallRows, categoryBreakdown = []) => {
      const container = document.getElementById('overallScoreGrid');
      container.innerHTML = '';

      const summaries = [];
      overallRows.forEach((row) => {
        const decorated = decorateSummaryRow(row);
        summaries.push({ ...decorated, title: row.scoreName || 'Overall score' });
      });

      const hasCategories = Array.isArray(categoryBreakdown) && categoryBreakdown.length > 0;

      if (!summaries.length && !hasCategories) {
        currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
        if (exportOverallButton) exportOverallButton.disabled = true;
        container.innerHTML = '<p class="empty-state">No overall scores available for the current selection.</p>';
        return;
      }

      currentOverallSummaryData = {
        summaries: cloneForExport(summaries),
        categoryBreakdown: hasCategories ? cloneForExport(categoryBreakdown) : [],
      };
      if (exportOverallButton) {
        exportOverallButton.disabled = false;
      }

      const cardsToRender = summaries.length ? summaries : [{ title: 'Category breakdown' }];

      cardsToRender.forEach((row, index) => {
        const card = document.createElement('article');
        card.className = 'score-summary';

        const header = document.createElement('div');
        header.className = 'score-summary-header';
        const title = document.createElement('h3');
        title.textContent = row.title;
        header.appendChild(title);
        if (Number.isFinite(row.score) || (row.scoreRaw && `${row.scoreRaw}`.trim())) {
          header.appendChild(createScoreBadge(row.score, row.scoreRaw ?? row.score));
        }
        card.appendChild(header);

        if (row.rating) {
          const ratingBadge = document.createElement('span');
          ratingBadge.className = 'badge';
          ratingBadge.textContent = row.rating;
          card.appendChild(ratingBadge);
        }

        if (row.changeText) {
          const changeBadge = document.createElement('span');
          const direction =
            (Number.isFinite(row.moMChange) && row.moMChange > 0) || (Number.isFinite(row.qoQChange) && row.qoQChange > 0)
              ? 'up'
              : (Number.isFinite(row.moMChange) && row.moMChange < 0) || (Number.isFinite(row.qoQChange) && row.qoQChange < 0)
              ? 'down'
              : '';
          changeBadge.className = `badge ${direction}`.trim();
          changeBadge.textContent = row.changeText;
          card.appendChild(changeBadge);
        }

        const metrics = document.createElement('div');
        metrics.className = 'score-metrics';
        const momPill = createMetricPill('MoM', row.momText);
        if (momPill) metrics.appendChild(momPill);
        const qoqPill = createMetricPill('QoQ', row.qoqText);
        if (qoqPill) metrics.appendChild(qoqPill);
        if (metrics.children.length) {
          card.appendChild(metrics);
        }

        if (hasCategories && index === 0) {
          const treeLabel = document.createElement('p');
          treeLabel.className = 'score-tree-heading';
          treeLabel.textContent = 'Categories & subcategories';
          card.appendChild(treeLabel);

          const tree = document.createElement('ul');
          tree.className = 'score-tree';

          categoryBreakdown.forEach((category) => {
            const categoryItem = document.createElement('li');
            const categoryNode = createScoreTreeNode({ ...category, title: category.name }, 'category');
            categoryItem.appendChild(categoryNode);

            const subcategories = Array.isArray(category.subcategories) ? category.subcategories : [];
            const subList = document.createElement('ul');
            subList.className = 'score-tree-children';

            if (!subcategories.length) {
              const placeholderItem = document.createElement('li');
              const placeholderNode = createScoreTreeNode(
                { title: 'No subcategory scores available' },
                'subcategory'
              );
              placeholderNode.classList.add('score-tree-placeholder');
              placeholderItem.appendChild(placeholderNode);
              subList.appendChild(placeholderItem);
            } else {
              subcategories.forEach((subcategory) => {
                const subItem = document.createElement('li');
                const subNode = createScoreTreeNode({ ...subcategory, title: subcategory.name }, 'subcategory');
                subItem.appendChild(subNode);
                subList.appendChild(subItem);
              });
            }

            categoryItem.appendChild(subList);
            tree.appendChild(categoryItem);
          });

          card.appendChild(tree);
        }

        container.appendChild(card);
      });
    };

    const populateCategoryOptions = (categories) => {
      const uniqueCategories = Array.from(new Set(categories)).filter(Boolean).sort();
      document.querySelectorAll('.category-filter').forEach((select) => {
        select.innerHTML = '<option value="all">Category: all</option>';
        for (const name of uniqueCategories) {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          select.appendChild(option);
        }
        select.value = 'all';
      });
    };

    const selectedMonthLabel = document.getElementById('selectedMonth');
    const selectedAccountLabel = document.getElementById('selectedAccount');
    const referenceMonthSelect = document.getElementById('referenceMonth');
    const tenantTypeFilterSelect = document.getElementById('tenantTypeFilter');
    const accountFilterSelect = document.getElementById('accountFilter');
    const scoreUploadInput = document.getElementById('scoreUpload');
    const loadScoreBtn = document.getElementById('loadScoreBtn');
    const signalTypeFilter = document.getElementById('signalTypeFilter');
    const allSignalsSearchInput = document.getElementById('allSignalsSearch');
    const searchInputs = [allSignalsSearchInput].filter(Boolean);
    const allSignalsCategoryFilter = document.getElementById('allSignalsCategoryFilter');
    const allSignalsSubcategoryFilter = document.getElementById('allSignalsSubcategoryFilter');
    const allSignalsCapabilityFilter = document.getElementById('allSignalsCapabilityFilter');
    const allSignalsRatingFilter = document.getElementById('allSignalsRatingFilter');
    const categoryFilters = [allSignalsCategoryFilter].filter(Boolean);
    const allSignalsListContainer = document.getElementById('allSignalsList');
    const exportOverallButton = document.getElementById('exportOverallJson');
    const exportSignalsButton = document.getElementById('exportSignalsJson');
    const technicalHealthGrid = document.getElementById('technicalHealthGrid');
    const technicalHealthEmpty = document.getElementById('technicalHealthEmpty');
    const technicalHealthEmptyDefault = technicalHealthEmpty ? technicalHealthEmpty.textContent : '';
    const technicalHealthDeepDiveModal = document.getElementById('technicalHealthDeepDiveModal');
    const technicalHealthDeepDiveTitle = document.getElementById('technicalHealthDeepDiveTitle');
    const technicalHealthDeepDiveBody = document.getElementById('technicalHealthDeepDiveBody');
    const technicalHealthDeepDiveCloseElements = technicalHealthDeepDiveModal
      ? Array.from(technicalHealthDeepDiveModal.querySelectorAll('[data-modal-close]'))
      : [];
    const addCustomTechnicalHealthSignalButton = document.getElementById('addCustomTechnicalHealthSignalButton');
    const customTechnicalHealthModal = document.getElementById('customTechnicalHealthModal');
    const customTechnicalHealthForm = document.getElementById('customTechnicalHealthForm');
    const customTechnicalHealthError = document.getElementById('customTechnicalHealthError');
    const customTechnicalHealthModalCloseElements = customTechnicalHealthModal
      ? Array.from(customTechnicalHealthModal.querySelectorAll('[data-custom-modal-close]'))
      : [];
    let lastTechnicalHealthDeepDiveTrigger = null;
    let lastCustomTechnicalHealthTrigger = null;
    const TECHNICAL_HEALTH_NO_DATA_MESSAGE = 'No Technical Health scores available for the current selection.';
    const tabButtons = Array.from(document.querySelectorAll('[data-tab-target]'));
    const tabPanels = Array.from(document.querySelectorAll('.tab-panel-section'));

    const syncTechnicalHealthModalState = () => {
      if (!document.body) return;
      const isAnyModalOpen = Boolean(
        (technicalHealthDeepDiveModal && technicalHealthDeepDiveModal.classList.contains('is-open')) ||
          (customTechnicalHealthModal && customTechnicalHealthModal.classList.contains('is-open'))
      );
      document.body.classList.toggle('technical-health-modal-open', isAnyModalOpen);
    };

    const activateTab = (targetId) => {
      tabButtons.forEach((button) => {
        const isActive = button.dataset.tabTarget === targetId;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', isActive ? 'true' : 'false');
        button.setAttribute('tabindex', isActive ? '0' : '-1');
      });

      tabPanels.forEach((panel) => {
        const isActive = panel.id === targetId;
        panel.classList.toggle('active', isActive);
        panel.hidden = !isActive;
        if (isActive) {
          panel.setAttribute('tabindex', '0');
        } else {
          panel.setAttribute('tabindex', '-1');
        }
      });
    };

    const focusTabButton = (index) => {
      const button = tabButtons[index];
      if (button) {
        button.focus();
      }
    };

    const handleTabKeydown = (event, index) => {
      const { key } = event;
      if (key === 'Enter' || key === ' ') {
        event.preventDefault();
        const targetId = tabButtons[index]?.dataset.tabTarget;
        if (targetId) {
          activateTab(targetId);
        }
        return;
      }
      if (!['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(key)) return;
      event.preventDefault();
      const lastIndex = tabButtons.length - 1;
      if (key === 'Home') {
        focusTabButton(0);
        return;
      }
      if (key === 'End') {
        focusTabButton(lastIndex);
        return;
      }
      const increment = key === 'ArrowRight' ? 1 : -1;
      let nextIndex = index + increment;
      if (nextIndex < 0) nextIndex = lastIndex;
      if (nextIndex > lastIndex) nextIndex = 0;
      focusTabButton(nextIndex);
    };

    if (tabButtons.length && tabPanels.length) {
      const initial = tabButtons.find((button) => button.classList.contains('active')) || tabButtons[0];
      activateTab(initial.dataset.tabTarget);
      tabButtons.forEach((button, index) => {
        button.addEventListener('click', () => {
          activateTab(button.dataset.tabTarget);
        });
        button.addEventListener('keydown', (event) => handleTabKeydown(event, index));
      });
    }

    if (signalTypeFilter) {
      signalTypeFilter.disabled = true;
    }

    const technicalHealthScoreBand = (score) => {
      if (!Number.isFinite(score)) return 'medium';
      if (score > 80) return 'high';
      if (score >= 60) return 'medium';
      return 'low';
    };

    const customTechnicalHealthSignalsByContext = new Map();

    const getTechnicalHealthContextKey = (context) => {
      const targetContext = context || currentAccountContext || {};
      const snapshot = targetContext.snapshotDateRaw || '';
      const tenant = targetContext.tenantType || '';
      const account = targetContext.accountName || '';
      return [snapshot, tenant, account].join('::');
    };

    const getCustomTechnicalHealthSignalsForContext = (context) => {
      const key = getTechnicalHealthContextKey(context);
      const stored = customTechnicalHealthSignalsByContext.get(key);
      return stored ? stored.slice() : [];
    };

    const setCustomTechnicalHealthSignalsForContext = (signals, context) => {
      const key = getTechnicalHealthContextKey(context);
      if (Array.isArray(signals) && signals.length) {
        customTechnicalHealthSignalsByContext.set(key, signals.slice());
      } else {
        customTechnicalHealthSignalsByContext.delete(key);
      }
    };

    const updateTechnicalHealthDeepDiveContent = (signal) => {
      if (!technicalHealthDeepDiveModal) return;
      const metricName = signal.signalName || signal.metricName || 'Technical health metric';
      if (technicalHealthDeepDiveTitle) {
        technicalHealthDeepDiveTitle.textContent = `${metricName} – Deep dive guidance`;
      }
      if (technicalHealthDeepDiveBody) {
        technicalHealthDeepDiveBody.innerHTML = '';
        const contextPieces = [];
        const capability = signal.technicalHealthCapability || signal.capabilityName;
        const subcategory = signal.technicalHealthSubcategory || signal.subcategoryName;
        if (capability) {
          contextPieces.push(`Capability: ${capability}`);
        }
        if (subcategory) {
          contextPieces.push(`Subcategory: ${subcategory}`);
        }
        if (contextPieces.length) {
          const context = document.createElement('p');
          context.className = 'technical-health-modal-context';
          context.textContent = contextPieces.join(' • ');
          technicalHealthDeepDiveBody.appendChild(context);
        }
        const definitionTextRaw =
          signal.signalDefinition ?? signal.definition ?? signal.metricDefinition ?? '';
        const definitionText = `${definitionTextRaw ?? ''}`.trim();
        if (definitionText) {
          const definition = document.createElement('p');
          definition.className = 'technical-health-modal-definition';
          definition.textContent = definitionText;
          technicalHealthDeepDiveBody.appendChild(definition);
        } else {
          const placeholder = document.createElement('p');
          placeholder.textContent = 'Specific deep dive instructions for this metric will appear here.';
          technicalHealthDeepDiveBody.appendChild(placeholder);
        }

        const geminiActions = document.createElement('div');
        geminiActions.className = 'technical-health-modal-actions';

        const geminiLink = document.createElement('a');
        geminiLink.className = 'technical-health-modal-button';
        geminiLink.textContent = 'Ask Gemini';
        geminiLink.target = '_blank';
        geminiLink.rel = 'noopener noreferrer';

        const signalCategory =
          signal.technicalHealthSubcategory ||
          signal.subcategoryName ||
          signal.categoryDescription ||
          signal.categoryName ||
          '';
        const signalName = signal.signalName || signal.metricName || 'Technical health metric';

        const encodeQueryValue = (value) =>
          encodeURIComponent(`${value}`.trim()).replace(/%20/g, '+');

        const query = [
          'Give me details and official documentation for: salesforce customer success score',
          signalCategory,
          signalName,
          definitionText,
        ]
          .filter((segment) => segment && `${segment}`.trim().length)
          .map(encodeQueryValue)
          .join('+');

        geminiLink.href = `https://www.google.com/search?udm=50&source=searchlabs&q=${query}`;
        geminiLink.setAttribute('aria-label', 'Open Ask Gemini search in a new tab');

        geminiActions.appendChild(geminiLink);
        technicalHealthDeepDiveBody.appendChild(geminiActions);
      }
    };

    const closeTechnicalHealthDeepDive = () => {
      if (!technicalHealthDeepDiveModal) return;
      technicalHealthDeepDiveModal.classList.remove('is-open');
      technicalHealthDeepDiveModal.setAttribute('aria-hidden', 'true');
      syncTechnicalHealthModalState();
      if (
        lastTechnicalHealthDeepDiveTrigger &&
        typeof lastTechnicalHealthDeepDiveTrigger.focus === 'function' &&
        document.contains(lastTechnicalHealthDeepDiveTrigger)
      ) {
        lastTechnicalHealthDeepDiveTrigger.focus();
      }
      lastTechnicalHealthDeepDiveTrigger = null;
    };

    const openTechnicalHealthDeepDive = (signal, trigger) => {
      if (!technicalHealthDeepDiveModal) return;
      updateTechnicalHealthDeepDiveContent(signal);
      if (trigger) {
        lastTechnicalHealthDeepDiveTrigger = trigger;
      }
      technicalHealthDeepDiveModal.classList.add('is-open');
      technicalHealthDeepDiveModal.setAttribute('aria-hidden', 'false');
      syncTechnicalHealthModalState();
      const closeButton = technicalHealthDeepDiveModal.querySelector('.technical-health-modal-close');
      if (closeButton) {
        closeButton.focus();
      } else {
        technicalHealthDeepDiveModal.focus();
      }
    };

    if (technicalHealthDeepDiveModal) {
      technicalHealthDeepDiveModal.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && technicalHealthDeepDiveModal.classList.contains('is-open')) {
          event.preventDefault();
          closeTechnicalHealthDeepDive();
        }
      });
      technicalHealthDeepDiveCloseElements.forEach((element) => {
        element.addEventListener('click', (event) => {
          event.preventDefault();
          closeTechnicalHealthDeepDive();
        });
      });
    }

    const resetCustomTechnicalHealthForm = () => {
      if (customTechnicalHealthForm) {
        customTechnicalHealthForm.reset();
      }
      if (customTechnicalHealthError) {
        customTechnicalHealthError.textContent = '';
        customTechnicalHealthError.hidden = true;
      }
    };

    const closeCustomTechnicalHealthModal = () => {
      if (!customTechnicalHealthModal) return;
      customTechnicalHealthModal.classList.remove('is-open');
      customTechnicalHealthModal.setAttribute('aria-hidden', 'true');
      syncTechnicalHealthModalState();
      const fallbackTrigger =
        addCustomTechnicalHealthSignalButton &&
        typeof addCustomTechnicalHealthSignalButton.focus === 'function' &&
        document.contains(addCustomTechnicalHealthSignalButton)
          ? addCustomTechnicalHealthSignalButton
          : null;
      const targetToFocus =
        (lastCustomTechnicalHealthTrigger &&
          typeof lastCustomTechnicalHealthTrigger.focus === 'function' &&
          document.contains(lastCustomTechnicalHealthTrigger)
          ? lastCustomTechnicalHealthTrigger
          : null) || fallbackTrigger;
      if (targetToFocus) {
        targetToFocus.focus();
      }
      lastCustomTechnicalHealthTrigger = null;
    };

    const openCustomTechnicalHealthModal = (trigger) => {
      if (!customTechnicalHealthModal) return;
      if (trigger) {
        lastCustomTechnicalHealthTrigger = trigger;
      } else {
        lastCustomTechnicalHealthTrigger = addCustomTechnicalHealthSignalButton;
      }
      resetCustomTechnicalHealthForm();
      customTechnicalHealthModal.classList.add('is-open');
      customTechnicalHealthModal.setAttribute('aria-hidden', 'false');
      syncTechnicalHealthModalState();
      const firstField = customTechnicalHealthForm
        ? customTechnicalHealthForm.querySelector('input, select, textarea')
        : null;
      if (firstField && typeof firstField.focus === 'function') {
        firstField.focus();
      } else {
        customTechnicalHealthModal.focus();
      }
    };

    if (addCustomTechnicalHealthSignalButton) {
      addCustomTechnicalHealthSignalButton.addEventListener('click', (event) => {
        event.preventDefault();
        openCustomTechnicalHealthModal(addCustomTechnicalHealthSignalButton);
      });
    }

    if (customTechnicalHealthModal) {
      customTechnicalHealthModal.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && customTechnicalHealthModal.classList.contains('is-open')) {
          event.preventDefault();
          closeCustomTechnicalHealthModal();
        }
      });
    }

    customTechnicalHealthModalCloseElements.forEach((element) => {
      element.addEventListener('click', (event) => {
        event.preventDefault();
        closeCustomTechnicalHealthModal();
      });
    });

    if (customTechnicalHealthForm) {
      customTechnicalHealthForm.addEventListener('input', () => {
        if (customTechnicalHealthError && !customTechnicalHealthError.hidden) {
          customTechnicalHealthError.textContent = '';
          customTechnicalHealthError.hidden = true;
        }
      });

      customTechnicalHealthForm.addEventListener('submit', (event) => {
        event.preventDefault();
        if (!customTechnicalHealthForm) return;
        const formData = new FormData(customTechnicalHealthForm);
        const name = `${formData.get('customSignalName') || ''}`.trim();
        if (!name) {
          if (customTechnicalHealthError) {
            customTechnicalHealthError.textContent = 'Provide a signal name to create the custom card.';
            customTechnicalHealthError.hidden = false;
          }
          const nameInput = customTechnicalHealthForm.querySelector('#customSignalName');
          if (nameInput && typeof nameInput.focus === 'function') {
            nameInput.focus();
          }
          return;
        }

        const subcategory = `${formData.get('customSignalSubcategory') || ''}`.trim();
        const capability = `${formData.get('customSignalCapability') || ''}`.trim();
        const scoreRaw = `${formData.get('customSignalScore') || ''}`.trim();
        const scoreNumeric = parseNumber(scoreRaw);
        const valueRaw = `${formData.get('customSignalValue') || ''}`.trim();
        const valueNumeric = parseNumber(valueRaw);
        const benchmarkRaw = `${formData.get('customSignalBenchmark') || ''}`.trim();
        const momRaw = `${formData.get('customSignalMoM') || ''}`.trim();
        const momNumeric = parseNumber(momRaw);
        const qoqRaw = `${formData.get('customSignalQoQ') || ''}`.trim();
        const qoqNumeric = parseNumber(qoqRaw);
        const changeDirectionSelection = `${formData.get('customSignalChangeDirection') || 'auto'}`.trim();
        const manualChangeText = `${formData.get('customSignalChangeText') || ''}`.trim();
        const definition = `${formData.get('customSignalDefinition') || ''}`.trim();

        const effectiveChangeDirection = (() => {
          if (changeDirectionSelection === 'up' || changeDirectionSelection === 'down' || changeDirectionSelection === 'flat') {
            return changeDirectionSelection;
          }
          if ((Number.isFinite(momNumeric) && momNumeric > 0) || (Number.isFinite(qoqNumeric) && qoqNumeric > 0)) {
            return 'up';
          }
          if ((Number.isFinite(momNumeric) && momNumeric < 0) || (Number.isFinite(qoqNumeric) && qoqNumeric < 0)) {
            return 'down';
          }
          return 'flat';
        })();

        const autoChangeText = buildChangeLabel(momNumeric, qoqNumeric);
        const changeText = manualChangeText || autoChangeText;
        const benchmarkStatus = evaluateBenchmark(Number.isFinite(valueNumeric) ? valueNumeric : null, benchmarkRaw);

        const customSignal = {
          id: `custom-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          signalName: name,
          metricName: name,
          categoryName: 'Technical Health',
          technicalHealthSubcategory: subcategory || 'Custom',
          subcategoryName: subcategory || 'Custom',
          technicalHealthCapability: capability || '',
          capabilityName: capability || '',
          score: Number.isFinite(scoreNumeric) ? scoreNumeric : null,
          scoreRaw: scoreRaw || '',
          valueDisplay: valueRaw || '',
          value: valueRaw || '',
          valueNumeric: Number.isFinite(valueNumeric) ? valueNumeric : null,
          benchmark: benchmarkRaw || '',
          benchmarkDisplay: benchmarkRaw
            ? `${benchmarkRaw}${benchmarkStatus ? ` • ${benchmarkStatus}` : ''}`
            : '',
          benchmarkStatus: benchmarkStatus || '',
          moMChange: Number.isFinite(momNumeric) ? momNumeric : null,
          moMChangeRaw: momRaw || '',
          qoQChange: Number.isFinite(qoqNumeric) ? qoqNumeric : null,
          qoQChangeRaw: qoqRaw || '',
          momText: formatChangeDisplay(Number.isFinite(momNumeric) ? momNumeric : null, momRaw),
          qoqText: formatChangeDisplay(Number.isFinite(qoqNumeric) ? qoqNumeric : null, qoqRaw),
          changeText: changeText || '',
          changeDirection: effectiveChangeDirection,
          signalDefinition: definition || '',
          isCustomTechnicalHealth: true,
          signalType: 'scored',
          isScored: true,
          rating: Number.isFinite(scoreNumeric) ? ratingFromScore(scoreNumeric) : '',
          categoryDescription: [subcategory || '', capability || ''].filter(Boolean).join(' • '),
        };

        const existing = getCustomTechnicalHealthSignalsForContext();
        existing.push(customSignal);
        setCustomTechnicalHealthSignalsForContext(existing);
        renderTechnicalHealthDashboard(allSignalsByType.scored);
        closeCustomTechnicalHealthModal();
      });
    }

    const createTechnicalHealthCard = (signal) => {
      const scoreNumericValue = getTechnicalHealthScoreValue(signal);
      const scoreFallback = getTechnicalHealthScoreFallback(signal, scoreNumericValue);

      const card = document.createElement('article');
      card.className = `technical-health-card ${technicalHealthScoreBand(scoreNumericValue)}`;

      const label = document.createElement('p');
      label.className = 'technical-health-label';
      label.textContent = signal.signalName || signal.metricName || 'Technical health metric';
      card.appendChild(label);

      const metaPieces = [];
      const capability = signal.technicalHealthCapability || signal.capabilityName;
      if (capability) metaPieces.push(capability);

      if (metaPieces.length) {
        const meta = document.createElement('p');
        meta.className = 'technical-health-meta';
        meta.textContent = metaPieces.join(' • ');
        card.appendChild(meta);
      }

      const scoreWrapper = document.createElement('div');
      scoreWrapper.className = 'technical-health-score';

      const scoreValueElement = document.createElement('span');
      scoreValueElement.className = 'technical-health-value';
      const formattedScore = formatScore(scoreNumericValue, scoreFallback);
      scoreValueElement.textContent = formattedScore;
      scoreWrapper.appendChild(scoreValueElement);

      const valueText = (() => {
        if (signal.valueDisplay && `${signal.valueDisplay}`.trim()) {
          return `${signal.valueDisplay}`.trim();
        }
        if (signal.value && `${signal.value}`.trim()) {
          return `${signal.value}`.trim();
        }
        if (Number.isFinite(signal.valueNumeric)) {
          return formatNumberWithThousandSuffix(signal.valueNumeric);
        }
        return '';
      })();

      if (valueText) {
        const unit = document.createElement('span');
        unit.className = 'technical-health-unit';
        unit.textContent = `(${valueText})`;
        scoreWrapper.appendChild(unit);
      }

      const trendValue = Number.isFinite(signal.moMChange)
        ? signal.moMChange
        : Number.isFinite(signal.qoQChange)
        ? signal.qoQChange
        : null;

      if (Number.isFinite(trendValue) && trendValue !== 0) {
        const trend = document.createElement('span');
        const direction = trendValue > 0 ? 'up' : 'down';
        trend.className = `technical-health-trend ${direction}`;
        const arrow = direction === 'up' ? '▲' : '▼';
        const labelText = Number.isFinite(signal.moMChange) ? 'MoM' : 'QoQ';
        trend.textContent = `${arrow} ${formatNumber(Math.abs(trendValue))} ${labelText}`.trim();
        scoreWrapper.appendChild(trend);
      } else if (signal.changeDirection && signal.changeDirection !== 'flat' && signal.changeText) {
        const trend = document.createElement('span');
        trend.className = `technical-health-trend ${signal.changeDirection}`;
        const arrow = signal.changeDirection === 'up' ? '▲' : '▼';
        trend.textContent = `${arrow} ${signal.changeText}`;
        scoreWrapper.appendChild(trend);
      }

      card.appendChild(scoreWrapper);

      const deepDiveLink = document.createElement('button');
      deepDiveLink.type = 'button';
      deepDiveLink.className = 'technical-health-deep-dive-link';
      deepDiveLink.textContent = '?';
      deepDiveLink.addEventListener('click', () => openTechnicalHealthDeepDive(signal, deepDiveLink));
      card.appendChild(deepDiveLink);

      return card;
    };

    const renderTechnicalHealthDashboard = (signals = []) => {
      if (!technicalHealthGrid || !technicalHealthEmpty) return;
      const baseSignals = Array.isArray(signals)
        ? signals.filter((signal) => normalizeKey(signal.categoryName) === 'technical health')
        : [];
      const customSignals = getCustomTechnicalHealthSignalsForContext();
      const technicalSignals = [...baseSignals, ...customSignals];

      technicalHealthGrid.innerHTML = '';

      if (!technicalSignals.length) {
        technicalHealthEmpty.textContent = TECHNICAL_HEALTH_NO_DATA_MESSAGE;
        technicalHealthEmpty.hidden = false;
        return;
      }

      technicalHealthEmpty.hidden = true;

      const groupedBySubcategory = technicalSignals.reduce((map, signal) => {
        const subcategoryName = signal.technicalHealthSubcategory || signal.subcategoryName || 'Uncategorized';
        if (!map.has(subcategoryName)) {
          map.set(subcategoryName, []);
        }
        map.get(subcategoryName).push(signal);
        return map;
      }, new Map());

      const sortedSubcategories = Array.from(groupedBySubcategory.keys()).sort((a, b) => {
        const isAUncategorized = a === 'Uncategorized';
        const isBUncategorized = b === 'Uncategorized';
        if (isAUncategorized && !isBUncategorized) return 1;
        if (!isAUncategorized && isBUncategorized) return -1;
        return a.localeCompare(b, undefined, { sensitivity: 'base' });
      });

      sortedSubcategories.forEach((subcategoryName) => {
        const groupContainer = document.createElement('section');
        groupContainer.className = 'technical-health-subcategory-group';

        const heading = document.createElement('h3');
        heading.className = 'technical-health-subcategory-heading';
        heading.textContent = subcategoryName;
        groupContainer.appendChild(heading);

        const groupGrid = document.createElement('div');
        groupGrid.className = 'technical-health-subcategory-grid';

        groupedBySubcategory
          .get(subcategoryName)
          .slice()
          .sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity))
          .forEach((signal) => {
            groupGrid.appendChild(createTechnicalHealthCard(signal));
          });

        groupContainer.appendChild(groupGrid);
        technicalHealthGrid.appendChild(groupContainer);
      });
    };

    let parsedDataset = null;
    let currentCategorySummaries = new Map();
    let allSignalsByType = { scored: [], informational: [] };

    const initialAccountContext = () => ({
      entries: [],
      accountName: '',
      accountLocalName: '',
      companyName: '',
      snapshotDateRaw: '',
      snapshotDateFormatted: '',
      successPlan: '',
      tenantType: '',
    });

    let currentAccountContext = initialAccountContext();
    let currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
    let currentFilteredSignals = [];
    let currentAllSignalsFilters = {
      searchTerm: '',
      category: 'all',
      subcategory: 'all',
      capability: 'all',
      rating: 'all',
      signalType: 'scored',
    };

    const resetSignalsFiltersState = () => {
      currentAllSignalsFilters = {
        searchTerm: '',
        category: 'all',
        subcategory: 'all',
        capability: 'all',
        rating: 'all',
        signalType: 'scored',
      };
    };

    const clearVisualizations = (message) => {
      allSignalsByType = { scored: [], informational: [] };
      currentOverallSummaryData = { summaries: [], categoryBreakdown: [] };
      currentFilteredSignals = [];
      currentCategorySummaries = new Map();
      currentAccountContext = initialAccountContext();
      resetSignalsFiltersState();

      if (exportOverallButton) exportOverallButton.disabled = true;
      if (exportSignalsButton) exportSignalsButton.disabled = true;

      if (signalTypeFilter) {
        signalTypeFilter.value = 'scored';
        signalTypeFilter.disabled = true;
      }

      const accountOverview = document.getElementById('accountOverview');
      if (accountOverview) accountOverview.innerHTML = '';
      const overallGrid = document.getElementById('overallScoreGrid');
      if (overallGrid) overallGrid.innerHTML = `<p class="empty-state">${message}</p>`;
      if (allSignalsListContainer) {
        allSignalsListContainer.innerHTML = `<p class="empty-state">${message}</p>`;
      }
      if (technicalHealthGrid) {
        technicalHealthGrid.innerHTML = '';
      }
      if (technicalHealthEmpty) {
        technicalHealthEmpty.textContent = message || technicalHealthEmptyDefault || TECHNICAL_HEALTH_NO_DATA_MESSAGE;
        technicalHealthEmpty.hidden = false;
      }
      document.querySelectorAll('.signal-search').forEach((input) => {
        input.value = '';
      });
      if (allSignalsSubcategoryFilter) {
        allSignalsSubcategoryFilter.innerHTML = '<option value="all">Subcategory: all</option>';
        allSignalsSubcategoryFilter.value = 'all';
        allSignalsSubcategoryFilter.disabled = true;
      }
      if (allSignalsCapabilityFilter) {
        allSignalsCapabilityFilter.innerHTML = '<option value="all">Capability: all</option>';
        allSignalsCapabilityFilter.value = 'all';
        allSignalsCapabilityFilter.disabled = true;
      }
      if (allSignalsRatingFilter) {
        allSignalsRatingFilter.innerHTML = '<option value="all">Rating: all</option>';
        allSignalsRatingFilter.value = 'all';
        allSignalsRatingFilter.disabled = true;
      }
      document.querySelectorAll('.category-filter').forEach((select) => {
        select.innerHTML = '<option value="all">Category: all</option>';
        select.value = 'all';
      });
    };

    const buildAccountOverviewPayload = () => {
      const { entries, ...meta } = currentAccountContext;
      const sanitizedMeta = {};
      Object.entries(meta).forEach(([key, value]) => {
        if (value === null || value === undefined) return;
        if (typeof value === 'string' && value.trim() === '') return;
        sanitizedMeta[key] = value;
      });
      return {
        ...sanitizedMeta,
        entries: cloneForExport(entries),
      };
    };

    const extractScoreValue = (summary) => {
      if (Number.isFinite(summary?.score)) {
        return summary.score;
      }
      const raw = summary?.scoreRaw;
      if (raw !== null && raw !== undefined) {
        if (typeof raw === 'string') {
          const trimmed = raw.trim();
          if (trimmed) return trimmed;
        } else {
          return raw;
        }
      }
      const fallback = summary?.score;
      if (fallback !== null && fallback !== undefined) {
        if (typeof fallback === 'string') {
          const trimmed = fallback.trim();
          if (trimmed) return trimmed;
        } else {
          return fallback;
        }
      }
      return null;
    };

    const buildOverallScoreSnapshot = () => {
      const summaries = currentOverallSummaryData?.summaries;
      if (!Array.isArray(summaries) || !summaries.length) {
        return null;
      }

      const desiredTitles = new Map([
        ['overall score', 'Overall'],
        ['overall', 'Overall'],
        ['customer expertise', 'Customer Expertise'],
        ['product adoption', 'Product Adoption'],
        ['technical health', 'Technical Health'],
      ]);

      const snapshot = {};
      summaries.forEach((summary) => {
        const rawTitle = (summary?.title || summary?.scoreName || '').trim();
        if (!rawTitle) return;
        const normalized = rawTitle.toLowerCase();
        const exportKey = desiredTitles.get(normalized);
        if (!exportKey) return;
        const value = extractScoreValue(summary);
        if (value !== null && value !== '') {
          snapshot[exportKey] = value;
        }
      });

      return Object.keys(snapshot).length ? snapshot : null;
    };

    const buildExportFilename = (base) => {
      const accountSlug = slugify(currentAccountContext.accountName) || 'account';
      const snapshotSource =
        currentAccountContext.snapshotDateRaw || currentAccountContext.snapshotDateFormatted || 'snapshot';
      const snapshotSlug = slugify(snapshotSource) || 'snapshot';
      return `${base}-${accountSlug}-${snapshotSlug}.json`;
    };

    const triggerJsonDownload = (filename, payload) => {
      const blob = new Blob([`${JSON.stringify(payload, null, 2)}\n`], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };

    const populateReferenceOptions = (dates) => {
      referenceMonthSelect.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      placeholder.textContent = dates.length ? '-- Select snapshot date --' : 'Upload a file to populate dates';
      referenceMonthSelect.appendChild(placeholder);
      for (const date of dates) {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = date;
        referenceMonthSelect.appendChild(option);
      }
    };

    const resetTenantTypeSelect = (message) => {
      if (!tenantTypeFilterSelect) return;
      tenantTypeFilterSelect.innerHTML = `<option value="" disabled selected>${message}</option>`;
      tenantTypeFilterSelect.disabled = true;
    };

    const resetAccountSelect = (message) => {
      accountFilterSelect.innerHTML = `<option value="" disabled selected>${message}</option>`;
      accountFilterSelect.disabled = true;
    };

    const syncSearchInputs = (source) => {
      const value = source.value;
      searchInputs.forEach((input) => {
        if (input !== source && input.value !== value) {
          input.value = value;
        }
      });
      applyFilters();
    };

    const syncCategoryFilters = (source) => {
      const value = source.value;
      categoryFilters.forEach((select) => {
        if (select !== source && select.value !== value) {
          select.value = value;
        }
      });
      updateAllSignalsFilterOptions({ resetSubcategory: true, resetCapability: true });
      applyFilters();
    };

    const getSelectedSignalType = () => {
      if (!signalTypeFilter) return 'scored';
      return signalTypeFilter.value || 'scored';
    };

    const getActiveSignals = () => {
      const type = getSelectedSignalType();
      if (type === 'informational') {
        return allSignalsByType.informational;
      }
      return allSignalsByType.scored;
    };

    const applyFilters = () => {
      if (!allSignalsListContainer) return;
      const rawSearchTerm = searchInputs[0]?.value || '';
      const searchTerm = rawSearchTerm.toLowerCase();
      const categoryValue = categoryFilters[0]?.value || 'all';
      const subcategoryValue =
        allSignalsSubcategoryFilter && !allSignalsSubcategoryFilter.disabled
          ? allSignalsSubcategoryFilter.value
          : 'all';
      const capabilityValue =
        allSignalsCapabilityFilter && !allSignalsCapabilityFilter.disabled
          ? allSignalsCapabilityFilter.value
          : 'all';
      const ratingValue =
        allSignalsRatingFilter && !allSignalsRatingFilter.disabled
          ? allSignalsRatingFilter.value
          : 'all';

      const matchesFilters = (signal) => {
        const matchesSearch =
          !searchTerm ||
          signal.signalName?.toLowerCase().includes(searchTerm) ||
          signal.definition?.toLowerCase().includes(searchTerm);
        const matchesCategory =
          categoryValue === 'all' ||
          signal.categoryName === categoryValue ||
          signal.categoryDescription?.startsWith(`${categoryValue}`);
        const matchesSubcategory = subcategoryValue === 'all' || signal.subcategoryName === subcategoryValue;
        const matchesCapability = capabilityValue === 'all' || signal.capabilityName === capabilityValue;
        const matchesRating = ratingValue === 'all' || (signal.rating || '') === ratingValue;
        return matchesSearch && matchesCategory && matchesSubcategory && matchesCapability && matchesRating;
      };

      const sourceSignals = getActiveSignals();
      const filteredSignals = sourceSignals.filter(matchesFilters);
      currentFilteredSignals = cloneForExport(filteredSignals);
      currentAllSignalsFilters = {
        searchTerm: rawSearchTerm,
        category: categoryValue,
        subcategory: subcategoryValue,
        capability: capabilityValue,
        rating: ratingValue,
        signalType: getSelectedSignalType(),
      };
      if (exportSignalsButton) {
        exportSignalsButton.disabled = sourceSignals.length === 0;
      }
      populateGroupedSignals(filteredSignals, allSignalsListContainer);
    };

    const updateAllSignalsFilterOptions = ({
      resetSubcategory = false,
      resetCapability = false,
      resetRating = false,
    } = {}) => {
      if (!allSignalsSubcategoryFilter || !allSignalsCapabilityFilter) return;

      const categoryValue = allSignalsCategoryFilter ? allSignalsCategoryFilter.value : 'all';
      const baseSignals = getActiveSignals();
      const relevantSignals =
        categoryValue === 'all'
          ? baseSignals
          : baseSignals.filter((signal) => signal.categoryName === categoryValue);

      const previousSubValue = resetSubcategory ? 'all' : allSignalsSubcategoryFilter.value || 'all';
      const subcategories = new Set();
      relevantSignals.forEach((signal) => {
        if (signal.subcategoryName) {
          subcategories.add(signal.subcategoryName);
        }
      });
      const sortedSubs = Array.from(subcategories).sort((a, b) => a.localeCompare(b));

      allSignalsSubcategoryFilter.innerHTML = '';
      const defaultSub = document.createElement('option');
      defaultSub.value = 'all';
      defaultSub.textContent = 'Subcategory: all';
      allSignalsSubcategoryFilter.appendChild(defaultSub);
      sortedSubs.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        allSignalsSubcategoryFilter.appendChild(option);
      });

      const newSubValue = sortedSubs.includes(previousSubValue) ? previousSubValue : 'all';
      allSignalsSubcategoryFilter.value = newSubValue;
      const subcategoryChanged = newSubValue !== previousSubValue;

      const previousCapValue =
        resetCapability || subcategoryChanged ? 'all' : allSignalsCapabilityFilter.value || 'all';
      const capabilitySignals = relevantSignals.filter(
        (signal) => newSubValue === 'all' || signal.subcategoryName === newSubValue
      );
      const capabilities = new Set();
      capabilitySignals.forEach((signal) => {
        if (signal.capabilityName) {
          capabilities.add(signal.capabilityName);
        }
      });
      const sortedCaps = Array.from(capabilities).sort((a, b) => a.localeCompare(b));

      allSignalsCapabilityFilter.innerHTML = '';
      const defaultCap = document.createElement('option');
      defaultCap.value = 'all';
      defaultCap.textContent = 'Capability: all';
      allSignalsCapabilityFilter.appendChild(defaultCap);
      sortedCaps.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        allSignalsCapabilityFilter.appendChild(option);
      });

      const newCapValue = sortedCaps.includes(previousCapValue) ? previousCapValue : 'all';
      allSignalsCapabilityFilter.value = newCapValue;

      const hasSignals = baseSignals.length > 0;
      allSignalsSubcategoryFilter.disabled = !hasSignals;
      allSignalsCapabilityFilter.disabled = !hasSignals;

      if (allSignalsRatingFilter) {
        const previousRatingValue = resetRating ? 'all' : allSignalsRatingFilter.value || 'all';
        const ratings = new Set();
        baseSignals.forEach((signal) => {
          if (signal.rating) {
            ratings.add(signal.rating);
          }
        });
        const sortedRatings = Array.from(ratings).sort((a, b) => a.localeCompare(b));

        allSignalsRatingFilter.innerHTML = '';
        const defaultRating = document.createElement('option');
        defaultRating.value = 'all';
        defaultRating.textContent = 'Rating: all';
        allSignalsRatingFilter.appendChild(defaultRating);
        sortedRatings.forEach((name) => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          allSignalsRatingFilter.appendChild(option);
        });

        const newRatingValue = sortedRatings.includes(previousRatingValue) ? previousRatingValue : 'all';
        allSignalsRatingFilter.value = newRatingValue;
        allSignalsRatingFilter.disabled = !hasSignals || sortedRatings.length === 0;
      }
    };

    const populateAccountOptions = (snapshotDate, tenantTypeValue = 'all') => {
      if (!parsedDataset || !snapshotDate) {
        resetAccountSelect(snapshotDate ? 'No accounts for selected date' : 'Select a snapshot date first');
        updateLoadButtonState();
        return;
      }

      const accounts = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (parsedDataset[key] || []).forEach((row) => {
          const matchesTenant =
            tenantTypeValue === 'all' || !tenantTypeValue || (row.tenantType || '') === tenantTypeValue;
          if (row.snapshotDate === snapshotDate && row.accountName && matchesTenant) {
            accounts.add(row.accountName);
          }
        });
      });

      const sorted = Array.from(accounts).sort((a, b) => a.localeCompare(b));
      accountFilterSelect.innerHTML = '';

      if (!sorted.length) {
        const option = document.createElement('option');
        option.value = '';
        option.disabled = true;
        option.selected = true;
        option.textContent = tenantTypeValue && tenantTypeValue !== 'all' ? 'No accounts for selected tenant type' : 'No accounts for selected date';
        accountFilterSelect.appendChild(option);
        accountFilterSelect.disabled = true;
        updateLoadButtonState();
        return;
      }

      if (sorted.length > 1) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.disabled = true;
        placeholder.selected = true;
        placeholder.textContent = '-- Select account --';
        accountFilterSelect.appendChild(placeholder);
      }

      sorted.forEach((name) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        accountFilterSelect.appendChild(option);
      });

      accountFilterSelect.disabled = false;
      accountFilterSelect.value = sorted.length === 1 ? sorted[0] : '';
      updateLoadButtonState();
    };

    const populateTenantTypeOptions = (snapshotDate) => {
      if (!tenantTypeFilterSelect) return;
      if (!parsedDataset || !snapshotDate) {
        resetTenantTypeSelect(snapshotDate ? 'No tenant types for selected date' : 'Select a snapshot date first');
        return;
      }

      const types = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (parsedDataset[key] || []).forEach((row) => {
          if (row.snapshotDate === snapshotDate && row.tenantType) {
            types.add(row.tenantType);
          }
        });
      });

      const sorted = Array.from(types).sort((a, b) => a.localeCompare(b));

      if (!sorted.length) {
        tenantTypeFilterSelect.innerHTML = '<option value="all">Tenant type: all</option>';
        tenantTypeFilterSelect.value = 'all';
        tenantTypeFilterSelect.disabled = true;
        return;
      }

      tenantTypeFilterSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'Tenant type: all';
      tenantTypeFilterSelect.appendChild(allOption);
      sorted.forEach((type) => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        tenantTypeFilterSelect.appendChild(option);
      });

      tenantTypeFilterSelect.disabled = false;
      tenantTypeFilterSelect.value = sorted.length === 1 ? sorted[0] : 'all';
    };

    const collectSnapshotDates = (dataset) => {
      if (!dataset) return [];
      const values = new Set();
      ['signals', 'categories', 'subcategories', 'overall'].forEach((key) => {
        (dataset[key] || []).forEach((row) => {
          if (row.snapshotDate) {
            values.add(row.snapshotDate);
          }
        });
      });
      return Array.from(values).sort((a, b) => {
        const dateA = new Date(a);
        const dateB = new Date(b);
        if (!Number.isNaN(dateA) && !Number.isNaN(dateB)) {
          return dateB - dateA;
        }
        return `${b}`.localeCompare(`${a}`);
      });
    };

    const refreshDashboard = (dataset, snapshotDate, accountName, tenantTypeValue = '') => {
      if (!dataset) return;
      const activeTenantType = tenantTypeValue && tenantTypeValue !== 'all' ? tenantTypeValue : '';
      const filterBySelection = (row) =>
        row.snapshotDate === snapshotDate &&
        (!activeTenantType || (row.tenantType || '') === activeTenantType) &&
        (!accountName || row.accountName === accountName);

      const overallRows = (dataset.overall || []).filter(filterBySelection);
      const categoryRows = (dataset.categories || []).filter(filterBySelection);
      const subcategoryRows = (dataset.subcategories || []).filter(filterBySelection);
      const signalRows = (dataset.signals || []).filter(filterBySelection);

      const processed = signalRows.map(transformSignalRow);
      const scoredSignals = processed.filter((signal) => signal.isScored);
      const informationalSignals = processed.filter((signal) => signal.isInformational);
      const accountInfo = signalRows[0] || categoryRows[0] || subcategoryRows[0] || overallRows[0] || {};

      selectedMonthLabel.textContent = snapshotDate ? formatSnapshotMonth(snapshotDate) : 'Not selected';
      selectedAccountLabel.textContent = accountName || accountInfo.accountName || 'Not selected';

      populateAccountOverview({ ...accountInfo, accountName: accountInfo.accountName || accountName }, snapshotDate, accountName);

      currentCategorySummaries = new Map();
      categoryRows.forEach((row) => {
        if (!row.categoryName) return;
        currentCategorySummaries.set(row.categoryName, decorateSummaryRow(row));
      });

      const categories = buildCategoryHierarchy(scoredSignals, categoryRows, subcategoryRows);
      populateOverallScores(overallRows, categories);

      renderTechnicalHealthDashboard(scoredSignals);

      allSignalsByType = { scored: scoredSignals, informational: informationalSignals };

      const defaultSignalType = scoredSignals.length || !informationalSignals.length ? 'scored' : 'informational';

      if (signalTypeFilter) {
        signalTypeFilter.disabled = processed.length === 0;
        signalTypeFilter.value = defaultSignalType;
      }

      currentAllSignalsFilters.signalType = defaultSignalType;

      const categoryNames = [
        ...new Set([
          ...processed.map((signal) => signal.categoryName),
          ...categoryRows.map((row) => row.categoryName),
        ].filter(Boolean)),
      ];

      populateCategoryOptions(categoryNames);
      updateAllSignalsFilterOptions({ resetSubcategory: true, resetCapability: true, resetRating: true });
      applyFilters();
    };

    const updateLoadButtonState = () => {
      loadScoreBtn.disabled = !(parsedDataset && referenceMonthSelect.value && accountFilterSelect.value);
    };

    const resetDashboard = () => {
      parsedDataset = null;
      customTechnicalHealthSignalsByContext.clear();
      selectedMonthLabel.textContent = 'Not selected';
      selectedAccountLabel.textContent = 'Not selected';
      populateReferenceOptions([]);
      resetTenantTypeSelect('Select a snapshot date first');
      resetAccountSelect('Select a snapshot date first');
      scoreUploadInput.value = '';
      loadScoreBtn.disabled = true;
      clearVisualizations('Upload a file to begin the analysis.');
    };

    const isExcelFile = (file) => {
      if (!file) return false;
      const name = (file.name || '').toLowerCase();
      if (name.endsWith('.xlsx') || name.endsWith('.xlsm') || name.endsWith('.xls')) return true;
      const type = file.type || '';
      return (
        type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
        type === 'application/vnd.ms-excel'
      );
    };

    const parseWorkbook = (arrayBuffer) => {
      if (typeof XLSX === 'undefined') {
        throw new Error('XLSX library is not available');
      }
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const extractSheet = (sheetName) => {
        const sheet = workbook.Sheets[sheetName];
        if (!sheet) return [];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        if (!rows.length) return [];
        const headerIndex = rows.findIndex(
          (row) => Array.isArray(row) && row.some((cell) => `${cell}`.trim().toLowerCase() === 'snapshot date')
        );
        if (headerIndex === -1) return [];
        const headers = rows[headerIndex].map((cell) => `${cell}`.trim());
        const records = [];
        for (let i = headerIndex + 1; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || row.every((cell) => `${cell ?? ''}`.trim() === '')) continue;
          const record = {};
          headers.forEach((header, index) => {
            const value = row[index];
            if (value === undefined || value === null) {
              record[header] = '';
            } else if (typeof value === 'string') {
              record[header] = value.trim();
            } else {
              record[header] = value;
            }
          });
          const hasData = Object.values(record).some((value) => `${value}`.trim().length);
          if (hasData) {
            records.push(record);
          }
        }
        return records;
      };

      const overall = extractSheet('Overall Scores').map((row) => normalizeScoreRow(row, OVERALL_COLUMN_MAP));
      const categories = extractSheet('Category Scores').map((row) => normalizeScoreRow(row, CATEGORY_COLUMN_MAP));
      const subcategories = extractSheet('Subcategory Scores').map((row) => normalizeScoreRow(row, SUBCATEGORY_COLUMN_MAP));
      const signals = extractSheet('Signal Scores').map((row) => normalizeSignalRow(row));

      if (!overall.length && !categories.length && !subcategories.length && !signals.length) {
        throw new Error('The workbook does not contain score data.');
      }

      return { overall, categories, subcategories, signals };
    };

    scoreUploadInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) {
        resetDashboard();
        return;
      }

      if (isExcelFile(file)) {
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            parsedDataset = parseWorkbook(loadEvent.target.result);
            const dates = collectSnapshotDates(parsedDataset);
            populateReferenceOptions(dates);
            resetTenantTypeSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            resetAccountSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            clearVisualizations('Select a snapshot date and account, then click "Load score".');
            selectedMonthLabel.textContent = 'Not selected';
            selectedAccountLabel.textContent = 'Not selected';
            updateLoadButtonState();
          } catch (error) {
            console.error('Unable to parse Excel file', error);
            alert('The uploaded file is not a valid Customer Success Score export.');
            resetDashboard();
          }
        };
        reader.readAsArrayBuffer(file);
      } else {
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
          try {
            const rawRows = parseCSV(loadEvent.target.result);
            const signals = rawRows.map(normalizeSignalRow);
            if (!signals.length) {
              alert('The uploaded file does not contain any records.');
              resetDashboard();
              return;
            }
            parsedDataset = {
              overall: [],
              categories: [],
              subcategories: [],
              signals,
            };
            const dates = collectSnapshotDates(parsedDataset);
            populateReferenceOptions(dates);
            resetTenantTypeSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            resetAccountSelect(dates.length ? 'Select a snapshot date first' : 'No data available');
            clearVisualizations('Select a snapshot date and account, then click "Load score".');
            selectedMonthLabel.textContent = 'Not selected';
            selectedAccountLabel.textContent = 'Not selected';
            updateLoadButtonState();
          } catch (error) {
            console.error('Unable to parse CSV file', error);
            alert('The uploaded file is not a valid Customer Success Score export.');
            resetDashboard();
          }
        };
        reader.readAsText(file);
      }
    });

    referenceMonthSelect.addEventListener('change', () => {
      populateTenantTypeOptions(referenceMonthSelect.value);
      const tenantValue =
        tenantTypeFilterSelect && !tenantTypeFilterSelect.disabled ? tenantTypeFilterSelect.value || 'all' : 'all';
      populateAccountOptions(referenceMonthSelect.value, tenantValue);
      selectedAccountLabel.textContent = 'Not selected';
      updateLoadButtonState();
    });

    if (tenantTypeFilterSelect) {
      tenantTypeFilterSelect.addEventListener('change', () => {
        const tenantValue = tenantTypeFilterSelect.disabled ? 'all' : tenantTypeFilterSelect.value || 'all';
        populateAccountOptions(referenceMonthSelect.value, tenantValue);
        selectedAccountLabel.textContent = 'Not selected';
        updateLoadButtonState();
      });
    }

    accountFilterSelect.addEventListener('change', () => {
      updateLoadButtonState();
    });

    loadScoreBtn.addEventListener('click', () => {
      const snapshotDate = referenceMonthSelect.value;
      const accountName = accountFilterSelect.value;
      if (!snapshotDate || !parsedDataset || !accountName) return;
      const tenantValue = tenantTypeFilterSelect && !tenantTypeFilterSelect.disabled ? tenantTypeFilterSelect.value : '';
      refreshDashboard(parsedDataset, snapshotDate, accountName, tenantValue);
    });

    searchInputs.forEach((input) => {
      input.addEventListener('input', (event) => syncSearchInputs(event.target));
    });
    categoryFilters.forEach((select) => {
      select.addEventListener('change', (event) => syncCategoryFilters(event.target));
    });

    if (allSignalsSubcategoryFilter) {
      allSignalsSubcategoryFilter.addEventListener('change', () => {
        updateAllSignalsFilterOptions({ resetCapability: true });
        applyFilters();
      });
    }

    if (signalTypeFilter) {
      signalTypeFilter.addEventListener('change', () => {
        currentAllSignalsFilters.signalType = getSelectedSignalType();
        updateAllSignalsFilterOptions({ resetSubcategory: true, resetCapability: true, resetRating: true });
        applyFilters();
      });
    }

    if (allSignalsCapabilityFilter) {
      allSignalsCapabilityFilter.addEventListener('change', applyFilters);
    }

    if (allSignalsRatingFilter) {
      allSignalsRatingFilter.addEventListener('change', applyFilters);
    }

    if (exportOverallButton) {
      exportOverallButton.addEventListener('click', () => {
        if (exportOverallButton.disabled) return;
        const payload = {
          accountOverview: buildAccountOverviewPayload(),
          overallSummary: cloneForExport(currentOverallSummaryData.summaries),
        };
        if (currentOverallSummaryData.categoryBreakdown.length) {
          payload.categoryBreakdown = cloneForExport(currentOverallSummaryData.categoryBreakdown);
        }
        triggerJsonDownload(buildExportFilename('overall-score-summary'), payload);
      });
    }

    if (exportSignalsButton) {
      exportSignalsButton.addEventListener('click', () => {
        if (exportSignalsButton.disabled) return;
        const payload = {
          accountOverview: buildAccountOverviewPayload(),
        };

        const overallScoreSnapshot = buildOverallScoreSnapshot();
        if (overallScoreSnapshot) {
          payload['Overall score'] = overallScoreSnapshot;
        }

        payload.filters = { ...currentAllSignalsFilters };
        payload.signals = cloneForExport(currentFilteredSignals);
        triggerJsonDownload(buildExportFilename('all-scored-signals'), payload);
      });
    }

    resetDashboard();
  </script>

</body>
</html>
