<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Customer Success Score Analyzer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --primary: #0ea5e9;
      --success: #15803d;
      --warning: #b45309;
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #64748b;
      --border: rgba(148, 163, 184, 0.35);
      --shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    body {
      background: linear-gradient(160deg, #e2e8f0, #f8fafc 45%, #ffffff 100%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    .page-header {
      padding: 3rem 5vw 1.5rem;
      display: grid;
      gap: 1.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .page-header h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 700;
    }

    .page-header p {
      color: var(--muted);
      max-width: 900px;
      line-height: 1.6;
    }

    .reference-month {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--muted);
    }

    main {
      padding: 0 5vw;
      display: grid;
      gap: 2.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .panel {
      background: var(--surface);
      border-radius: 1.25rem;
      padding: 1.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }

    .panel h2 {
      font-size: 1.35rem;
      margin-bottom: 1rem;
      color: var(--text);
    }

    .data-loader {
      display: grid;
      gap: 1.25rem;
    }

    .form-grid {
      display: grid;
      gap: 1.25rem;
    }

    @media (min-width: 720px) {
      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: end;
      }
    }

    .form-group {
      display: grid;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text);
    }

    .form-group select,
    .form-group input[type="file"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .load-button {
      justify-self: start;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    .load-button:disabled {
      background: var(--surface-alt);
      color: var(--muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    .helper-text {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .grid-3 {
      display: grid;
      gap: 1.5rem;
    }

    @media (min-width: 900px) {
      .grid-3 {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    .key-metric {
      border-radius: 1rem;
      padding: 1.5rem;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.12), rgba(148, 163, 184, 0.08));
      display: grid;
      gap: 0.75rem;
    }

    .key-metric h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .key-metric strong {
      display: block;
      font-size: 2.2rem;
      font-weight: 700;
      color: var(--text);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.85rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-weight: 600;
      color: var(--text);
      background: rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }

    .badge.up {
      color: var(--success);
      background: rgba(21, 128, 61, 0.12);
    }

    .badge.down {
      color: var(--danger);
      background: rgba(185, 28, 28, 0.12);
    }

    .overview-grid {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 720px) {
      .overview-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .overview-card {
      border-radius: 1rem;
      padding: 1.25rem;
      background: var(--surface-alt);
      border: 1px solid var(--border);
      display: grid;
      gap: 0.65rem;
    }

    .overview-card strong {
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--text);
    }

    .signal-list {
      display: grid;
      gap: 1rem;
    }

    .signal-item {
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      display: grid;
      gap: 0.35rem;
    }

    .signal-item header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
      margin-bottom: 0.25rem;
    }

    .signal-item h4 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .signal-definition {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 0.35rem;
      line-height: 1.4;
    }

    .signal-category {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .signal-metrics {
      display: grid;
      gap: 0.65rem;
      margin-top: 0.5rem;
    }

    .score-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .metric-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.8rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .metric-pill strong {
      font-size: 0.85rem;
      color: inherit;
    }

    .category-deck {
      display: grid;
      gap: 1.5rem;
    }

    .category-card {
      border-radius: 1.25rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      padding: 1.5rem;
      display: grid;
      gap: 1.25rem;
    }

    .category-headline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: space-between;
      align-items: center;
    }

    .subcategory-heading {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }

    .capability {
      border-radius: 1rem;
      padding: 1.25rem;
      border: 1px solid var(--border);
      background: var(--surface);
      display: grid;
      gap: 1rem;
    }

    .signals {
      display: grid;
      gap: 0.75rem;
    }

    .signal-chip {
      display: grid;
      gap: 0.35rem;
      padding: 0.85rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: var(--surface-alt);
    }

    .signal-chip span {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .signal-chip strong {
      font-size: 1.05rem;
      color: var(--text);
    }

    .score-pill {
      justify-self: flex-start;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .score-high {
      background: rgba(21, 128, 61, 0.15);
      color: var(--success);
    }

    .score-medium {
      background: rgba(234, 179, 8, 0.18);
      color: #b45309;
    }

    .score-low {
      background: rgba(185, 28, 28, 0.15);
      color: var(--danger);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .filters input,
    .filters select {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      color: var(--text);
      min-width: 200px;
      font-size: 0.95rem;
    }

    .filters input::placeholder {
      color: var(--muted);
    }

    .empty-state {
      padding: 1rem;
      color: var(--muted);
      font-style: italic;
    }

    @media (max-width: 640px) {
      .page-header,
      main {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <div>
      <h1>Customer Success Score Analyzer</h1>
      <p>
        Explore key metrics, trends, and scored signals for your customer success score. Upload a CSV export, pick a snapshot date,
        and use the interactive filters to uncover opportunities and risks faster.
      </p>
    </div>
    <div class="reference-month">Reference month: <strong id="selectedMonth">Not selected</strong></div>
  </header>
  <main>
    <section class="panel" id="dataLoaderPanel">
      <h2>Load customer success score</h2>
      <div class="data-loader">
        <div class="form-grid">
          <div class="form-group">
            <label for="referenceMonth">Snapshot date</label>
            <select id="referenceMonth">
              <option value="" disabled selected>Upload a CSV to populate dates</option>
            </select>
          </div>
          <div class="form-group">
            <label for="scoreUpload">Upload Customer Success Score CSV</label>
            <input type="file" id="scoreUpload" accept=".csv,text/csv">
          </div>
        </div>
        <button class="load-button" type="button" id="loadScoreBtn" disabled>Load score</button>
        <p class="helper-text">
          Upload a CSV export from Customer Success Score. The file is not sent anywhere; parsing happens in your browser. The
          selected snapshot date determines which records are displayed across the dashboard.
        </p>
      </div>
    </section>

    <section class="panel" id="account-overview">
      <h2>Account overview</h2>
      <div class="grid-3" id="accountCards"></div>
    </section>

    <section class="panel" id="overall-performance">
      <h2>Overall performance</h2>
      <div class="overview-grid" id="overviewGrid"></div>
    </section>

    <section class="panel" id="all-scored-signals">
      <h2>All scored signals</h2>
      <p class="helper-text">Every scored signal from the CSV file is listed below and respects the filters above.</p>
      <div class="signal-list" id="allSignalsList"></div>
    </section>

    <section class="panel" id="trends">
      <div class="filters">
        <input type="search" id="signalSearch" placeholder="Search a signal..." />
        <select id="trendFilter">
          <option value="all">Trend: all</option>
          <option value="up">Only improving</option>
          <option value="down">Only declining</option>
        </select>
        <select id="categoryFilter">
          <option value="all">Category: all</option>
        </select>
      </div>
      <div class="grid-3" style="margin-top: 1.5rem;" id="trendColumns">
        <div>
          <h3>Trending up</h3>
          <div class="signal-list" id="trendingUp"></div>
        </div>
        <div>
          <h3>Trending down</h3>
          <div class="signal-list" id="trendingDown"></div>
        </div>
        <div>
          <h3>Warnings / At risk</h3>
          <div class="signal-list" id="lowSignals"></div>
        </div>
      </div>
    </section>

    <section class="panel" id="categories">
      <h2>Category analysis</h2>
      <div class="category-deck" id="categoryDeck"></div>
    </section>
  </main>

  <template id="signalTemplate">
    <article class="signal-item">
      <header>
        <div style="display:flex; flex-direction:column; gap:0.25rem;">
          <h4 data-field="signal"></h4>
          <p class="signal-definition" data-field="definition"></p>
        </div>
        <span class="badge" data-field="change"></span>
      </header>
      <p class="signal-category" data-field="category"></p>
      <div class="signal-metrics">
        <div class="score-group">
          <strong data-field="score"></strong>
          <span class="badge" data-field="rating"></span>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:0.5rem;">
          <span class="metric-pill" data-field="value"></span>
          <span class="metric-pill" data-field="benchmark"></span>
          <span class="metric-pill" data-field="mom"></span>
          <span class="metric-pill" data-field="qoq"></span>
        </div>
      </div>
    </article>
  </template>

  <script>
    const scoreClass = (score) => {
      if (Number.isFinite(score)) {
        if (score >= 80) return 'score-high';
        if (score >= 50) return 'score-medium';
        return 'score-low';
      }
      return 'score-medium';
    };

    const formatScore = (score, fallback) => {
      if (Number.isFinite(score)) {
        const options = Number.isInteger(score)
          ? { maximumFractionDigits: 0 }
          : { maximumFractionDigits: 2 };
        return new Intl.NumberFormat('en-US', options).format(score);
      }
      if (fallback !== undefined && fallback !== null && `${fallback}`.trim()) {
        return `${fallback}`.trim();
      }
      if (typeof score === 'string' && score.trim()) return score.trim();
      return '-';
    };

    const createScoreBadge = (score) => {
      const span = document.createElement('span');
      span.className = `score-pill ${scoreClass(score)}`;
      span.textContent = `Score ${formatScore(score)}`;
      return span;
    };

    const createOverviewCard = (title, value, extra) => {
      const card = document.createElement('article');
      card.className = 'overview-card';
      const h3 = document.createElement('h3');
      h3.textContent = title;
      const strong = document.createElement('strong');
      strong.textContent = formatScore(value);
      card.append(h3, strong);
      if (extra) {
        const span = document.createElement('span');
        span.className = 'badge';
        span.textContent = extra;
        card.appendChild(span);
      }
      return card;
    };

    const formatNumber = (value, options = {}) => {
      if (!Number.isFinite(value)) return '';
      const formatter = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 2,
        ...options,
      });
      return formatter.format(value);
    };

    const parseNumber = (value) => {
      if (value === null || value === undefined) return null;
      const str = String(value).trim();
      if (!str) return null;
      const sanitized = str.replace(/\s|%/g, '');
      const match = sanitized.match(/[-+]?\d+[.,]?\d*(?:[.,]\d+)?/);
      if (!match) return null;
      let numeric = match[0];
      const lastComma = numeric.lastIndexOf(',');
      const lastDot = numeric.lastIndexOf('.');
      if (lastComma > lastDot) {
        numeric = numeric.replace(/\./g, '').replace(',', '.');
      } else if (lastDot > lastComma) {
        numeric = numeric.replace(/,/g, '');
      } else {
        numeric = numeric.replace(/[.,]/g, '');
      }
      const parsed = Number(numeric);
      return Number.isFinite(parsed) ? parsed : null;
    };

    const ratingFromScore = (score) => {
      if (!Number.isFinite(score)) return '';
      if (score >= 80) return 'Excellent';
      if (score >= 50) return 'On track';
      return 'Needs attention';
    };

    const formatSigned = (value) => {
      if (!Number.isFinite(value)) return 'N/A';
      if (value === 0) return '0';
      const formatted = formatNumber(Math.abs(value));
      return `${value > 0 ? '+' : '-'}${formatted}`;
    };

    const changePiece = (value, label) => {
      if (!Number.isFinite(value)) return null;
      const formatted = formatNumber(Math.abs(value));
      const direction = value > 0 ? '↑' : value < 0 ? '↓' : '→';
      return `${direction} ${formatted} ${label}`;
    };

    const buildChangeLabel = (mom, qoq) => {
      return [changePiece(mom, 'MoM'), changePiece(qoq, 'QoQ')]
        .filter(Boolean)
        .join(' • ');
    };

    const evaluateBenchmark = (valueNumeric, benchmarkRaw) => {
      if (!Number.isFinite(valueNumeric)) return null;
      if (!benchmarkRaw) return null;
      const cleaned = benchmarkRaw.replace(/\s/g, '');
      const match = cleaned.match(/(<=|>=|<|>|=)\s*([-+]?\d+[.,]?\d*(?:[.,]\d+)?)/);
      if (!match) return null;
      const operator = match[1];
      const threshold = parseNumber(match[2]);
      if (!Number.isFinite(threshold)) return null;
      switch (operator) {
        case '<=':
          return valueNumeric <= threshold ? 'met' : 'missed';
        case '>=':
          return valueNumeric >= threshold ? 'met' : 'missed';
        case '<':
          return valueNumeric < threshold ? 'met' : 'missed';
        case '>':
          return valueNumeric > threshold ? 'met' : 'missed';
        case '=':
          return valueNumeric === threshold ? 'met' : 'missed';
        default:
          return null;
      }
    };

    const splitCSVLine = (line) => {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const char = line[i];
        if (char === '"') {
          const next = line[i + 1];
          if (inQuotes && next === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    };

    const parseCSV = (text) => {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = [];
      let buffer = '';
      let inQuotes = false;
      for (let i = 0; i < normalized.length; i += 1) {
        const char = normalized[i];
        if (char === '"') {
          const next = normalized[i + 1];
          if (inQuotes && next === '"') {
            buffer += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === '\n' && !inQuotes) {
          lines.push(buffer);
          buffer = '';
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        lines.push(buffer);
      }
      const filtered = lines.filter((line) => line.trim().length);
      if (!filtered.length) return [];
      const headerCells = splitCSVLine(filtered.shift());
      if (!headerCells.length) return [];
      headerCells[0] = headerCells[0].replace(/^\uFEFF/, '');
      const headers = headerCells.map((cell) => cell.trim());
      const rows = [];
      for (const line of filtered) {
        const cells = splitCSVLine(line).map((cell) => cell.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = cells[index] ?? '';
        });
        const hasData = Object.values(row).some((value) => value && `${value}`.trim().length);
        if (hasData) {
          rows.push(row);
        }
      }
      return rows;
    };

    const COLUMN_MAP = {
      'Snapshot Date': 'snapshotDate',
      'Company Name': 'companyName',
      'Company ID': 'companyId',
      'Account Name': 'accountName',
      'Account ID': 'accountId',
      'Tenant Type': 'tenantType',
      'Tenant ID': 'tenantId',
      'Account Local Name': 'accountLocalName',
      'Success Plan': 'successPlan',
      'Category Name': 'categoryName',
      'Subcategory Name': 'subcategoryName',
      'Capability Name': 'capabilityName',
      'Signal Name': 'signalName',
      Definition: 'definition',
      Score: 'scoreRaw',
      Value: 'value',
      'MoM Change': 'moMChangeRaw',
      'QoQ Change': 'qoQChangeRaw',
      Benchmark: 'benchmark',
    };

    const normalizeRow = (row) => {
      const normalized = {};
      for (const [column, key] of Object.entries(COLUMN_MAP)) {
        const value = row[column] ?? row[column.replace(/\s+/g, ' ')] ?? '';
        normalized[key] = typeof value === 'string' ? value.trim() : value;
      }
      normalized.score = parseNumber(normalized.scoreRaw);
      normalized.valueNumeric = parseNumber(normalized.value);
      normalized.moMChange = parseNumber(normalized.moMChangeRaw);
      normalized.qoQChange = parseNumber(normalized.qoQChangeRaw);
      return normalized;
    };

    const transformRow = (row) => {
      const processed = { ...row };
      processed.rating = ratingFromScore(row.score);
      processed.categoryDescription = [row.categoryName, row.subcategoryName, row.capabilityName]
        .filter(Boolean)
        .join(' • ');
      processed.changeText = buildChangeLabel(row.moMChange, row.qoQChange);
      processed.changeDirection = row.moMChange > 0 || row.qoQChange > 0 ? 'up' : row.moMChange < 0 || row.qoQChange < 0 ? 'down' : 'flat';
      processed.momText = Number.isFinite(row.moMChange)
        ? `${row.moMChange > 0 ? '+' : row.moMChange < 0 ? '-' : ''}${formatNumber(Math.abs(row.moMChange))}`
        : '';
      processed.qoqText = Number.isFinite(row.qoQChange)
        ? `${row.qoQChange > 0 ? '+' : row.qoQChange < 0 ? '-' : ''}${formatNumber(Math.abs(row.qoQChange))}`
        : '';
      processed.valueDisplay = row.value && row.value.length ? row.value : Number.isFinite(row.valueNumeric) ? formatNumber(row.valueNumeric) : '';
      const benchmarkStatus = evaluateBenchmark(row.valueNumeric, row.benchmark);
      processed.benchmarkStatus = benchmarkStatus;
      processed.benchmarkDisplay = row.benchmark
        ? `${row.benchmark}${benchmarkStatus ? ` • ${benchmarkStatus}` : ''}`
        : '';
      return processed;
    };

    const average = (values) => {
      const valid = values.filter((value) => Number.isFinite(value));
      if (!valid.length) return null;
      return valid.reduce((sum, value) => sum + value, 0) / valid.length;
    };

    const computeSummary = (rows) => {
      const categories = new Set(rows.map((row) => row.categoryName).filter(Boolean));
      const capabilities = new Set(
        rows.map((row) => `${row.categoryName || '—'}::${row.capabilityName || row.subcategoryName || '—'}`)
      );
      const benchmarkEvaluated = rows.filter((row) => row.benchmarkStatus);
      const met = benchmarkEvaluated.filter((row) => row.benchmarkStatus === 'met').length;
      const missed = benchmarkEvaluated.filter((row) => row.benchmarkStatus === 'missed').length;
      return {
        averageScore: average(rows.map((row) => row.score)),
        totalSignals: rows.length,
        uniqueCategories: categories.size,
        uniqueCapabilities: capabilities.size,
        averageValue: average(rows.map((row) => row.valueNumeric)),
        averageMoM: average(rows.map((row) => row.moMChange)),
        averageQoQ: average(rows.map((row) => row.qoQChange)),
        benchmarkEvaluated: {
          total: benchmarkEvaluated.length,
          met,
          missed,
        },
      };
    };

    const buildCategoryHierarchy = (rows) => {
      const categoryMap = new Map();
      for (const row of rows) {
        const categoryName = row.categoryName || 'Uncategorized';
        const subcategoryName = row.subcategoryName || 'General';
        const capabilityName = row.capabilityName || 'General';

        if (!categoryMap.has(categoryName)) {
          categoryMap.set(categoryName, {
            name: categoryName,
            scores: [],
            moms: [],
            qoqs: [],
            subcategories: new Map(),
          });
        }

        const category = categoryMap.get(categoryName);
        if (Number.isFinite(row.score)) category.scores.push(row.score);
        if (Number.isFinite(row.moMChange)) category.moms.push(row.moMChange);
        if (Number.isFinite(row.qoQChange)) category.qoqs.push(row.qoQChange);

        if (!category.subcategories.has(subcategoryName)) {
          category.subcategories.set(subcategoryName, new Map());
        }

        const subcategory = category.subcategories.get(subcategoryName);
        if (!subcategory.has(capabilityName)) {
          subcategory.set(capabilityName, {
            name: capabilityName,
            subcategory: subcategoryName,
            scores: [],
            moms: [],
            qoqs: [],
            signals: [],
          });
        }

        const capability = subcategory.get(capabilityName);
        capability.signals.push(row);
        if (Number.isFinite(row.score)) capability.scores.push(row.score);
        if (Number.isFinite(row.moMChange)) capability.moms.push(row.moMChange);
        if (Number.isFinite(row.qoQChange)) capability.qoqs.push(row.qoQChange);
      }

      return Array.from(categoryMap.values())
        .map((category) => {
          const capabilities = [];
          for (const subcategory of category.subcategories.values()) {
            for (const capability of subcategory.values()) {
              const score = average(capability.scores);
              const mom = average(capability.moms);
              const qoq = average(capability.qoqs);
              capabilities.push({
                name: capability.name,
                subcategory: capability.subcategory,
                score,
                rating: ratingFromScore(score),
                changeText: buildChangeLabel(mom, qoq),
                momChange: mom,
                qoQChange: qoq,
                signals: capability.signals,
              });
            }
          }

          const score = average(category.scores);
          const mom = average(category.moms);
          const qoq = average(category.qoqs);

          return {
            name: category.name,
            score,
            rating: ratingFromScore(score),
            changeText: buildChangeLabel(mom, qoq),
            momChange: mom,
            qoQChange: qoq,
            capabilities: capabilities.sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity)),
          };
        })
        .sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity));
    };

    const createInfoCard = (title, main, subtitle) => {
      const card = document.createElement('article');
      card.className = 'key-metric';
      const h3 = document.createElement('h3');
      h3.textContent = title;
      const strong = document.createElement('strong');
      strong.textContent = main;
      card.append(h3, strong);
      if (subtitle) {
        const span = document.createElement('span');
        span.className = 'badge';
        span.textContent = subtitle;
        card.appendChild(span);
      }
      return card;
    };

    const formatSnapshotMonth = (snapshotDate) => {
      if (!snapshotDate) {
        return 'N/A';
      }

      const trimmed = `${snapshotDate}`.trim();
      const isoMatch = trimmed.match(/^(\d{4})-(\d{1,2})(?:-(\d{1,2}))?$/);
      let parsed = null;

      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        parsed = new Date(Number(year), Number(month) - 1, Number(day || 1));
      } else {
        const attempt = new Date(trimmed);
        if (!Number.isNaN(attempt.getTime())) {
          parsed = attempt;
        }
      }

      if ((!parsed || Number.isNaN(parsed.getTime())) && trimmed.includes('/')) {
        const parts = trimmed.split('/').map((part) => part.trim());
        if (parts.length === 3) {
          if (parts[0].length === 4) {
            const [year, month, day] = parts.map((part) => Number.parseInt(part, 10));
            parsed = new Date(year, (month || 1) - 1, day || 1);
          } else if (parts[2].length === 4) {
            const [first, second, year] = parts.map((part) => Number.parseInt(part, 10));
            const month = Number.isFinite(first) ? first : 1;
            parsed = new Date(year, (month || 1) - 1, Number.isFinite(second) ? second : 1);
          }
        }
      }

      if (!parsed || Number.isNaN(parsed.getTime())) {
        return snapshotDate;
      }

      return parsed.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    };

    const populateAccountOverview = (info, snapshotDate) => {
      const container = document.getElementById('accountCards');
      container.innerHTML = '';
      const cards = [
        createInfoCard('Company', info.companyName || 'N/A'),
        createInfoCard('Account local name', info.accountLocalName || 'N/A'),
        createInfoCard('Snapshot date', formatSnapshotMonth(snapshotDate)),
      ];
      cards.forEach((card) => container.appendChild(card));
    };

    const populateSummaryCards = (summary) => {
      const grid = document.getElementById('overviewGrid');
      grid.innerHTML = '';
      grid.appendChild(
        createOverviewCard(
          'Average score',
          summary.averageScore,
          ratingFromScore(summary.averageScore) || 'No scored signals'
        )
      );
      grid.appendChild(
        createOverviewCard(
          'Signals in snapshot',
          summary.totalSignals,
          `${summary.uniqueCategories} categories • ${summary.uniqueCapabilities} capabilities`
        )
      );
      grid.appendChild(
        createOverviewCard(
          'Average MoM change',
          formatSigned(summary.averageMoM),
          summary.averageQoQ === null ? '' : `Avg QoQ ${formatSigned(summary.averageQoQ)}`
        )
      );
      const benchmarkInfo = summary.benchmarkEvaluated.total
        ? `${summary.benchmarkEvaluated.met}/${summary.benchmarkEvaluated.total} met`
        : 'No benchmark rules';
      const benchmarkExtra = summary.benchmarkEvaluated.missed
        ? `${summary.benchmarkEvaluated.missed} missed`
        : summary.benchmarkEvaluated.total
          ? 'All met'
          : '';
      grid.appendChild(createOverviewCard('Benchmark adherence', benchmarkInfo, benchmarkExtra));
    };

    const createMetricPill = (label, value) => {
      if (value === null || value === undefined || `${value}`.trim() === '') return null;
      const pill = document.createElement('span');
      pill.className = 'metric-pill';
      pill.innerHTML = `<strong>${label}</strong> ${value}`;
      return pill;
    };

    const populateSignalList = (signals, container) => {
      container.innerHTML = '';
      if (!signals.length) {
        const empty = document.createElement('p');
        empty.className = 'empty-state';
        empty.textContent = 'No signals match the current filters.';
        container.appendChild(empty);
        return;
      }

      for (const item of signals) {
        const clone = document.getElementById('signalTemplate').content.firstElementChild.cloneNode(true);
        clone.querySelector('[data-field="signal"]').textContent = item.signalName;
        const definitionElement = clone.querySelector('[data-field="definition"]');
        if (item.definition) {
          definitionElement.textContent = item.definition;
        } else {
          definitionElement.remove();
        }
        const categoryElement = clone.querySelector('[data-field="category"]');
        categoryElement.textContent = item.categoryDescription || item.categoryName || '';

        const changeSpan = clone.querySelector('[data-field="change"]');
        if (item.changeText) {
          changeSpan.textContent = item.changeText;
          if (item.moMChange > 0 || item.qoQChange > 0) {
            changeSpan.classList.add('up');
          } else if (item.moMChange < 0 || item.qoQChange < 0) {
            changeSpan.classList.add('down');
          }
        } else {
          changeSpan.remove();
        }

        clone.querySelector('[data-field="score"]').textContent = formatScore(item.score, item.scoreRaw);

        const ratingBadge = clone.querySelector('[data-field="rating"]');
        if (item.rating) {
          ratingBadge.textContent = item.rating;
        } else {
          ratingBadge.remove();
        }

        const valuePill = clone.querySelector('[data-field="value"]');
        if (item.valueDisplay) {
          valuePill.innerHTML = `<strong>Value</strong> ${item.valueDisplay}`;
        } else {
          valuePill.remove();
        }

        const benchmarkPill = clone.querySelector('[data-field="benchmark"]');
        if (item.benchmarkDisplay) {
          benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmarkDisplay}`;
        } else if (item.benchmark) {
          benchmarkPill.innerHTML = `<strong>Benchmark</strong> ${item.benchmark}`;
        } else {
          benchmarkPill.remove();
        }

        const momPill = clone.querySelector('[data-field="mom"]');
        if (item.momText) {
          momPill.innerHTML = `<strong>MoM</strong> ${item.momText}`;
        } else {
          momPill.remove();
        }

        const qoqPill = clone.querySelector('[data-field="qoq"]');
        if (item.qoqText) {
          qoqPill.innerHTML = `<strong>QoQ</strong> ${item.qoqText}`;
        } else {
          qoqPill.remove();
        }

        container.appendChild(clone);
      }
    };

    const buildCategoryDeck = (categories) => {
      const deck = document.getElementById('categoryDeck');
      if (!categories.length) {
        deck.innerHTML = '<p class="empty-state">No category data available for the selected snapshot.</p>';
        return;
      }

      deck.innerHTML = '';

      for (const category of categories) {
        const categoryCard = document.createElement('article');
        categoryCard.className = 'category-card';

        const headline = document.createElement('div');
        headline.className = 'category-headline';
        const title = document.createElement('h3');
        title.textContent = category.name;
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = category.rating || 'N/A';
        headline.append(title, badge, createScoreBadge(category.score));
        categoryCard.appendChild(headline);

        if (category.changeText) {
          const change = document.createElement('span');
          change.className = `badge ${category.momChange > 0 ? 'up' : category.momChange < 0 ? 'down' : ''}`;
          change.textContent = category.changeText;
          categoryCard.appendChild(change);
        }

        const subcategoryGroups = new Map();
        for (const capability of category.capabilities || []) {
          const key = capability.subcategory || 'General';
          if (!subcategoryGroups.has(key)) {
            subcategoryGroups.set(key, []);
          }
          subcategoryGroups.get(key).push(capability);
        }

        for (const [subcategoryName, capabilities] of subcategoryGroups) {
          const subHeading = document.createElement('h4');
          subHeading.className = 'subcategory-heading';
          subHeading.textContent = subcategoryName;
          categoryCard.appendChild(subHeading);

          for (const capability of capabilities) {
            const capabilityBlock = document.createElement('section');
            capabilityBlock.className = 'capability';

            const heading = document.createElement('div');
            heading.style.display = 'flex';
            heading.style.justifyContent = 'space-between';
            heading.style.alignItems = 'center';
            heading.style.flexWrap = 'wrap';
            heading.style.gap = '0.75rem';

            const name = document.createElement('h4');
            name.textContent = capability.name;
            name.style.fontSize = '1.1rem';
            name.style.color = 'var(--text)';
            heading.appendChild(name);

            if (capability.rating) {
              const capabilityBadge = document.createElement('span');
              capabilityBadge.className = 'badge';
              capabilityBadge.textContent = capability.rating;
              heading.appendChild(capabilityBadge);
            }

            heading.appendChild(createScoreBadge(capability.score));

            if (capability.changeText) {
              const change = document.createElement('span');
              change.className = `badge ${capability.momChange > 0 ? 'up' : capability.momChange < 0 ? 'down' : ''}`;
              change.textContent = capability.changeText;
              heading.appendChild(change);
            }

            capabilityBlock.appendChild(heading);

            const signals = document.createElement('div');
            signals.className = 'signals';
            for (const signal of capability.signals || []) {
              const chip = document.createElement('div');
              chip.className = 'signal-chip';

              const title = document.createElement('strong');
              title.textContent = signal.signalName;
              chip.appendChild(title);

              if (signal.definition) {
                const definition = document.createElement('span');
                definition.textContent = signal.definition;
                chip.appendChild(definition);
              }

              const metrics = document.createElement('div');
              metrics.style.display = 'flex';
              metrics.style.flexWrap = 'wrap';
              metrics.style.gap = '0.5rem';
              metrics.style.marginTop = '0.35rem';

              const scorePill = createMetricPill('Score', formatScore(signal.score, signal.scoreRaw));
              if (scorePill) metrics.appendChild(scorePill);

              const ratingPill = createMetricPill('Rating', signal.rating);
              if (ratingPill) metrics.appendChild(ratingPill);

              const valuePill = createMetricPill('Value', signal.valueDisplay);
              if (valuePill) metrics.appendChild(valuePill);

              const benchmarkPill = createMetricPill('Benchmark', signal.benchmarkDisplay || signal.benchmark);
              if (benchmarkPill) metrics.appendChild(benchmarkPill);

              const momPill = createMetricPill('MoM', signal.momText);
              if (momPill) metrics.appendChild(momPill);

              const qoqPill = createMetricPill('QoQ', signal.qoqText);
              if (qoqPill) metrics.appendChild(qoqPill);

              chip.appendChild(metrics);
              signals.appendChild(chip);
            }
            capabilityBlock.appendChild(signals);
            categoryCard.appendChild(capabilityBlock);
          }
        }

        deck.appendChild(categoryCard);
      }
    };

    const populateCategoryOptions = (categories) => {
      const uniqueCategories = Array.from(new Set(categories)).filter(Boolean).sort();
      categoryFilter.innerHTML = '<option value="all">Category: all</option>';
      for (const name of uniqueCategories) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        categoryFilter.appendChild(option);
      }
      categoryFilter.value = 'all';
    };

    const clearVisualizations = (message) => {
      currentTrendData = null;
      allScoredSignals = [];
      document.getElementById('accountCards').innerHTML = '';
      document.getElementById('overviewGrid').innerHTML = '';
      document.getElementById('categoryDeck').innerHTML = `<p class="empty-state">${message}</p>`;
      document.getElementById('trendingUp').innerHTML = `<p class="empty-state">${message}</p>`;
      document.getElementById('trendingDown').innerHTML = `<p class="empty-state">${message}</p>`;
      document.getElementById('lowSignals').innerHTML = `<p class="empty-state">${message}</p>`;
      document.getElementById('allSignalsList').innerHTML = `<p class="empty-state">${message}</p>`;
      document.getElementById('signalSearch').value = '';
      document.getElementById('trendFilter').value = 'all';
      categoryFilter.innerHTML = '<option value="all">Category: all</option>';
      categoryFilter.value = 'all';
    };

    const populateReferenceOptions = (dates) => {
      referenceMonthSelect.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      placeholder.textContent = dates.length ? '-- Select snapshot date --' : 'Upload a CSV to populate dates';
      referenceMonthSelect.appendChild(placeholder);
      for (const date of dates) {
        const option = document.createElement('option');
        option.value = date;
        option.textContent = date;
        referenceMonthSelect.appendChild(option);
      }
    };

    const selectedMonthLabel = document.getElementById('selectedMonth');
    const referenceMonthSelect = document.getElementById('referenceMonth');
    const scoreUploadInput = document.getElementById('scoreUpload');
    const loadScoreBtn = document.getElementById('loadScoreBtn');
    const categoryFilter = document.getElementById('categoryFilter');

    let parsedRows = [];
    let currentTrendData = null;
    let allScoredSignals = [];

    const applyFilters = () => {
      if (!currentTrendData) return;
      const searchTerm = document.getElementById('signalSearch').value.toLowerCase();
      const trendFilterValue = document.getElementById('trendFilter').value;
      const categoryValue = categoryFilter.value;

      const matchesFilters = (signal) => {
        const matchesSearch =
          !searchTerm ||
          signal.signalName?.toLowerCase().includes(searchTerm) ||
          signal.definition?.toLowerCase().includes(searchTerm);
        const matchesCategory =
          categoryValue === 'all' ||
          signal.categoryName === categoryValue ||
          signal.categoryDescription?.startsWith(`${categoryValue}`);
        return matchesSearch && matchesCategory;
      };

      const trendingUpFiltered =
        trendFilterValue !== 'down' ? currentTrendData.trendingUp.filter(matchesFilters) : [];
      const trendingDownFiltered =
        trendFilterValue !== 'up' ? currentTrendData.trendingDown.filter(matchesFilters) : [];
      const lowSignalsFiltered = currentTrendData.lowSignals.filter(matchesFilters);
      const allSignalsFiltered = allScoredSignals.filter(matchesFilters);

      populateSignalList(trendingUpFiltered, document.getElementById('trendingUp'));
      populateSignalList(trendingDownFiltered, document.getElementById('trendingDown'));
      populateSignalList(lowSignalsFiltered, document.getElementById('lowSignals'));
      populateSignalList(allSignalsFiltered, document.getElementById('allSignalsList'));
    };

    const refreshDashboard = (rows, snapshotDate) => {
      if (!rows.length) {
        selectedMonthLabel.textContent = snapshotDate || 'Not selected';
        clearVisualizations('No records match the selected snapshot date.');
        return;
      }

      const processed = rows.map(transformRow);
      const summary = computeSummary(processed);
      const categories = buildCategoryHierarchy(processed);
      const accountInfo = processed[0];

      selectedMonthLabel.textContent = snapshotDate || 'Not selected';
      populateAccountOverview(accountInfo, snapshotDate);
      populateSummaryCards(summary);
      buildCategoryDeck(categories);

      currentTrendData = {
        trendingUp: processed.filter((signal) => Number.isFinite(signal.moMChange) && signal.moMChange > 0),
        trendingDown: processed.filter((signal) => Number.isFinite(signal.moMChange) && signal.moMChange < 0),
        lowSignals: processed.filter(
          (signal) =>
            (Number.isFinite(signal.score) && signal.score < 50) || signal.benchmarkStatus === 'missed'
        ),
      };
      allScoredSignals = processed;

      populateCategoryOptions(processed.map((signal) => signal.categoryName));
      applyFilters();
    };

    const updateLoadButtonState = () => {
      loadScoreBtn.disabled = !(parsedRows.length && referenceMonthSelect.value);
    };

    const resetDashboard = () => {
      parsedRows = [];
      selectedMonthLabel.textContent = 'Not selected';
      populateReferenceOptions([]);
      scoreUploadInput.value = '';
      loadScoreBtn.disabled = true;
      clearVisualizations('Upload a CSV file to begin the analysis.');
    };

    scoreUploadInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) {
        resetDashboard();
        return;
      }

      const reader = new FileReader();
      reader.onload = (loadEvent) => {
        try {
          const rawRows = parseCSV(loadEvent.target.result);
          parsedRows = rawRows.map(normalizeRow);
          if (!parsedRows.length) {
            resetDashboard();
            alert('The uploaded CSV does not contain any records.');
            return;
          }
          const snapshotDates = Array.from(
            new Set(parsedRows.map((row) => row.snapshotDate).filter((date) => date && date.length))
          ).sort((a, b) => {
            const dateA = new Date(a);
            const dateB = new Date(b);
            if (!Number.isNaN(dateA) && !Number.isNaN(dateB)) {
              return dateB - dateA;
            }
            return `${b}`.localeCompare(`${a}`);
          });
          populateReferenceOptions(snapshotDates);
          clearVisualizations('Select a snapshot date and click "Load score".');
          selectedMonthLabel.textContent = 'Not selected';
          updateLoadButtonState();
        } catch (error) {
          console.error('Unable to parse CSV file', error);
          alert('The uploaded file is not a valid Customer Success Score CSV export.');
          resetDashboard();
        }
      };
      reader.readAsText(file);
    });

    referenceMonthSelect.addEventListener('change', updateLoadButtonState);

    loadScoreBtn.addEventListener('click', () => {
      const snapshotDate = referenceMonthSelect.value;
      if (!snapshotDate || !parsedRows.length) return;
      const rows = parsedRows.filter((row) => row.snapshotDate === snapshotDate);
      refreshDashboard(rows, snapshotDate);
    });

    document.getElementById('signalSearch').addEventListener('input', applyFilters);
    document.getElementById('trendFilter').addEventListener('change', applyFilters);
    categoryFilter.addEventListener('change', applyFilters);

    resetDashboard();
  </script>

</body>
</html>
