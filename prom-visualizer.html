<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProM Alert Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f6; /* Light gray background */
            color: #333; /* Dark gray text */
            line-height: 1.6;
            padding: 1rem; /* Add some padding */
        }
        .container {
            max-width: 1200px; /* Keep a wider container for the visualizer content */
            margin: 2rem auto; /* Center the container with more vertical margin */
            background-color: #ffffff; /* White background */
            border-radius: 0.75rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); /* Stronger shadow */
            padding: 2rem; /* Increase padding */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        h1, h2, h3 {
            color: #1a202c; /* Darker heading color */
            margin-bottom: 1rem; /* Space below headings */
            font-weight: 700; /* Bold headings */
        }
        h1 {
            text-align: center; /* Center the main title */
            margin-bottom: 2rem; /* More space below the main title */
        }
        h2, h3 {
            margin-top: 0; /* Remove default top margin */
        }

        /* NEW Styles for Source Selector */
        .source-selector-container {
            margin-bottom: 1.5rem; /* Space below the selector */
            padding: 1rem;
            background-color: #f9fafb; /* Slightly different background */
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .source-selector-container h3 {
            font-size: 1.125rem; /* Equivalent to text-lg */
            font-weight: 600; /* Equivalent to font-semibold */
            margin-bottom: 0.75rem; /* Equivalent to mb-3 */
            color: #374151; /* Equivalent to text-gray-700 */
        }
        .source-selector-options div {
            margin-bottom: 0.5rem;
        }
        .source-selector-options label {
            color: #4b5563; /* Equivalent to text-gray-600 */
            cursor: pointer;
            margin-left: 0.25rem; /* Equivalent to ml-1 */
        }
         .source-selector-options input[type="radio"] {
            accent-color: #4f46e5; /* Indigo to match buttons */
         }


        textarea {
            width: 100%; /* Make textarea take full width */
            margin-bottom: 1.5rem; /* Increased margin */
            padding: 0.75rem; /* Increased padding */
            border-radius: 0.375rem; /* Rounded corners */
            border: 1px solid #d1d5db; /* Lighter border */
            min-height: 200px; /* Keep a good minimum height */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Use system monospace stack */
            font-size: 0.95em; /* Slightly larger font size */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* Style for buttons container */
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem; /* Increased gap between buttons */
            flex-wrap: wrap;
            margin-top: 2rem; /* More space above buttons */
            margin-bottom: 2rem; /* More space below buttons */
        }

        button {
            background-color: #4f46e5; /* Indigo primary button color */
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem; /* Increased padding */
            border-radius: 0.375rem; /* Rounded corners */
            cursor: pointer;
            font-size: 1rem; /* Standard font size */
            font-weight: 600; /* Semi-bold text */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        button:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-2px); /* Slight lift on hover */
        }

        /* Styles for Summary Widgets */
        .summary-widgets-container {
            display: flex;
            gap: 2rem; /* Increased space between cards */
            margin-bottom: 2rem; /* Increased space below the widgets */
            flex-wrap: wrap;
            justify-content: center; /* Center widgets if they wrap */
        }

        .widget-card {
            flex: 1;
            min-width: 300px; /* Minimum width before wrapping */
            max-width: 500px; /* Max width */
            background-color: #ffffff; /* White background */
            border: 1px solid #e5e7eb; /* Lighter border */
            border-radius: 0.5rem; /* Rounded corners */
            padding: 1.5rem; /* Increased padding */
            text-align: left;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            display: flex;
            flex-direction: column;
        }

        .widget-card h3 {
            margin-top: 0;
            margin-bottom: 1rem; /* Increased space below title */
            color: #1f2937; /* Darker title color */
            font-size: 1.25em; /* Slightly larger title */
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e5e7eb; /* Separator below title */
            padding-bottom: 0.75rem; /* Space between title and separator */
        }

        .widget-card .info-icon {
            font-size: 0.8em;
            margin-left: 0.5rem; /* Increased space */
            color: #6b7280; /* Gray color */
            cursor: help;
        }

        .widget-card .total-count {
            font-size: 3.5em; /* Larger number style */
            font-weight: 700; /* Bold */
            color: #4f46e5; /* Indigo color */
            margin-bottom: 1.5rem; /* Increased space */
            text-align: center; /* Center the total count */
        }

        .level-breakdown,
        .top-metrics-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* Allow lists to take available space */
        }

        .level-breakdown li,
        .top-metrics-list li {
            margin-bottom: 0.75rem; /* Increased space between list items */
            font-size: 0.95em;
            color: #4b5563; /* Darker gray */
        }

        .level-breakdown li {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .level-breakdown .level-name {
            flex-basis: 90px; /* Slightly wider fixed width */
            flex-shrink: 0;
            margin-right: 1rem; /* Increased space */
            font-weight: 600; /* Semi-bold */
            color: #1f2937; /* Darker color for name */
        }

        .level-breakdown .level-bar {
            flex-grow: 1;
            height: 12px; /* Thicker bar */
            background-color: #e5e7eb; /* Light gray background for the bar track */
            border-radius: 6px; /* More rounded corners */
            overflow: hidden;
            margin-right: 1rem; /* Increased space */
        }

        .level-breakdown .level-bar-inner {
            height: 100%;
            /* Width will be set by JS */
            transition: width 0.5s ease-in-out; /* Smooth transition for bar width */
        }

        /* Specific colors for levels (using Tailwind color palette where possible) */
        .level-breakdown .level-bar-inner.warning {
            background-color: #fcd34d; /* Tailwind amber-400 */
        }
        .level-breakdown .level-bar-inner.critical {
            background-color: #ef4444; /* Tailwind red-500 */
        }
        .level-breakdown .level-bar-inner.exhausted {
            background-color: #a78bfa; /* Tailwind violet-400 */
        }
        .level-breakdown .level-bar-inner.info {
            background-color: #38b2ac; /* Tailwind teal-500 */
        }
        .level-breakdown .level-bar-inner.cleared { /* NEW for Gadget UI status */
             background-color: #34d399; /* Tailwind green-400 for Cleared status */
        }
        .level-breakdown .level-bar-inner.other {
            background-color: #6b7280; /* Tailwind gray-500 for unknown */
        }


        .level-breakdown .level-count,
        .top-metrics-list .metric-count {
            font-weight: 600; /* Semi-bold */
            flex-shrink: 0;
            color: #1f2937; /* Darker color for count */
        }

        .top-metrics-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem; /* space before bottom border */
            border-bottom: 1px dashed #d1d5db; /* subtle separator */
        }
        .top-metrics-list li:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .top-metrics-list .metric-name {
            flex-grow: 1;
            margin-right: 0.75rem; /* space between name and count */
            color: #374151; /* Darker color */
            word-break: break-word; /* Allow long names to wrap */
        }

        .chart-container {
            margin-bottom: 2rem; /* Increased margin */
            padding: 1.5rem; /* Increased padding */
            border: 1px solid #e5e7eb; /* Lighter border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: #ffffff; /* White background */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Match widget shadow */
        }

        canvas {
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
        }

        /* Message box styling */
        .message-box {
            display: none;
            position: fixed;
            top: 1rem; /* Adjusted top position */
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem; /* Increased padding */
            background-color: #fef2f2; /* Tailwind red-50 */
            color: #991b1b; /* Tailwind red-800 */
            border: 1px solid #fca5a5; /* Tailwind red-300 */
            border-radius: 0.375rem; /* Rounded corners */
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 90%; /* Increased max-width */
            text-align: left;
        }
        .message-box.success {
            background-color: #ecfdf5; /* Tailwind green-50 */
            color: #065f46; /* Tailwind green-800 */
            border-color: #a7f3d0; /* Tailwind green-200 */
        }
        .message-box.warning {
            background-color: #fffbeb; /* Tailwind amber-50 */
            color: #92400e; /* Tailwind amber-800 */
            border-color: #fcd34d; /* Tailwind amber-300 */
        }

        /* Footer styling */
        footer {
            text-align: center;
            padding: 1.5rem; /* Increased padding */
            font-size: 0.875rem; /* Smaller text size */
            color: #6b7280; /* Gray text color */
            margin-top: 2rem; /* Space above the footer */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">ProM Alert Visualizer</h1>

        <div class="source-selector-container">
            <h3>Select Data Source Type:</h3>
            <div class="source-selector-options">
                <div>
                    <input type="radio" id="sourceProactiveMonitoring" name="dataSourceType" value="proactiveMonitoring" checked>
                    <label for="sourceProactiveMonitoring">Proactive Monitoring Internal Portal</label>
                </div>
                <div>
                    <input type="radio" id="sourceGadgetUI" name="dataSourceType" value="gadgetUI">
                    <label for="sourceGadgetUI">Gadget-UI Portal</label>
                </div>
            </div>
        </div>

        <textarea id="alertData" rows="15"
            placeholder="Paste RAW data copied from the alert source here..."></textarea>

        <div class="button-group">
            <button id="visualizeButton">Visualize Data</button>
        </div>

        <div class="summary-widgets-container">
            <div class="widget-card">
                <h3>Total ProM Alerts <span class="info-icon" title="Total count of alerts processed with valid dates and duration.">&#x24D8;</span></h3>
                <div class="total-count" id="totalAlertCountWidget">0</div>
                <div class="level-breakdown" id="levelBreakdownWidget">
                </div>
            </div>
            <div class="widget-card">
                <h3>Top Alerts by Volume <span class="info-icon" title="Top 5 Alert Metrics by total count over the period.">&#x24D8;</span></h3>
                <div class="top-metrics-list" id="topMetricsListWidget">
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h3 id="alertCountChartTitle">Timeline of ProM alerts</h3>
            <canvas id="alertCountChart"></canvas>
        </div>

        <div class="chart-container">
            <h3>Total Alert Duration per Week (hours)</h3>
            <canvas id="totalDurationChart"></canvas>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <footer>
        These tools are not official or Salesforce authorized. They have been developed for personal purpose by Saverio Guardato with the aim of improving CSM tasks.
    </footer>

    <script>
        // Register the datalabels plugin globally
        Chart.register(ChartDataLabels);

        document.addEventListener('DOMContentLoaded', function () {
            const visualizeButton = document.getElementById('visualizeButton');
            const alertDataTextarea = document.getElementById('alertData');
            const messageBox = document.getElementById('messageBox');
            const alertCountChartTitleElement = document.getElementById('alertCountChartTitle');

            const totalAlertCountWidget = document.getElementById('totalAlertCountWidget');
            const levelBreakdownWidget = document.getElementById('levelBreakdownWidget');
            const topMetricsListWidget = document.getElementById('topMetricsListWidget');

            let alertCountChartInstance = null;
            let totalDurationChartInstance = null;
            // let currentProcessedData = null; // Not strictly needed globally if passed around

            visualizeButton.addEventListener('click', visualizeData);

            function showMessage(message, type = 'error') {
                messageBox.textContent = message;
                messageBox.className = `message-box ${type}`; // Ensure only one type class is applied
                messageBox.style.display = 'block';
                const duration = type === 'success' ? 3000 : 6000;
                setTimeout(hideMessage, duration);
            }

            function hideMessage() {
                messageBox.style.display = 'none';
            }

            // --- PARSING FUNCTION FOR PROACTIVE MONITORING INTERNAL PORTAL (TAB-SEPARATED DATA) ---
            function parseNewRawData(rawText) {
                console.log("Starting Proactive Monitoring Internal Portal data parsing...");
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) {
                    showMessage("Textarea is empty. Paste raw data first.", "warning");
                    return null;
                }

                const lines = rawText.replace(/^\[|\]$/g, '').split(/\r\n|\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0);

                if (lines.length < 2) {
                    showMessage("No data rows found after headers (Proactive Monitoring). Paste raw data including headers.", "warning");
                    return null;
                }

                const headers = lines[0].split('\t').map(h => h.trim());
                console.log("Detected headers (Proactive Monitoring):", headers);

                const headerMap = {
                    'Level': -1,
                    'Metric': -1,
                    'Triggered Date/Time': -1,
                    'Duration': -1
                };

                headers.forEach((header, index) => {
                    const key = Object.keys(headerMap).find(k => k.toLowerCase() === header.toLowerCase());
                    if (key) {
                        headerMap[key] = index;
                    }
                });

                const requiredHeaders = ['Level', 'Metric', 'Triggered Date/Time', 'Duration'];
                const missingHeaders = requiredHeaders.filter(h => headerMap[h] === -1);

                if (missingHeaders.length > 0) {
                    showMessage(`Missing required headers for Proactive Monitoring: ${missingHeaders.join(', ')}. Check pasted text format.`, "error");
                    console.error("Missing headers (Proactive Monitoring):", missingHeaders);
                    return null;
                }

                const maxHeaderIndex = Math.max(...Object.values(headerMap));

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split('\t').map(value => value.trim());

                    if (values.length < maxHeaderIndex + 1) {
                        console.warn(`Skipping line ${i + 1} (Proactive Monitoring): Incorrect number of columns. Expected at least ${maxHeaderIndex + 1}, found ${values.length}.`, lines[i]);
                        continue;
                    }

                    const level = values[headerMap['Level']];
                    const metric = values[headerMap['Metric']];
                    const triggeredDateTimeStr = values[headerMap['Triggered Date/Time']];
                    const durationStr = values[headerMap['Duration']];

                    const startDate = parseTriggeredDateTime(triggeredDateTimeStr);
                    const durationMillis = parseDurationString(durationStr);

                    if (!isNaN(startDate.getTime()) && durationMillis > 0 && metric && metric.length > 0 && level && level.length > 0) {
                        const endDate = new Date(startDate.getTime() + durationMillis);
                        parsedAlerts.push({
                            alertName: metric,
                            startDate: startDate,
                            endDate: endDate,
                            status: level
                        });
                    } else {
                        console.warn(`Skipping line ${i + 1} (Proactive Monitoring): Invalid date (${triggeredDateTimeStr}), invalid/zero duration (${durationStr}), or missing metric/level.`, lines[i]);
                    }
                }

                console.log('Finished Parsing Proactive Monitoring Data. Valid alerts for processing:', parsedAlerts.length);
                if (parsedAlerts.length === 0 && lines.length > 1) {
                     showMessage("No valid alerts found in the Proactive Monitoring data.", "warning");
                }
                // Return array of parsed alerts (could be empty if lines.length <=1 or all invalid, or null if input error)
                return (lines.length <=1 && parsedAlerts.length === 0) ? null : parsedAlerts;
            }

            // --- PARSING FUNCTION FOR GADGET-UI PORTAL ---
            function parseGadgetUIData(rawText) {
                console.log("Starting Gadget-UI Portal data parsing...");
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) {
                    showMessage("Textarea is empty for Gadget-UI. Paste raw data first.", "warning");
                    return null;
                }

                const lines = rawText.split(/\r\n|\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0);

                if (lines.length < 2) { // Header + at least one data line
                    showMessage("No data rows found after headers (Gadget-UI). Paste raw data including headers.", "warning");
                    return null;
                }

                // 1. Pulizia Intestazione
                const rawHeaders = lines[0].split('\t');
                const cleanedHeaders = rawHeaders.map(h =>
                    h.replace(/sort this column/gi, '')
                     .replace(/\(https:\/\/.*?\)/g, '')
                     .replace(/\s\s+/g, ' ')
                     .trim()
                );
                console.log("Cleaned Gadget-UI Headers:", cleanedHeaders);

                const headerMap = {
                    'Alert Name': cleanedHeaders.indexOf('Alert Name'),
                    'Start Time(UTC)': cleanedHeaders.indexOf('Start Time(UTC)'),
                    'End Time(UTC)': cleanedHeaders.indexOf('End Time(UTC)'),
                    'Status': cleanedHeaders.indexOf('Status'),
                    'Alert Age (hrs)': cleanedHeaders.indexOf('Alert Age (hrs)')
                };

                const requiredGadgetHeaders = ['Alert Name', 'Start Time(UTC)', /* 'End Time(UTC)' is optional if Alert Age is present */ 'Status'];
                const missingHeaders = requiredGadgetHeaders.filter(h => headerMap[h] === -1);

                if (missingHeaders.length > 0) {
                    showMessage(`Gadget-UI: Missing required headers after cleaning: ${missingHeaders.join(', ')}. Check format.`, "error");
                    console.error("Gadget-UI Missing headers from map:", missingHeaders, "Original:", rawHeaders, "Cleaned:", cleanedHeaders);
                    return null;
                }
                 // End Time and Alert Age are somewhat co-dependent for calculating duration if one is missing
                if (headerMap['End Time(UTC)'] === -1 && headerMap['Alert Age (hrs)'] === -1) {
                    showMessage(`Gadget-UI: Missing both 'End Time(UTC)' and 'Alert Age (hrs)'. Cannot determine duration.`, "error");
                    return null;
                }


                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split('\t').map(value => value.trim());
                    const maxNeededIndex = Math.max(...Object.values(headerMap).filter(idx => idx !== -1)); // Get max index of *found* headers

                    if (values.length <= maxNeededIndex) {
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Insufficient columns. Expected at least ${maxNeededIndex + 1}, found ${values.length}. Line: "${lines[i]}"`);
                        continue;
                    }

                    let alertNameRaw = values[headerMap['Alert Name']];
                    let alertName = alertNameRaw.replace(/\(https:\/\/.*?\)/g, '').trim();
                    alertName = alertName.replace(/\s*-\s*ProM$/i, '').trim();
                    if (!alertName) {
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Alert Name is empty after cleaning. Raw: "${alertNameRaw}"`);
                        continue;
                    }
                    
                    const startTimeStr = values[headerMap['Start Time(UTC)']];
                    const startDateParts = startTimeStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2}):(\d{2})/);
                    let startDate = new Date(NaN);
                    if (startDateParts) {
                        startDate = new Date(Date.UTC(
                            parseInt(startDateParts[3]), parseInt(startDateParts[1]) - 1, parseInt(startDateParts[2]),
                            parseInt(startDateParts[4]), parseInt(startDateParts[5]), parseInt(startDateParts[6])
                        ));
                    } else {
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Could not parse Start Time(UTC): "${startTimeStr}"`);
                        continue;
                    }
                    if (isNaN(startDate.getTime())) {
                         console.warn(`Gadget-UI: Skipping line ${i + 1}: Invalid Start Date after parsing: "${startTimeStr}"`);
                         continue;
                    }

                    let endTimeStr = headerMap['End Time(UTC)'] !== -1 ? values[headerMap['End Time(UTC)']] : '';
                    let endDate = new Date(NaN);
                    if (endTimeStr) {
                        const endDateParts = endTimeStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2}):(\d{2})/);
                        if (endDateParts) {
                            endDate = new Date(Date.UTC(
                                parseInt(endDateParts[3]), parseInt(endDateParts[1]) - 1, parseInt(endDateParts[2]),
                                parseInt(endDateParts[4]), parseInt(endDateParts[5]), parseInt(endDateParts[6])
                            ));
                        } else if (endTimeStr) { // Non-empty but didn't match
                             console.warn(`Gadget-UI: Could not parse End Time(UTC) on line ${i + 1}: "${endTimeStr}".`);
                        }
                    }
                     if (endTimeStr && isNaN(endDate.getTime())) { // If there was an end time string but it was invalid
                         console.warn(`Gadget-UI: Invalid End Date after parsing on line ${i + 1}: "${endTimeStr}"`);
                         // We might still proceed if Alert Age is available
                    }

                    let durationMillis = 0;
                    const alertAgeHrsStr = headerMap['Alert Age (hrs)'] !== -1 ? values[headerMap['Alert Age (hrs)']] : '';
                    if (alertAgeHrsStr) {
                        const alertAgeHrs = parseFloat(alertAgeHrsStr);
                        if (!isNaN(alertAgeHrs) && alertAgeHrs > 0) {
                            durationMillis = alertAgeHrs * 60 * 60 * 1000;
                        }
                    }
                    
                    if (durationMillis <= 0 && !isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && endDate.getTime() > startDate.getTime()) {
                        durationMillis = endDate.getTime() - startDate.getTime();
                    }

                    const status = values[headerMap['Status']];
                    if (!status) {
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Status is empty.`);
                        continue;
                    }

                    // If endDate is still invalid but we got a duration (likely from Alert Age), and status is Cleared, reconstruct endDate
                    if (isNaN(endDate.getTime()) && durationMillis > 0) {
                        endDate = new Date(startDate.getTime() + durationMillis);
                        console.log(`Gadget-UI: Reconstructed endDate for line ${i+1} using startDate and duration (${alertAgeHrsStr} hrs). Status: ${status}`);
                    }

                    // Final check for duration and valid date range
                    if (durationMillis <= 0) {
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Final duration is zero or negative. Start: "${startTimeStr}", End: "${endTimeStr}", Age: "${alertAgeHrsStr}"`);
                        continue;
                    }
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || endDate.getTime() <= startDate.getTime()) { // endDate must be strictly after startDate for positive duration
                        console.warn(`Gadget-UI: Skipping line ${i + 1}: Invalid date range or non-positive duration. Start: ${startDate.toISOString()}, End: ${endDate.toISOString()}, Duration Millis: ${durationMillis}`);
                        continue;
                    }

                    parsedAlerts.push({
                        alertName: alertName,
                        startDate: startDate,
                        endDate: endDate,
                        status: status
                    });
                }

                console.log('Finished Parsing Gadget-UI Data. Valid alerts for processing:', parsedAlerts.length);
                if (parsedAlerts.length === 0 && lines.length > 1) {
                     showMessage("No valid alerts found in the Gadget-UI data after parsing.", "warning");
                }
                return (lines.length <=1 && parsedAlerts.length === 0) ? null : parsedAlerts;
            }


            function parseDurationString(durationStr) {
                if (!durationStr) return 0;
                durationStr = durationStr.trim().toLowerCase();
                const value = parseInt(durationStr, 10);
                if (isNaN(value)) {
                    console.warn("Could not parse duration value:", durationStr);
                    return 0;
                }
                if (durationStr.endsWith('m')) return value * 60 * 1000;
                else if (durationStr.endsWith('h')) return value * 60 * 60 * 1000;
                else if (durationStr.endsWith('s')) return value * 1000;
                else if (durationStr.endsWith('d')) return value * 24 * 60 * 60 * 1000;
                console.warn("Unknown or missing duration unit for string:", durationStr); // Log the problematic string
                return 0;
            }

            function parseTriggeredDateTime(dateTimeStr) { // Used by Proactive Monitoring
                if (!dateTimeStr) return new Date(NaN);
                // Example: "Apr 30, 2025, 04:09 (CEST)"
                const cleanDateTimeStr = dateTimeStr.replace(/\s*\(.*\)$/, '').replace(',', ''); // Remove (CEST) and first comma
                const date = new Date(cleanDateTimeStr); // "Apr 30 2025 04:09"
                if (isNaN(date.getTime())) {
                    console.warn("Failed to parse date string (Proactive Monitoring format):", dateTimeStr, "-> Cleaned:", cleanDateTimeStr);
                }
                return date;
            }

            function visualizeData() {
                hideMessage();
                if (alertCountChartInstance) { alertCountChartInstance.destroy(); alertCountChartInstance = null; }
                if (totalDurationChartInstance) { totalDurationChartInstance.destroy(); totalDurationChartInstance = null; }
                totalAlertCountWidget.textContent = '0';
                levelBreakdownWidget.innerHTML = '';
                topMetricsListWidget.innerHTML = '';
                alertCountChartTitleElement.textContent = 'Timeline of ProM alerts';

                const rawText = alertDataTextarea.value.trim();
                if (!rawText) {
                    showMessage("Textarea is empty. Paste raw data first.", "warning");
                    return;
                }

                const selectedSourceType = document.querySelector('input[name="dataSourceType"]:checked').value;
                let alerts = null;
                console.log("Selected source type:", selectedSourceType);

                if (selectedSourceType === 'proactiveMonitoring') {
                    alerts = parseNewRawData(rawText);
                } else if (selectedSourceType === 'gadgetUI') {
                    alerts = parseGadgetUIData(rawText);
                } else {
                    showMessage("Invalid data source type selected.", "error");
                    return;
                }

                if (alerts === null) { // Indicates an early exit from parser (e.g. no input, headers only for ProM)
                    renderSummaryWidgets({ totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {} });
                    renderAlertCountChart({ labels: [], datasets: [] });
                    renderTotalDurationChart({ labels: [], groupedDataByLevel: {}, alertLevelsList: [] });
                    return;
                }
                console.log('Parsed Alerts from selected source:', alerts.length);

                if (alerts.length === 0) { // Parser ran, but no valid alert objects were created
                    // Message might have been shown by parser already
                    if (!messageBox.textContent.includes("No valid alerts found")) { // Avoid duplicate messages
                         showMessage('No valid alert items were created after parsing.', 'warning');
                    }
                    renderSummaryWidgets({ totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {} });
                    renderAlertCountChart({ labels: [], datasets: [] });
                    renderTotalDurationChart({ labels: [], groupedDataByLevel: {}, alertLevelsList: [] });
                    return;
                }

                const currentProcessedData = processAlertDataForDurationAndCount(alerts); // Renamed from currentProcessedData

                if (currentProcessedData) {
                    renderSummaryWidgets(currentProcessedData);
                    if (alertCountChartTitleElement) {
                        alertCountChartTitleElement.textContent = `Timeline of ProM alerts (${currentProcessedData.totalAlertCountOverall || 0}) for the selected period`;
                    }
                    alertCountChartInstance = renderAlertCountChart(currentProcessedData);
                    totalDurationChartInstance = renderTotalDurationChart(currentProcessedData);

                    if (currentProcessedData.totalAlertCountOverall > 0) {
                        showMessage('Data visualized successfully!', 'success');
                    } else if (alerts.length > 0 && currentProcessedData.totalAlertCountOverall === 0) {
                        showMessage('Data parsed, but no items could be processed for charts. Check console for details.', 'warning');
                    } else {
                        showMessage('No data to display in charts. Check input or console.', 'warning');
                    }
                } else {
                    showMessage('Error processing alert data for visualization. Check console.');
                }
            }

            function processAlertDataForDurationAndCount(alerts) {
                console.log('Processing Alerts for Duration & Count (Weekly & Overall):', alerts.length);
                if (!alerts || alerts.length === 0) {
                    return { // Return a default empty structure
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: [], alertLevelsList: [],
                        totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {}
                    };
                }

                const processedItems = [];
                const uniqueMetrics = new Set();
                const uniqueLevels = new Set();
                const overallCountsByLevel = {};
                const overallCountsByMetric = {};
                let totalCount = 0;

                alerts.forEach(alert => {
                    if (alert.startDate instanceof Date && !isNaN(alert.startDate.getTime()) &&
                        alert.endDate instanceof Date && !isNaN(alert.endDate.getTime()) &&
                        alert.endDate.getTime() > alert.startDate.getTime() && // Duration must be positive
                        alert.alertName && alert.alertName.length > 0 &&
                        alert.status && alert.status.length > 0) {
                        const durationMillis = alert.endDate.getTime() - alert.startDate.getTime();
                        const durationHours = durationMillis / (1000 * 60 * 60);

                        // durationHours will be positive due to endDate > startDate check
                        processedItems.push({
                            startDate: alert.startDate,
                            alertName: alert.alertName,
                            durationHours: durationHours,
                            status: alert.status
                        });
                        totalCount++;
                        overallCountsByLevel[alert.status] = (overallCountsByLevel[alert.status] || 0) + 1;
                        overallCountsByMetric[alert.alertName] = (overallCountsByMetric[alert.alertName] || 0) + 1;
                        uniqueMetrics.add(alert.alertName);
                        uniqueLevels.add(alert.status);
                    } else {
                        console.warn("Skipping alert in processing: Invalid dates, zero/negative duration, or missing fields.", alert);
                    }
                });

                console.log("Overall Counts by Level:", overallCountsByLevel);
                console.log("Overall Counts by Metric:", overallCountsByMetric);
                console.log("Total Valid Alerts for Processing (totalCount):", totalCount);

                if (totalCount === 0) {
                     return {
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: [], alertLevelsList: [],
                        totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {}
                    };
                }

                const alertMetricsList = [...uniqueMetrics];
                const alertLevelsList = [...uniqueLevels];
                const startDates = processedItems.map(d => d.startDate);
                const weekStarts = getWeekStarts(startDates);

                if (weekStarts.length === 0 && processedItems.length > 0) {
                    console.log('No weekly start dates generated, returning overall counts.');
                     return {
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: alertMetricsList, alertLevelsList: alertLevelsList,
                        totalAlertCountOverall: totalCount, countByLevelOverall: overallCountsByLevel, countByMetricOverall: overallCountsByMetric
                    };
                }
                const labels = weekStarts.map(formatDateRange);

                const groupedData = {}; // { weekLabel: { metricLabel: { totalDuration: X, count: Y } } }
                labels.forEach(label => {
                    groupedData[label] = {};
                    alertMetricsList.forEach(metric => {
                        groupedData[label][metric] = { totalDuration: 0, count: 0 };
                    });
                });

                const groupedDataByLevel = {}; // { weekLabel: { level: { totalDuration: X, count: Y } } }
                labels.forEach(label => {
                    groupedDataByLevel[label] = {};
                    alertLevelsList.forEach(level => {
                        groupedDataByLevel[label][level] = { totalDuration: 0, count: 0 };
                    });
                });

                processedItems.forEach(item => {
                    const { startDate, alertName, durationHours, status } = item;
                    for (let i = 0; i < weekStarts.length; i++) {
                        const weekStartObj = new Date(weekStarts[i] + 'T00:00:00Z');
                        const weekEndObj = new Date(weekStartObj);
                        weekEndObj.setUTCDate(weekEndObj.getUTCDate() + 6);
                        weekEndObj.setUTCHours(23, 59, 59, 999);

                        if (startDate.getTime() >= weekStartObj.getTime() && startDate.getTime() <= weekEndObj.getTime()) {
                            if (groupedData[labels[i]] && groupedData[labels[i]].hasOwnProperty(alertName)) {
                                groupedData[labels[i]][alertName].totalDuration += durationHours;
                                groupedData[labels[i]][alertName].count++;
                            }
                            if (groupedDataByLevel[labels[i]] && groupedDataByLevel[labels[i]].hasOwnProperty(status)) {
                                groupedDataByLevel[labels[i]][status].totalDuration += durationHours;
                                groupedDataByLevel[labels[i]][status].count++;
                            }
                            break;
                        }
                    }
                });

                const colorsMetrics = generateDistinctColors(alertMetricsList.length);
                const datasetsForFirstChart = alertMetricsList.map((metric, index) => ({
                    label: metric,
                    data: labels.map(label => {
                        const dataPoint = groupedData[label] && groupedData[label][metric] ? groupedData[label][metric].count : 0;
                        return (dataPoint && !isNaN(dataPoint)) ? dataPoint : 0;
                    }),
                    backgroundColor: colorsMetrics[index % colorsMetrics.length]
                }));

                return {
                    labels: labels, datasets: datasetsForFirstChart,
                    groupedData: groupedData, groupedDataByLevel: groupedDataByLevel,
                    alertMetricsList: alertMetricsList, alertLevelsList: alertLevelsList,
                    totalAlertCountOverall: totalCount, countByLevelOverall: overallCountsByLevel, countByMetricOverall: overallCountsByMetric
                };
            }

            function renderSummaryWidgets(summaryData) {
                totalAlertCountWidget.textContent = summaryData.totalAlertCountOverall || 0;
                levelBreakdownWidget.innerHTML = '';
                const countsByLevel = summaryData.countByLevelOverall || {};
                const totalAlertsForBreakdown = summaryData.totalAlertCountOverall || 0;
                const levels = Object.keys(countsByLevel).sort((a, b) => countsByLevel[b] - countsByLevel[a]);

                if (levels.length === 0 && totalAlertsForBreakdown > 0) {
                    const li = document.createElement('li');
                    li.textContent = "No level breakdown available.";
                    levelBreakdownWidget.appendChild(li);
                } else if (levels.length === 0) { /* No data, do nothing or show "No data" */ }
                else {
                    levels.forEach(level => {
                        const count = countsByLevel[level];
                        const percentage = totalAlertsForBreakdown > 0 ? (count / totalAlertsForBreakdown) * 100 : 0;
                        const listItem = document.createElement('li');
                        const levelClass = level.toLowerCase().trim().replace(/\s+/g, '-'); // Make CSS class friendly
                        let barClass = 'other';
                        if (['warning', 'critical', 'exhausted', 'info', 'cleared'].includes(levelClass)) {
                            barClass = levelClass;
                        }
                        listItem.innerHTML = `
                            <span class="level-name">${level}</span>
                            <div class="level-bar">
                                <div class="level-bar-inner ${barClass}" style="width: ${percentage.toFixed(1)}%;"></div>
                            </div>
                            <span class="level-count">${count}</span>`;
                        levelBreakdownWidget.appendChild(listItem);
                    });
                }

                topMetricsListWidget.innerHTML = '';
                const countsByMetric = summaryData.countByMetricOverall || {};
                const sortedMetrics = Object.keys(countsByMetric)
                    .map(metric => ({ name: metric, count: countsByMetric[metric] }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);

                if (sortedMetrics.length === 0 && totalAlertsForBreakdown > 0) {
                     const li = document.createElement('li');
                     li.textContent = "No metric data to display.";
                     topMetricsListWidget.appendChild(li);
                } else if (sortedMetrics.length === 0) { /* No data, do nothing or show "No data" */ }
                else {
                    sortedMetrics.forEach(metric => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `
                            <span class="metric-name">${metric.name}</span>
                            <span class="metric-count">${metric.count}</span>`;
                        topMetricsListWidget.appendChild(listItem);
                    });
                }
            }

            function getWeekStarts(dates) {
                if (!dates || dates.length === 0) return [];
                const validDates = dates.filter(d => d instanceof Date && !isNaN(d.getTime()));
                if (validDates.length === 0) { console.warn("getWeekStarts: No valid dates provided."); return []; }

                const sortedDates = validDates.sort((a, b) => a.getTime() - b.getTime());
                const minDate = sortedDates[0];
                const maxDate = sortedDates[sortedDates.length - 1];
                
                let currentMonday = getMonday(minDate);
                if (isNaN(currentMonday.getTime())) { console.error("getMonday returned invalid date from minDate."); return []; }

                const weekStarts = [];
                const mondayOfMaxDateWeek = getMonday(maxDate);
                if (isNaN(mondayOfMaxDateWeek.getTime())) { console.error("getMonday returned invalid date from maxDate."); return weekStarts; }

                while (currentMonday.getTime() <= mondayOfMaxDateWeek.getTime()) {
                    weekStarts.push(currentMonday.toISOString().slice(0, 10));
                    currentMonday.setUTCDate(currentMonday.getUTCDate() + 7);
                }
                return weekStarts;
            }

            function getMonday(date) { // Assumes date is a valid Date object
                const d = new Date(date.getTime());
                const day = d.getUTCDay();
                const diff = d.getUTCDate() - day + (day === 0 ? -6 : 1);
                d.setUTCDate(diff);
                d.setUTCHours(0, 0, 0, 0);
                return d;
            }

            function formatDateRange(startDateStr) {
                if (!startDateStr) return '';
                try {
                    const start = new Date(startDateStr + 'T00:00:00Z');
                    const end = new Date(start);
                    end.setUTCDate(end.getUTCDate() + 6);
                    const startDay = String(start.getUTCDate()).padStart(2, '0');
                    const startMonth = String(start.getUTCMonth() + 1).padStart(2, '0');
                    const endDay = String(end.getUTCDate()).padStart(2, '0');
                    const endMonth = String(end.getUTCMonth() + 1).padStart(2, '0');
                    return `${startDay}/${startMonth} - ${endDay}/${endMonth}`;
                } catch (e) { console.error("Error formatting date range:", startDateStr, e); return 'Invalid Date'; }
            }

            function generateDistinctColors(count) {
                if (count <= 0) return ['rgba(54, 162, 235, 0.8)'];
                const colors = []; const saturation = 0.7; const lightness = 0.6;
                for (let i = 0; i < count; i++) {
                    const hue = (i * (360 / count) + 40) % 360;
                    colors.push(`hsla(${hue}, ${saturation * 100}%, ${lightness * 100}%, 0.8)`);
                }
                return colors;
            }

            function getLevelColor(level) {
                const lowerLevel = level.toLowerCase().trim().replace(/\s+/g, '-');
                switch (lowerLevel) {
                    case 'warning': return 'rgba(252, 211, 77, 0.8)';
                    case 'critical': return 'rgba(239, 68, 68, 0.8)';
                    case 'exhausted': return 'rgba(167, 139, 250, 0.8)';
                    case 'info': return 'rgba(56, 178, 172, 0.8)';
                    case 'cleared': return 'rgba(52, 211, 153, 0.8)'; // Tailwind green-400
                    default: return 'rgba(107, 114, 128, 0.8)';
                }
            }

            function renderAlertCountChart(processedData) {
                const { labels, datasets } = processedData || { labels: [], datasets: [] };
                const ctx = document.getElementById('alertCountChart').getContext('2d');
                if (alertCountChartInstance) { alertCountChartInstance.destroy(); alertCountChartInstance = null; }

                if (labels.length === 0) { console.log("No labels for alert count chart."); return null; }
                const hasPositiveData = datasets && datasets.some(ds => ds.data.some(value => value > 0));
                if (!hasPositiveData) { console.warn("Alert count chart: No positive data. Rendering empty structure.");}

                try {
                    alertCountChartInstance = new Chart(ctx, {
                        type: 'bar', data: { labels, datasets },
                        options: {
                            responsive: true, maintainAspectRatio: true,
                            scales: {
                                x: { stacked: true, title: { display: true, text: 'Week Alert Started (Monday - Sunday)' } },
                                y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Number of Alerts' }, ticks: { precision: 0, callback: function(value) { if (Number.isInteger(value)) { return value; } } } }
                            },
                            plugins: {
                                legend: { position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle' } },
                                tooltip: { mode: 'index', intersect: false, callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) { label += context.parsed.y + ` alert${context.parsed.y === 1 ? '' : 's'}`; }
                                        return label;
                                    }}},
                                datalabels: {
                                    display: (context) => context.dataset.data[context.dataIndex] > 0,
                                    color: 'white', anchor: 'center', align: 'center', font: { weight: 'bold', size: 10 },
                                    formatter: (value) => value, textStrokeColor: 'black', textStrokeWidth: 1
                                }
                            }
                        }
                    });
                    return alertCountChartInstance;
                } catch (error) { console.error('Error rendering alert count chart:', error); showMessage('Error rendering alert count chart. Check console.'); return null; }
            }

            function renderTotalDurationChart(processedData) {
                const { labels, groupedDataByLevel, alertLevelsList } = processedData || { labels: [], groupedDataByLevel: {}, alertLevelsList: [] };
                const ctx = document.getElementById('totalDurationChart').getContext('2d');
                if (totalDurationChartInstance) { totalDurationChartInstance.destroy(); totalDurationChartInstance = null; }

                if (labels.length === 0) { console.log("No labels for total duration chart."); return null; }

                const currentAlertLevels = alertLevelsList || [];
                const sortedLevels = ['Critical', 'Warning', 'Exhausted', 'Info', 'Cleared'] // Add Cleared to preferred order
                                     .filter(level => currentAlertLevels.includes(level));
                currentAlertLevels.forEach(level => { if (!sortedLevels.includes(level)) sortedLevels.push(level); });

                const datasetsForSecondChart = sortedLevels.map(level => ({
                    label: level,
                    data: labels.map(label => {
                        const dataPoint = groupedDataByLevel && groupedDataByLevel[label] && groupedDataByLevel[label][level] ? groupedDataByLevel[label][level].totalDuration : 0;
                        return (dataPoint && !isNaN(dataPoint)) ? dataPoint : 0;
                    }),
                    backgroundColor: getLevelColor(level),
                    borderColor: getLevelColor(level).replace(', 0.8)', ', 1)'), borderWidth: 1
                }));

                const hasPositiveData = datasetsForSecondChart.some(ds => ds.data.some(value => value > 0));
                if (!hasPositiveData) { console.warn("Total duration chart: No positive data. Rendering empty structure.");}

                const weeklyTotals = labels.map(label => {
                    let total = 0;
                    if (groupedDataByLevel && groupedDataByLevel[label]) {
                        sortedLevels.forEach(level => { total += (groupedDataByLevel[label][level]?.totalDuration || 0); });
                    } return total;
                });
                const maxValue = Math.max(0, ...weeklyTotals); const yAxisMax = maxValue > 0 ? maxValue * 1.15 : 1;

                try {
                    totalDurationChartInstance = new Chart(ctx, {
                        type: 'bar', data: { labels: labels, datasets: datasetsForSecondChart },
                        options: {
                            responsive: true, maintainAspectRatio: true,
                            scales: {
                                x: { stacked: true, title: { display: true, text: 'Week Alert Started (Monday - Sunday)' } },
                                y: { stacked: true, beginAtZero: true, max: yAxisMax, title: { display: true, text: 'Sum of Durations (hours)' }, ticks: { precision: 1 } }
                            },
                            plugins: {
                                legend: { display: true, position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle' } },
                                tooltip: { mode: 'index', intersect: false, callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) { label += context.parsed.y.toFixed(1) + ' hours'; }
                                        return label;
                                    },
                                    footer: function (tooltipItems) {
                                        let total = 0; tooltipItems.forEach(item => { total += item.parsed.y; });
                                        return 'Total: ' + total.toFixed(1) + ' hours';
                                    }}},
                                datalabels: {
                                    display: (context) => context.dataset.data[context.dataIndex] > 0.1,
                                    anchor: 'center', align: 'center', color: 'white', font: { weight: 'bold', size: 10 },
                                    formatter: (value) => (value < 0.1) ? '' : value.toFixed(1), // Hide if < 0.1
                                    textStrokeColor: 'black', textStrokeWidth: 1,
                                }
                            }
                        }
                    });
                    return totalDurationChartInstance;
                } catch (error) { console.error('Error rendering total duration chart:', error); showMessage('Error rendering total duration chart. Check console.'); return null; }
            }
        });
    </script>
</body>
</html>
