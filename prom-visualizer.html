<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProM Alert Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f6; /* Light gray background */
            color: #333; /* Dark gray text */
            line-height: 1.6;
            padding: 1rem; /* Add some padding */
        }
        .container {
            max-width: 1200px; /* Keep a wider container for the visualizer content */
            margin: 2rem auto; /* Center the container with more vertical margin */
            background-color: #ffffff; /* White background */
            border-radius: 0.75rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); /* Stronger shadow */
            padding: 2rem; /* Increase padding */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        h1, h2, h3 {
            color: #1a202c; /* Darker heading color */
            margin-bottom: 1rem; /* Space below headings */
            font-weight: 700; /* Bold headings */
        }
        h1 {
            text-align: center; /* Center the main title */
            margin-bottom: 2rem; /* More space below the main title */
        }
        h2, h3 {
            margin-top: 0; /* Remove default top margin */
        }

        /* NEW Styles for Source Selector */
        .source-selector-container {
            margin-bottom: 1.5rem; /* Space below the selector */
            padding: 1rem;
            background-color: #f9fafb; /* Slightly different background */
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .source-selector-container h3 {
            font-size: 1.125rem; /* Equivalent to text-lg */
            font-weight: 600; /* Equivalent to font-semibold */
            margin-bottom: 0.75rem; /* Equivalent to mb-3 */
            color: #374151; /* Equivalent to text-gray-700 */
        }
        .source-selector-options div {
            margin-bottom: 0.5rem;
        }
        .source-selector-options label {
            color: #4b5563; /* Equivalent to text-gray-600 */
            cursor: pointer;
            margin-left: 0.25rem; /* Equivalent to ml-1 */
        }
         .source-selector-options input[type="radio"] {
            accent-color: #4f46e5; /* Indigo to match buttons */
         }


        textarea {
            width: 100%; /* Make textarea take full width */
            margin-bottom: 1.5rem; /* Increased margin */
            padding: 0.75rem; /* Increased padding */
            border-radius: 0.375rem; /* Rounded corners */
            border: 1px solid #d1d5db; /* Lighter border */
            min-height: 200px; /* Keep a good minimum height */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Use system monospace stack */
            font-size: 0.95em; /* Slightly larger font size */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* Style for buttons container */
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem; /* Increased gap between buttons */
            flex-wrap: wrap;
            margin-top: 2rem; /* More space above buttons */
            margin-bottom: 2rem; /* More space below buttons */
        }

        button {
            background-color: #4f46e5; /* Indigo primary button color */
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem; /* Increased padding */
            border-radius: 0.375rem; /* Rounded corners */
            cursor: pointer;
            font-size: 1rem; /* Standard font size */
            font-weight: 600; /* Semi-bold text */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        button:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-2px); /* Slight lift on hover */
        }

        /* Styles for Summary Widgets */
        .summary-widgets-container {
            display: flex;
            gap: 2rem; /* Increased space between cards */
            margin-bottom: 2rem; /* Increased space below the widgets */
            flex-wrap: wrap;
            justify-content: center; /* Center widgets if they wrap */
        }

        .widget-card {
            flex: 1;
            min-width: 300px; /* Minimum width before wrapping */
            max-width: 500px; /* Max width */
            background-color: #ffffff; /* White background */
            border: 1px solid #e5e7eb; /* Lighter border */
            border-radius: 0.5rem; /* Rounded corners */
            padding: 1.5rem; /* Increased padding */
            text-align: left;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            display: flex;
            flex-direction: column;
        }

        .widget-card h3 {
            margin-top: 0;
            margin-bottom: 1rem; /* Increased space below title */
            color: #1f2937; /* Darker title color */
            font-size: 1.25em; /* Slightly larger title */
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e5e7eb; /* Separator below title */
            padding-bottom: 0.75rem; /* Space between title and separator */
        }

        .widget-card .info-icon {
            font-size: 0.8em;
            margin-left: 0.5rem; /* Increased space */
            color: #6b7280; /* Gray color */
            cursor: help;
        }

        .widget-card .total-count {
            font-size: 3.5em; /* Larger number style */
            font-weight: 700; /* Bold */
            color: #4f46e5; /* Indigo color */
            margin-bottom: 1.5rem; /* Increased space */
            text-align: center; /* Center the total count */
        }

        .level-breakdown,
        .top-metrics-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* Allow lists to take available space */
        }

        .level-breakdown li,
        .top-metrics-list li {
            margin-bottom: 0.75rem; /* Increased space between list items */
            font-size: 0.95em;
            color: #4b5563; /* Darker gray */
        }

        .level-breakdown li {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .level-breakdown .level-name {
            flex-basis: 90px; /* Slightly wider fixed width */
            flex-shrink: 0;
            margin-right: 1rem; /* Increased space */
            font-weight: 600; /* Semi-bold */
            color: #1f2937; /* Darker color for name */
        }

        .level-breakdown .level-bar {
            flex-grow: 1;
            height: 12px; /* Thicker bar */
            background-color: #e5e7eb; /* Light gray background for the bar track */
            border-radius: 6px; /* More rounded corners */
            overflow: hidden;
            margin-right: 1rem; /* Increased space */
        }

        .level-breakdown .level-bar-inner {
            height: 100%;
            /* Width will be set by JS */
            transition: width 0.5s ease-in-out; /* Smooth transition for bar width */
        }

        /* Specific colors for levels (using Tailwind color palette where possible) */
        .level-breakdown .level-bar-inner.warning {
            background-color: #fcd34d; /* Tailwind amber-400 */
        }
        .level-breakdown .level-bar-inner.critical {
            background-color: #ef4444; /* Tailwind red-500 */
        }
        .level-breakdown .level-bar-inner.exhausted {
            background-color: #a78bfa; /* Tailwind violet-400 */
        }
        .level-breakdown .level-bar-inner.info {
            background-color: #38b2ac; /* Tailwind teal-500 */
        }
        .level-breakdown .level-bar-inner.other {
            background-color: #6b7280; /* Tailwind gray-500 for unknown */
        }

        .level-breakdown .level-count,
        .top-metrics-list .metric-count {
            font-weight: 600; /* Semi-bold */
            flex-shrink: 0;
            color: #1f2937; /* Darker color for count */
        }

        .top-metrics-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem; /* space before bottom border */
            border-bottom: 1px dashed #d1d5db; /* subtle separator */
        }
        .top-metrics-list li:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .top-metrics-list .metric-name {
            flex-grow: 1;
            margin-right: 0.75rem; /* space between name and count */
            color: #374151; /* Darker color */
            word-break: break-word; /* Allow long names to wrap */
        }

        .chart-container {
            margin-bottom: 2rem; /* Increased margin */
            padding: 1.5rem; /* Increased padding */
            border: 1px solid #e5e7eb; /* Lighter border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: #ffffff; /* White background */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Match widget shadow */
        }

        canvas {
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
        }

        /* Message box styling */
        .message-box {
            display: none;
            position: fixed;
            top: 1rem; /* Adjusted top position */
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem; /* Increased padding */
            background-color: #fef2f2; /* Tailwind red-50 */
            color: #991b1b; /* Tailwind red-800 */
            border: 1px solid #fca5a5; /* Tailwind red-300 */
            border-radius: 0.375rem; /* Rounded corners */
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 90%; /* Increased max-width */
            text-align: left;
        }
        .message-box.success {
            background-color: #ecfdf5; /* Tailwind green-50 */
            color: #065f46; /* Tailwind green-800 */
            border-color: #a7f3d0; /* Tailwind green-200 */
        }
        .message-box.warning {
            background-color: #fffbeb; /* Tailwind amber-50 */
            color: #92400e; /* Tailwind amber-800 */
            border-color: #fcd34d; /* Tailwind amber-300 */
        }

        /* Footer styling */
        footer {
            text-align: center;
            padding: 1.5rem; /* Increased padding */
            font-size: 0.875rem; /* Smaller text size */
            color: #6b7280; /* Gray text color */
            margin-top: 2rem; /* Space above the footer */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">ProM Alert Visualizer</h1>

        <div class="source-selector-container">
            <h3>Select Data Source Type:</h3>
            <div class="source-selector-options">
                <div>
                    <input type="radio" id="sourceProactiveMonitoring" name="dataSourceType" value="proactiveMonitoring" checked>
                    <label for="sourceProactiveMonitoring">Proactive Monitoring Internal Portal</label>
                </div>
                <div>
                    <input type="radio" id="sourceGadgetUI" name="dataSourceType" value="gadgetUI">
                    <label for="sourceGadgetUI">Gadget-UI Portal</label>
                </div>
            </div>
        </div>

        <textarea id="alertData" rows="15"
            placeholder="Paste RAW data copied from the alert source here..."></textarea>

        <div class="button-group">
            <button id="visualizeButton">Visualize Data</button>
        </div>

        <div class="summary-widgets-container">
            <div class="widget-card">
                <h3>Total ProM Alerts <span class="info-icon" title="Total count of alerts processed with valid dates and duration.">&#x24D8;</span></h3>
                <div class="total-count" id="totalAlertCountWidget">0</div>
                <div class="level-breakdown" id="levelBreakdownWidget">
                </div>
            </div>
            <div class="widget-card">
                <h3>Top Alerts by Volume <span class="info-icon" title="Top 5 Alert Metrics by total count over the period.">&#x24D8;</span></h3>
                <div class="top-metrics-list" id="topMetricsListWidget">
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h3 id="alertCountChartTitle">Timeline of ProM alerts</h3>
            <canvas id="alertCountChart"></canvas>
        </div>

        <div class="chart-container">
            <h3>Total Alert Duration per Week (hours)</h3>
            <canvas id="totalDurationChart"></canvas>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <footer>
        These tools are not official or Salesforce authorized. They have been developed for personal purpose by Saverio Guardato with the aim of improving CSM tasks.
    </footer>

    <script>
        // Register the datalabels plugin globally
        Chart.register(ChartDataLabels);

        document.addEventListener('DOMContentLoaded', function () {
            const visualizeButton = document.getElementById('visualizeButton');
            const alertDataTextarea = document.getElementById('alertData');
            const messageBox = document.getElementById('messageBox');
            const alertCountChartTitleElement = document.getElementById('alertCountChartTitle');

            const totalAlertCountWidget = document.getElementById('totalAlertCountWidget');
            const levelBreakdownWidget = document.getElementById('levelBreakdownWidget');
            const topMetricsListWidget = document.getElementById('topMetricsListWidget');

            let alertCountChartInstance = null;
            let totalDurationChartInstance = null;
            let currentProcessedData = null;

            visualizeButton.addEventListener('click', visualizeData);

            function showMessage(message, type = 'error') {
                messageBox.textContent = message;
                messageBox.className = `message-box ${type}`;
                messageBox.style.display = 'block';
                const duration = type === 'success' ? 3000 : 6000;
                setTimeout(hideMessage, duration);
            }

            function hideMessage() {
                messageBox.style.display = 'none';
            }

            // --- PARSING FUNCTION FOR PROACTIVE MONITORING INTERNAL PORTAL (TAB-SEPARATED DATA) ---
            function parseNewRawData(rawText) {
                console.log("Starting Proactive Monitoring Internal Portal data parsing...");
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) {
                    showMessage("Textarea is empty. Paste raw data first.", "warning");
                    return null;
                }

                const lines = rawText.replace(/^\[|\]$/g, '').split(/\r\n|\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0);

                if (lines.length < 2) { // Needs at least header and one data line to be potentially valid
                    showMessage("No data rows found after headers. Paste raw data including headers.", "warning");
                    return null; // Not enough lines to process
                }

                const headers = lines[0].split('\t').map(h => h.trim());
                console.log("Detected headers (Proactive Monitoring):", headers);

                const headerMap = {
                    'Level': -1,
                    'Metric': -1,
                    'Triggered Date/Time': -1,
                    'Duration': -1
                };

                headers.forEach((header, index) => {
                    const key = Object.keys(headerMap).find(k => k.toLowerCase() === header.toLowerCase());
                    if (key) {
                        headerMap[key] = index;
                    }
                });

                const requiredHeaders = ['Level', 'Metric', 'Triggered Date/Time', 'Duration'];
                const missingHeaders = requiredHeaders.filter(h => headerMap[h] === -1);

                if (missingHeaders.length > 0) {
                    showMessage(`Missing required headers for Proactive Monitoring: ${missingHeaders.join(', ')}. Check pasted text format.`, "error");
                    console.error("Missing headers (Proactive Monitoring):", missingHeaders);
                    return null;
                }

                const maxHeaderIndex = Math.max(...Object.values(headerMap));

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split('\t').map(value => value.trim());

                    if (values.length < maxHeaderIndex + 1) {
                        console.warn(`Skipping line ${i + 1} (Proactive Monitoring): Incorrect number of columns. Expected at least ${maxHeaderIndex + 1}, found ${values.length}.`, lines[i]);
                        continue;
                    }

                    const level = values[headerMap['Level']];
                    const metric = values[headerMap['Metric']];
                    const triggeredDateTimeStr = values[headerMap['Triggered Date/Time']];
                    const durationStr = values[headerMap['Duration']];

                    const startDate = parseTriggeredDateTime(triggeredDateTimeStr);
                    const durationMillis = parseDurationString(durationStr);

                    if (!isNaN(startDate.getTime()) && durationMillis > 0 && metric && metric.length > 0 && level && level.length > 0) {
                        const endDate = new Date(startDate.getTime() + durationMillis);
                        parsedAlerts.push({
                            alertName: metric,
                            startDate: startDate,
                            endDate: endDate,
                            status: level
                        });
                    } else {
                        console.warn(`Skipping line ${i + 1} (Proactive Monitoring): Invalid date (${triggeredDateTimeStr}), invalid/zero duration (${durationStr}), or missing metric/level.`, lines[i]);
                    }
                }

                console.log('Finished Parsing Proactive Monitoring Data. Valid alerts for processing:', parsedAlerts.length);
                if (parsedAlerts.length === 0 && lines.length > 1) { // More than just headers but no valid alerts
                     showMessage("No valid alerts found in the Proactive Monitoring data.", "warning");
                     return []; // Return empty array to signal processing happened but yielded no valid items
                }
                return parsedAlerts; // Return array of parsed alerts (could be empty if lines.length <=1 or all invalid)
            }

            // --- PLACEHOLDER PARSING FUNCTION FOR GADGET-UI PORTAL ---
            function parseGadgetUIData(rawText) {
                console.log("Starting Gadget-UI Portal data parsing...");
                // ================================================================================
                // TODO: IMPLEMENT PARSING LOGIC FOR GADGET-UI PORTAL
                // You will need to:
                // 1. Determine how lines and columns are structured (e.g., CSV, JSON, different tab-separated headers).
                // 2. Map the Gadget-UI column names to 'Level', 'Metric', 'Triggered Date/Time', 'Duration'.
                // 3. Adapt date/time parsing if `parseTriggeredDateTime` is not suitable.
                // 4. Adapt duration parsing if `parseDurationString` is not suitable.
                // 5. Ensure it returns an array of objects like:
                //    { alertName: string, startDate: Date, endDate: Date, status: string }
                //    or null/[] if no valid data.
                //
                // EXAMPLE (VERY HYPOTHETICAL - NEEDS REAL FORMAT):
                /*
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) {
                    showMessage("Textarea is empty for Gadget-UI. Paste raw data first.", "warning");
                    return null;
                }
                // Assuming CSV for example:
                // const lines = rawText.split(/\r\n|\n/).map(l => l.trim()).filter(l => l.length > 0);
                // if (lines.length < 2) {
                //    showMessage("No data rows for Gadget-UI.", "warning");
                //    return null; // Header + data
                // }
                // const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                // const metricIndex = headers.indexOf('gadget_metric_name'); // EXAMPLE
                // const levelIndex = headers.indexOf('gadget_severity');    // EXAMPLE
                // const dateIndex = headers.indexOf('gadget_timestamp');  // EXAMPLE
                // const durationIndex = headers.indexOf('gadget_active_time_seconds'); // EXAMPLE

                // // Check if all required headers are found by checking their index !== -1
                // if ([metricIndex, levelIndex, dateIndex, durationIndex].includes(-1)) {
                //    showMessage("Gadget-UI: Missing one or more required headers. Check console.", "error");
                //    console.error("Gadget-UI Header indices:", {metricIndex, levelIndex, dateIndex, durationIndex});
                //    return null;
                // }


                // for (let i = 1; i < lines.length; i++) {
                //     const values = lines[i].split(',');
                //     // Basic check for column count
                //     if (values.length <= Math.max(metricIndex, levelIndex, dateIndex, durationIndex)) {
                //        console.warn(`Gadget-UI: Skipping line ${i+1} due to insufficient columns.`);
                //        continue;
                //     }

                //     const metric = values[metricIndex];
                //     const level = values[levelIndex];
                //     const dateStr = values[dateIndex]; // Needs specific parsing for Gadget-UI date format
                //     const durationInSeconds = parseInt(values[durationIndex]); // Example: duration is in seconds

                //     // Placeholder for specific date parsing for Gadget-UI
                //     // const startDate = parseGadgetUIDateTime(dateStr);
                //     const startDate = new Date(dateStr); // !!! THIS IS A PLACEHOLDER AND LIKELY WRONG !!!

                //     // Placeholder for specific duration parsing for Gadget-UI (if not in '10m' format)
                //     // const durationMillis = parseGadgetUIDuration(durationStr);
                //     const durationMillis = !isNaN(durationInSeconds) ? durationInSeconds * 1000 : 0; // !!! THIS IS A PLACEHOLDER !!!


                //     if (!isNaN(startDate.getTime()) && durationMillis > 0 && metric && metric.length > 0 && level && level.length > 0) {
                //         parsedAlerts.push({
                //             alertName: metric,
                //             startDate: startDate,
                //             endDate: new Date(startDate.getTime() + durationMillis),
                //             status: level
                //         });
                //     } else {
                //        console.warn(`Gadget-UI: Skipping line ${i + 1}: Invalid data.`, {metric, level, dateStr, durationInSeconds, startDateValid: !isNaN(startDate.getTime()), durationMillis});
                //     }
                // }
                // console.log('Finished Parsing Gadget-UI Data. Valid alerts:', parsedAlerts.length);
                // if (parsedAlerts.length === 0 && lines.length > 1) { // More than just headers but no valid alerts
                //    showMessage("No valid alerts found in the Gadget-UI data.", "warning");
                //    return [];
                // }
                // return parsedAlerts;
                */
                // ================================================================================
                showMessage("Parsing for Gadget-UI Portal is not yet implemented. Please provide data format details.", "warning");
                return null; // Return null until implemented
            }


            function parseDurationString(durationStr) {
                if (!durationStr) return 0;
                durationStr = durationStr.trim().toLowerCase();
                const value = parseInt(durationStr, 10);
                if (isNaN(value)) {
                    console.warn("Could not parse duration value:", durationStr);
                    return 0;
                }
                if (durationStr.endsWith('m')) return value * 60 * 1000;
                else if (durationStr.endsWith('h')) return value * 60 * 60 * 1000;
                else if (durationStr.endsWith('s')) return value * 1000;
                else if (durationStr.endsWith('d')) return value * 24 * 60 * 60 * 1000;
                console.warn("Unknown or missing duration unit:", durationStr);
                return 0;
            }

            function parseTriggeredDateTime(dateTimeStr) {
                if (!dateTimeStr) return new Date(NaN);
                const cleanDateTimeStr = dateTimeStr.replace(/\s*\(.*\)$/, '').replace(',', '');
                const date = new Date(cleanDateTimeStr);
                if (isNaN(date.getTime())) {
                    console.warn("Failed to parse date string:", dateTimeStr, "-> Cleaned:", cleanDateTimeStr);
                }
                return date;
            }

            function visualizeData() {
                hideMessage();
                if (alertCountChartInstance) { alertCountChartInstance.destroy(); alertCountChartInstance = null; }
                if (totalDurationChartInstance) { totalDurationChartInstance.destroy(); totalDurationChartInstance = null; }
                totalAlertCountWidget.textContent = '0';
                levelBreakdownWidget.innerHTML = '';
                topMetricsListWidget.innerHTML = '';
                 alertCountChartTitleElement.textContent = 'Timeline of ProM alerts';


                const rawText = alertDataTextarea.value.trim();
                if (!rawText) {
                    showMessage("Textarea is empty. Paste raw data first.", "warning");
                    return;
                }

                const selectedSourceType = document.querySelector('input[name="dataSourceType"]:checked').value;
                let alerts = null;

                console.log("Selected source type:", selectedSourceType);

                if (selectedSourceType === 'proactiveMonitoring') {
                    alerts = parseNewRawData(rawText);
                } else if (selectedSourceType === 'gadgetUI') {
                    alerts = parseGadgetUIData(rawText);
                } else {
                    showMessage("Invalid data source type selected.", "error");
                    return;
                }

                if (alerts === null) {
                    // This means the parser decided there's nothing to process (e.g. empty input, or only headers for ProM)
                    // The parser function should have shown an appropriate message.
                    // Ensure widgets and charts are reset or show "no data"
                    renderSummaryWidgets({ totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {} });
                    renderAlertCountChart({ labels: [], datasets: [] });
                    renderTotalDurationChart({ labels: [], groupedDataByLevel: {}, alertLevelsList: [] });
                    return;
                }
                console.log('Parsed Alerts from selected source:', alerts.length);

                if (alerts.length === 0) {
                    // This means parsing happened, but yielded no valid alert items.
                    // The parser *might* have shown a message (e.g., "No valid alerts found...")
                    // Or, if the input was just headers, parseNewRawData might return []
                    if(selectedSourceType === 'proactiveMonitoring' && parseNewRawData.length > 1 && !messageBox.textContent.includes("No valid alerts")) {
                        // If ProM, had more than headers, but no alerts, and no message was shown by parser
                        showMessage('No valid alerts found in the Proactive Monitoring data after parsing.', 'warning');
                    } else if (selectedSourceType === 'gadgetUI' && parseGadgetUIData.length > 1 && !messageBox.textContent.includes("No valid alerts")){
                         showMessage('No valid alerts found in the Gadget-UI data after parsing.', 'warning');
                    }
                    // Ensure widgets and charts are reset or show "no data"
                    renderSummaryWidgets({ totalAlertCountOverall: 0, countByLevelOverall: {}, countByMetricOverall: {} });
                    renderAlertCountChart({ labels: [], datasets: [] });
                    renderTotalDurationChart({ labels: [], groupedDataByLevel: {}, alertLevelsList: [] });
                    return;
                }

                currentProcessedData = processAlertDataForDurationAndCount(alerts);

                if (currentProcessedData) {
                    renderSummaryWidgets(currentProcessedData);
                    if (alertCountChartTitleElement) {
                        alertCountChartTitleElement.textContent = `Timeline of ProM alerts (${currentProcessedData.totalAlertCountOverall || 0}) for the selected period`;
                    }
                    alertCountChartInstance = renderAlertCountChart(currentProcessedData);
                    totalDurationChartInstance = renderTotalDurationChart(currentProcessedData);

                    if (currentProcessedData.totalAlertCountOverall > 0) { // Check if any data was actually processed and counted
                        showMessage('Data visualized successfully!', 'success');
                    } else if (alerts.length > 0 && currentProcessedData.totalAlertCountOverall === 0) {
                        // Data was parsed, but processing yielded no countable items (e.g. all alerts had invalid dates/durations AFTER parsing)
                        showMessage('Data parsed, but no items could be processed for charts. Check console for details.', 'warning');
                    } else {
                        // This case should be rare if alerts.length > 0 but totalAlertCountOverall is 0.
                        // It implies alerts were parsed but not processed.
                        showMessage('Could not render charts or process data effectively. Check console for details.', 'warning');
                    }
                } else {
                     // processAlertDataForDurationAndCount returned null, meaning a more fundamental processing error
                    showMessage('Error processing alert data for visualization. Check console.');
                }
            }

            function processAlertDataForDurationAndCount(alerts) {
                console.log('Processing Alerts for Duration & Count (Weekly & Overall):', alerts.length);
                if (!alerts || alerts.length === 0) { // Should not happen if visualizeData checks alerts.length
                    console.warn("processAlertDataForDurationAndCount called with no alerts.");
                    return null;
                }

                const processedItems = [];
                const uniqueMetrics = new Set();
                const uniqueLevels = new Set();

                const overallCountsByLevel = {};
                const overallCountsByMetric = {};
                let totalCount = 0;

                alerts.forEach(alert => {
                    if (alert.startDate instanceof Date && !isNaN(alert.startDate.getTime()) &&
                        alert.endDate instanceof Date && !isNaN(alert.endDate.getTime()) &&
                        alert.endDate >= alert.startDate &&
                        alert.alertName && alert.alertName.length > 0 &&
                        alert.status && alert.status.length > 0) {
                        const durationMillis = alert.endDate.getTime() - alert.startDate.getTime();
                        const durationHours = durationMillis / (1000 * 60 * 60);

                        if (!isNaN(durationHours) && durationHours > 0) { // Ensure duration is also positive
                            processedItems.push({
                                startDate: alert.startDate,
                                alertName: alert.alertName,
                                durationHours: durationHours,
                                status: alert.status
                            });
                            totalCount++;
                            overallCountsByLevel[alert.status] = (overallCountsByLevel[alert.status] || 0) + 1;
                            overallCountsByMetric[alert.alertName] = (overallCountsByMetric[alert.alertName] || 0) + 1;
                            uniqueMetrics.add(alert.alertName);
                            uniqueLevels.add(alert.status);
                        } else {
                            console.warn("Calculated duration is NaN or zero for alert (after parsing):", alert, "DurationHours:", durationHours);
                        }
                    } else {
                        console.warn("Skipping alert due to missing required fields, invalid dates, or non-positive duration (after parsing):", alert);
                    }
                });

                console.log("Overall Counts by Level:", overallCountsByLevel);
                console.log("Overall Counts by Metric:", overallCountsByMetric);
                console.log("Total Valid Alerts for Processing (totalCount):", totalCount);


                if (totalCount === 0) { // If no alerts were actually processed (e.g. all had invalid duration after parsing)
                     console.log("No valid items were processed (totalCount is 0). Widgets will show 0.");
                     return { // Still return a structure for widgets/charts to show "0" or empty state
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: [],
                        alertLevelsList: [],
                        totalAlertCountOverall: 0,
                        countByLevelOverall: {},
                        countByMetricOverall: {}
                    };
                }


                const alertMetricsList = [...uniqueMetrics];
                const alertLevelsList = [...uniqueLevels];

                // Proceed with weekly grouping only if there are items that were valid enough to be processed
                if (processedItems.length === 0 && totalCount > 0) {
                    // This is an inconsistent state, should not happen if totalCount is derived from processedItems
                    console.error("Inconsistent state: totalCount > 0 but processedItems is empty.");
                    // Fallback to return overall counts if something went wrong with processedItems push
                    return {
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: alertMetricsList,
                        alertLevelsList: alertLevelsList,
                        totalAlertCountOverall: totalCount,
                        countByLevelOverall: overallCountsByLevel,
                        countByMetricOverall: overallCountsByMetric
                    };
                }


                const startDates = processedItems.map(d => d.startDate);
                const weekStarts = getWeekStarts(startDates);

                if (weekStarts.length === 0 && processedItems.length > 0) { // Had items, but couldn't determine weeks (e.g. all dates invalid somehow for getWeekStarts)
                    console.log('No weekly start dates generated, but returning overall counts as items were processed.');
                     return {
                        labels: [], datasets: [], groupedData: {}, groupedDataByLevel: {},
                        alertMetricsList: alertMetricsList,
                        alertLevelsList: alertLevelsList,
                        totalAlertCountOverall: totalCount,
                        countByLevelOverall: overallCountsByLevel,
                        countByMetricOverall: overallCountsByMetric
                    };
                }
                const labels = weekStarts.map(formatDateRange);

                const groupedData = {};
                labels.forEach(label => {
                    groupedData[label] = {};
                    alertMetricsList.forEach(metric => {
                        groupedData[label][metric] = { totalDuration: 0, count: 0 };
                    });
                });

                const groupedDataByLevel = {};
                labels.forEach(label => {
                    groupedDataByLevel[label] = {};
                    alertLevelsList.forEach(level => {
                        groupedDataByLevel[label][level] = { totalDuration: 0, count: 0 };
                    });
                });

                processedItems.forEach(item => {
                    const { startDate, alertName, durationHours, status } = item;
                    // durationHours already checked to be > 0 and not NaN before pushing to processedItems

                    for (let i = 0; i < weekStarts.length; i++) {
                        const weekStart = new Date(weekStarts[i] + 'T00:00:00Z');
                        const weekEnd = new Date(weekStarts[i] + 'T00:00:00Z');
                        weekEnd.setUTCDate(weekEnd.getUTCDate() + 6);
                        weekEnd.setUTCHours(23, 59, 59, 999);

                        if (startDate >= weekStart && startDate <= weekEnd) {
                            if (groupedData[labels[i]] && groupedData[labels[i]].hasOwnProperty(alertName)) {
                                groupedData[labels[i]][alertName].totalDuration += durationHours;
                                groupedData[labels[i]][alertName].count++;
                            } else {
                                console.warn(`Metric "${alertName}" not found for week "${labels[i]}" in groupedData initialization.`);
                            }
                            if (groupedDataByLevel[labels[i]] && groupedDataByLevel[labels[i]].hasOwnProperty(status)) {
                                groupedDataByLevel[labels[i]][status].totalDuration += durationHours;
                                groupedDataByLevel[labels[i]][status].count++;
                            } else {
                                console.warn(`Level "${status}" not found for week "${labels[i]}" in groupedDataByLevel initialization.`);
                            }
                            break;
                        }
                    }
                });

                const colorsMetrics = generateDistinctColors(alertMetricsList.length);
                const datasetsForFirstChart = alertMetricsList.map((metric, index) => ({
                    label: metric,
                    data: labels.map(label => {
                        const dataPoint = groupedData[label] && groupedData[label][metric] ? groupedData[label][metric].count : 0;
                        return (dataPoint && !isNaN(dataPoint)) ? dataPoint : 0;
                    }),
                    backgroundColor: colorsMetrics[index % colorsMetrics.length]
                }));


                return {
                    labels: labels,
                    datasets: datasetsForFirstChart,
                    groupedData: groupedData, // For debug or future use
                    groupedDataByLevel: groupedDataByLevel,
                    alertMetricsList: alertMetricsList,
                    alertLevelsList: alertLevelsList,
                    totalAlertCountOverall: totalCount,
                    countByLevelOverall: overallCountsByLevel,
                    countByMetricOverall: overallCountsByMetric
                };
            }

            function renderSummaryWidgets(summaryData) {
                console.log("Rendering summary widgets with data:", summaryData);
                totalAlertCountWidget.textContent = summaryData.totalAlertCountOverall || 0;
                levelBreakdownWidget.innerHTML = ''; // Clear previous
                const countsByLevel = summaryData.countByLevelOverall || {};
                const totalAlertsForBreakdown = summaryData.totalAlertCountOverall || 0; // Use overall total for percentage
                const levels = Object.keys(countsByLevel).sort((a, b) => countsByLevel[b] - countsByLevel[a]);

                if (levels.length === 0 && totalAlertsForBreakdown > 0) {
                    const listItem = document.createElement('li');
                    listItem.textContent = "No level breakdown available.";
                    levelBreakdownWidget.appendChild(listItem);
                } else if (levels.length === 0) {
                     // No levels and no total alerts, show nothing or "No data"
                }
                else {
                    levels.forEach(level => {
                        const count = countsByLevel[level];
                        const percentage = totalAlertsForBreakdown > 0 ? (count / totalAlertsForBreakdown) * 100 : 0;
                        const listItem = document.createElement('li');
                        const levelClass = level.toLowerCase();
                        let barClass = 'other';
                        if (['warning', 'critical', 'exhausted', 'info'].includes(levelClass)) {
                            barClass = levelClass;
                        }
                        listItem.innerHTML = `
                            <span class="level-name">${level}</span>
                            <div class="level-bar">
                                <div class="level-bar-inner ${barClass}" style="width: ${percentage.toFixed(1)}%;"></div>
                            </div>
                            <span class="level-count">${count}</span>`;
                        levelBreakdownWidget.appendChild(listItem);
                    });
                }


                topMetricsListWidget.innerHTML = ''; // Clear previous
                const countsByMetric = summaryData.countByMetricOverall || {};
                const sortedMetrics = Object.keys(countsByMetric)
                    .map(metric => ({ name: metric, count: countsByMetric[metric] }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);

                if (sortedMetrics.length === 0 && totalAlertsForBreakdown > 0) {
                     const listItem = document.createElement('li');
                     listItem.textContent = "No metric data to display.";
                     topMetricsListWidget.appendChild(listItem);
                } else if (sortedMetrics.length === 0) {
                    // No metrics and no total alerts, show nothing or "No data"
                }
                else {
                    sortedMetrics.forEach(metric => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `
                            <span class="metric-name">${metric.name}</span>
                            <span class="metric-count">${metric.count}</span>`;
                        topMetricsListWidget.appendChild(listItem);
                    });
                }
            }

            function getWeekStarts(dates) {
                if (!dates || dates.length === 0) return [];
                const sortedDates = [...dates].sort((a, b) => a.getTime() - b.getTime());
                const minDate = sortedDates[0];
                const maxDate = sortedDates[sortedDates.length - 1];
                if (isNaN(minDate.getTime()) || isNaN(maxDate.getTime())) {
                     console.error("getWeekStarts received invalid dates."); return [];
                }
                let currentMonday = getMonday(minDate);
                if (isNaN(currentMonday.getTime())) {
                    console.error("getMonday returned invalid date from minDate."); return [];
                }

                const weekStarts = [];
                const mondayOfMaxDateWeek = getMonday(maxDate);
                 if (isNaN(mondayOfMaxDateWeek.getTime())) {
                    console.error("getMonday returned invalid date from maxDate."); return weekStarts; // return what we have so far
                }


                // Loop until currentMonday is past the Monday of the maxDate's week
                // To include the week of maxDate, we go until currentMonday > mondayOfMaxDateWeek
                while (currentMonday.getTime() <= mondayOfMaxDateWeek.getTime()) {
                    weekStarts.push(currentMonday.toISOString().slice(0, 10));
                    currentMonday.setUTCDate(currentMonday.getUTCDate() + 7);
                }
                return weekStarts;
            }

            function getMonday(date) {
                if (!(date instanceof Date) || isNaN(date.getTime())) {
                    console.error("Invalid date provided to getMonday:", date);
                    return new Date(NaN); // Return invalid date
                }
                const d = new Date(date.getTime()); // Create a copy
                const day = d.getUTCDay(); // 0 for Sunday, 1 for Monday, ..., 6 for Saturday
                const diff = d.getUTCDate() - day + (day === 0 ? -6 : 1); // Adjust to Monday
                d.setUTCDate(diff);
                d.setUTCHours(0, 0, 0, 0); // Set to midnight UTC
                return d;
            }

            function formatDateRange(startDateStr) {
                if (!startDateStr) return '';
                try {
                    const start = new Date(startDateStr + 'T00:00:00Z'); // Assume YYYY-MM-DD is UTC
                    const end = new Date(start);
                    end.setUTCDate(end.getUTCDate() + 6); // Sunday
                    const startDay = String(start.getUTCDate()).padStart(2, '0');
                    const startMonth = String(start.getUTCMonth() + 1).padStart(2, '0');
                    const endDay = String(end.getUTCDate()).padStart(2, '0');
                    const endMonth = String(end.getUTCMonth() + 1).padStart(2, '0');
                    return `${startDay}/${startMonth} - ${endDay}/${endMonth}`;
                } catch (e) {
                    console.error("Error formatting date range:", startDateStr, e);
                    return 'Invalid Date';
                }
            }

            function generateDistinctColors(count) {
                if (count <= 0) return ['rgba(54, 162, 235, 0.8)']; // Default blue
                const colors = [];
                const saturation = 0.7; // 0.0-1.0
                const lightness = 0.6;  // 0.0-1.0
                for (let i = 0; i < count; i++) {
                    const hue = (i * (360 / count) + 40) % 360; // Offset hue for better start color
                    colors.push(`hsla(${hue}, ${saturation * 100}%, ${lightness * 100}%, 0.8)`);
                }
                return colors;
            }

            function getLevelColor(level) {
                const lowerLevel = level.toLowerCase();
                switch (lowerLevel) {
                    case 'warning': return 'rgba(252, 211, 77, 0.8)'; // amber-300/400
                    case 'critical': return 'rgba(239, 68, 68, 0.8)'; // red-500
                    case 'exhausted': return 'rgba(167, 139, 250, 0.8)'; // violet-400
                    case 'info': return 'rgba(56, 178, 172, 0.8)'; // teal-500 (using a slightly different teal from style for bar)
                    default: return 'rgba(107, 114, 128, 0.8)'; // gray-500
                }
            }

            function renderAlertCountChart(processedData) {
                const { labels, datasets } = processedData || { labels: [], datasets: [] }; // Default to empty if processedData is null/undefined

                const ctx = document.getElementById('alertCountChart').getContext('2d');
                if (alertCountChartInstance) {
                    alertCountChartInstance.destroy();
                    alertCountChartInstance = null;
                }

                if (labels.length === 0) {
                    console.log("No labels for alert count chart, clearing canvas.");
                    // Optionally, draw a "No data" message on the canvas
                    // ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    // ctx.textAlign = 'center';
                    // ctx.fillText('No data to display', ctx.canvas.width / 2, ctx.canvas.height / 2);
                    return null;
                }

                const hasPositiveData = datasets && datasets.some(ds => ds.data.some(value => value > 0));
                if (!hasPositiveData) {
                     console.warn("Alert count chart: No positive data found, but labels exist. Rendering empty structure.");
                }


                try {
                    alertCountChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: { labels, datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            scales: {
                                x: { stacked: true, title: { display: true, text: 'Week Alert Started (Monday - Sunday)' } },
                                y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Number of Alerts' }, ticks: { precision: 0, callback: function(value) { if (Number.isInteger(value)) { return value; } } } }
                            },
                            plugins: {
                                legend: { position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle' } },
                                tooltip: {
                                    mode: 'index', intersect: false,
                                    callbacks: {
                                        label: function (context) {
                                            let label = context.dataset.label || '';
                                            if (label) { label += ': '; }
                                            if (context.parsed.y !== null) {
                                                label += context.parsed.y + ` alert${context.parsed.y === 1 ? '' : 's'}`;
                                            }
                                            return label;
                                        }
                                    }
                                },
                                datalabels: {
                                    display: function (context) {
                                        return context.dataset.data[context.dataIndex] > 0;
                                    },
                                    color: 'white', anchor: 'center', align: 'center',
                                    font: { weight: 'bold', size: 10 },
                                    formatter: (value) => value,
                                    textStrokeColor: 'black',
                                    textStrokeWidth: 1
                                }
                            }
                        }
                    });
                    return alertCountChartInstance;
                } catch (error) {
                    console.error('Error rendering alert count chart:', error);
                    showMessage('Error rendering alert count chart. Check console.');
                    return null;
                }
            }

            function renderTotalDurationChart(processedData) {
                const { labels, groupedDataByLevel, alertLevelsList } = processedData || { labels: [], groupedDataByLevel: {}, alertLevelsList: [] };

                const ctx = document.getElementById('totalDurationChart').getContext('2d');
                if (totalDurationChartInstance) {
                    totalDurationChartInstance.destroy();
                    totalDurationChartInstance = null;
                }

                if (labels.length === 0) {
                     console.log("No labels for total duration chart, clearing canvas.");
                     return null;
                }

                const currentAlertLevels = alertLevelsList || [];
                const sortedLevels = ['Critical', 'Warning', 'Exhausted', 'Info'].filter(level => currentAlertLevels.includes(level));
                currentAlertLevels.forEach(level => {
                    if (!sortedLevels.includes(level)) sortedLevels.push(level);
                });

                const datasetsForSecondChart = sortedLevels.map(level => {
                    const levelColor = getLevelColor(level);
                    return {
                        label: level,
                        data: labels.map(label => {
                            const dataPoint = groupedDataByLevel && groupedDataByLevel[label] && groupedDataByLevel[label][level] ? groupedDataByLevel[label][level].totalDuration : 0;
                            return (dataPoint && !isNaN(dataPoint)) ? dataPoint : 0;
                        }),
                        backgroundColor: levelColor,
                        borderColor: levelColor.replace(', 0.8)', ', 1)'),
                        borderWidth: 1
                    };
                });

                const hasPositiveData = datasetsForSecondChart.some(ds => ds.data.some(value => value > 0));
                 if (!hasPositiveData) {
                     console.warn("Total duration chart: No positive data found, but labels exist. Rendering empty structure.");
                }


                const weeklyTotals = labels.map(label => {
                    let total = 0;
                    if (groupedDataByLevel && groupedDataByLevel[label]) {
                        sortedLevels.forEach(level => {
                            const duration = groupedDataByLevel[label][level]?.totalDuration || 0;
                            if (!isNaN(duration)) total += duration;
                        });
                    }
                    return total;
                });
                const maxValue = Math.max(0, ...weeklyTotals);
                const yAxisMax = maxValue > 0 ? maxValue * 1.15 : 1;

                try {
                    totalDurationChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: { labels: labels, datasets: datasetsForSecondChart },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            scales: {
                                x: { stacked: true, title: { display: true, text: 'Week Alert Started (Monday - Sunday)' } },
                                y: {
                                    stacked: true, beginAtZero: true, max: yAxisMax,
                                    title: { display: true, text: 'Sum of Durations (hours)' },
                                    ticks: { precision: 1 }
                                }
                            },
                            plugins: {
                                legend: { display: true, position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle' } },
                                tooltip: {
                                    mode: 'index', intersect: false,
                                    callbacks: {
                                        label: function (context) {
                                            let label = context.dataset.label || '';
                                            if (label) { label += ': '; }
                                            if (context.parsed.y !== null) {
                                                label += context.parsed.y.toFixed(1) + ' hours';
                                            }
                                            return label;
                                        },
                                        footer: function (tooltipItems) {
                                            let total = 0;
                                            tooltipItems.forEach(function (tooltipItem) { total += tooltipItem.parsed.y; });
                                            return 'Total: ' + total.toFixed(1) + ' hours';
                                        }
                                    }
                                },
                                datalabels: {
                                    display: function (context) {
                                        return context.dataset.data[context.dataIndex] > 0.1;
                                    },
                                    anchor: 'center', align: 'center', color: 'white',
                                    font: { weight: 'bold', size: 10 },
                                    formatter: (value) => {
                                        if (value < 0.5 && value > 0.1) return value.toFixed(1);
                                        if (value < 0.1) return ''; // Hide very small labels
                                        return value.toFixed(1);
                                    },
                                    textStrokeColor: 'black',
                                    textStrokeWidth: 1,
                                }
                            }
                        }
                    });
                    return totalDurationChartInstance;
                } catch (error) {
                    console.error('Error rendering total duration chart:', error);
                    showMessage('Error rendering total duration chart. Check console.');
                    return null;
                }
            }
        });
    </script>
</body>
</html>
