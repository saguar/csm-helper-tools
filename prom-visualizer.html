<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProM Alert Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
            padding: 1rem;
        }
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            box-sizing: border-box;
        }
        h1, h2, h3 {
            color: #1a202c;
            margin-bottom: 1rem;
            font-weight: 700;
        }
        h1 { text-align: center; margin-bottom: 2rem; font-size: 1.875rem; }
        h2, h3 { margin-top: 0; font-size: 1.25rem; }
        .source-selector-container { margin-bottom: 1.5rem; padding: 1rem; background-color: #f9fafb; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
        .source-selector-container h3 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.75rem; color: #374151; }
        .source-selector-options div { margin-bottom: 0.5rem; }
        .source-selector-options label { color: #4b5563; cursor: pointer; margin-left: 0.25rem; }
        .source-selector-options input[type="radio"] { accent-color: #4f46e5; }
        textarea { width: 100%; margin-bottom: 1.5rem; padding: 0.75rem; border-radius: 0.375rem; border: 1px solid #d1d5db; min-height: 200px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.95em; box-sizing: border-box; }
        .button-group { display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; margin-top: 1rem; margin-bottom: 2rem; }
        .action-btn { display: inline-block; color: white; padding: 0.65rem 1.25rem; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.95rem; font-weight: 600; transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .action-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }
        #visualizeButton { background-color: #10b981; }
        #visualizeButton:hover { background-color: #059669; }
        #aiAnalyzeButton { background-color: #4f46e5; }
        #aiAnalyzeButton:hover { background-color: #4338ca; }
        #aiAnalyzeButton:disabled { background-color: #a5b4fc; cursor: not-allowed; opacity: 0.7; }
        .summary-widgets-container { display: flex; gap: 1.5rem; margin-bottom: 2rem; flex-wrap: wrap; justify-content: center; }
        .widget-card { flex: 1; min-width: 280px; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1.5rem; text-align: left; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; }
        .widget-card h3 { margin-top: 0; margin-bottom: 1rem; color: #1f2937; font-size: 1.125rem; display: flex; align-items: center; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.75rem; }
        .widget-card .info-icon { font-size: 0.8em; margin-left: 0.5rem; color: #6b7280; cursor: help; }
        .widget-card .total-count { font-size: 3em; font-weight: 700; color: #4f46e5; margin-bottom: 1rem; text-align: center; }
        .level-breakdown, .top-metrics-list { list-style: none; padding: 0; margin: 0; flex-grow: 1; }
        .level-breakdown li, .top-metrics-list li { margin-bottom: 0.75rem; font-size: 0.90em; color: #4b5563; }
        .level-breakdown li { display: flex; align-items: center; justify-content: space-between; }
        .level-breakdown .level-name { flex-basis: 80px; flex-shrink: 0; margin-right: 0.75rem; font-weight: 600; color: #1f2937; }
        .level-breakdown .level-bar { flex-grow: 1; height: 10px; background-color: #e5e7eb; border-radius: 5px; overflow: hidden; margin-right: 0.75rem; }
        .level-breakdown .level-bar-inner { height: 100%; transition: width 0.5s ease-in-out; }
        .level-breakdown .level-bar-inner.warning { background-color: #fcd34d; }
        .level-breakdown .level-bar-inner.critical { background-color: #ef4444; }
        .level-breakdown .level-bar-inner.exhausted { background-color: #a78bfa; }
        .level-breakdown .level-bar-inner.info { background-color: #38b2ac; }
        .level-breakdown .level-bar-inner.cleared { background-color: #34d399; }
        .level-breakdown .level-bar-inner.other { background-color: #6b7280; }
        .level-breakdown .level-count, .top-metrics-list .metric-count { font-weight: 600; flex-shrink: 0; color: #1f2937; }
        .top-metrics-list li { display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px dashed #d1d5db; }
        .top-metrics-list li:last-child { border-bottom: none; padding-bottom: 0; margin-bottom: 0; }
        .top-metrics-list .metric-name { flex-grow: 1; margin-right: 0.75rem; color: #374151; word-break: break-word; }
        .chart-container { margin-bottom: 2rem; padding: 1.5rem; border: 1px solid #e5e7eb; border-radius: 0.5rem; background-color: #ffffff; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); }
        /* canvas { max-width: 100%; height: auto; } */ /* Commentato per test con dimensioni fisse */
        .message-box { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); padding: 1rem; background-color: #fef2f2; color: #991b1b; border: 1px solid #fca5a5; border-radius: 0.375rem; z-index: 1000; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 90%; text-align: left; }
        .message-box.success { background-color: #ecfdf5; color: #065f46; border-color: #a7f3d0; }
        .message-box.warning { background-color: #fffbeb; color: #92400e; border-color: #fcd34d; }
        footer { text-align: center; padding: 1.5rem; font-size: 0.875rem; color: #6b7280; margin-top: 2rem; }
        #aiResponseArea { margin-top: 2rem; padding: 1.5rem; border: 1px solid #a78bfa; border-radius: 0.5rem; background-color: #f3e8ff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        #aiResponseArea h3 { color: #5b21b6; margin-bottom: 1rem; font-size: 1.25rem; font-weight: 700; }
        #aiResponseContent p, #aiResponseContent ul, #aiResponseContent li, #aiResponseContent strong, #aiResponseContent em, #aiResponseContent code, #aiResponseContent pre { color: #374151; line-height: 1.6; }
        #aiResponseContent ul { list-style: disc inside; margin-top: 0.5rem; margin-bottom: 0.5rem; padding-left: 1.5rem; }
        #aiResponseContent li { margin-bottom: 0.25rem; }
        #aiResponseContent pre { background-color: #e5e7eb; padding: 1rem; border-radius: 0.25rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all; }
        #aiResponseContent code:not(pre code) { font-family: monospace; background-color: #e0e0e0; padding: 0.125rem 0.25rem; border-radius: 0.125rem; }
        #aiResponseContent pre code { background-color: transparent; padding: 0; border-radius: 0;}
        .loading-indicator { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-left: 0.5rem; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <h1>ProM Alert Visualizer</h1>
        <div class="source-selector-container">
            <h3>Seleziona il Tipo di Sorgente Dati:</h3>
            <div class="source-selector-options">
                <div><input type="radio" id="sourceProactiveMonitoring" name="dataSourceType" value="proactiveMonitoring" checked><label for="sourceProactiveMonitoring">Proactive Monitoring Internal Portal</label></div>
                <div><input type="radio" id="sourceGadgetUI" name="dataSourceType" value="gadgetUI"><label for="sourceGadgetUI">Gadget-UI Portal</label></div>
            </div>
        </div>
        <textarea id="alertData" rows="15" placeholder="Incolla qui i dati GREZZI copiati dalla sorgente degli alert..."></textarea>
        <div class="button-group">
            <button id="visualizeButton" class="action-btn">Visualizza Dati</button>
            <button id="aiAnalyzeButton" class="action-btn" style="display: none;">Analizza Dati con AI</button>
        </div>
        <div class="summary-widgets-container">
            <div class="widget-card">
                <h3>Totale Alert ProM <span class="info-icon" title="Conteggio totale degli alert processati con date e durata valide.">&#x24D8;</span></h3>
                <div class="total-count" id="totalAlertCountWidget">0</div>
                <div class="level-breakdown" id="levelBreakdownWidget"></div>
            </div>
            <div class="widget-card">
                <h3>Top Alert per Volume <span class="info-icon" title="Le 5 metriche di alert principali per conteggio totale nel periodo.">&#x24D8;</span></h3>
                <div class="top-metrics-list" id="topMetricsListWidget"></div>
            </div>
        </div>
        <div class="chart-container"><h3 id="alertCountChartTitle">Timeline degli alert ProM</h3><canvas id="alertCountChart" width="600" height="350"></canvas></div>
        <div class="chart-container"><h3>Durata Totale Alert per Settimana (ore)</h3><canvas id="totalDurationChart" width="600" height="350"></canvas></div>
        <div id="aiResponseArea" aria-live="polite" style="display: none;"><h3>Analisi AI</h3><div id="aiResponseContent"></div></div>
    </div>
    <div id="messageBox" class="message-box" aria-live="polite"></div>
    <footer>Questi strumenti non sono ufficiali o autorizzati da Salesforce. Sono stati sviluppati per uso personale da Saverio Guardato con lo scopo di migliorare le attività dei CSM.</footer>

    <script>
        // Temporaneamente commentato per debug: Chart.register(ChartDataLabels);
        const BACKEND_URL_AI = 'https://csm-ai-backend-43c415c64d97.herokuapp.com/analyze-release-update';

        document.addEventListener('DOMContentLoaded', function () {
            const visualizeButton = document.getElementById('visualizeButton');
            const aiAnalyzeButton = document.getElementById('aiAnalyzeButton');
            const alertDataTextarea = document.getElementById('alertData');
            const messageBox = document.getElementById('messageBox');
            const alertCountChartTitleElement = document.getElementById('alertCountChartTitle');
            const totalAlertCountWidget = document.getElementById('totalAlertCountWidget');
            const levelBreakdownWidget = document.getElementById('levelBreakdownWidget');
            const topMetricsListWidget = document.getElementById('topMetricsListWidget');
            let alertCountChartInstance = null;
            let totalDurationChartInstance = null;
            let currentRawDataForAI = "";

            visualizeButton.addEventListener('click', visualizeData);
            aiAnalyzeButton.addEventListener('click', handleAIAnalysisRequest);

            function showMessage(message, type = 'error') { /* ... */ }
            function hideMessage() { /* ... */ }
            function showAIResponse(response) { /* ... */ }
            function hideAIResponse() { /* ... */ }
            async function analyzeProMDataWithGemini(rawDataToAnalyze, buttonElement) { /* ... */ }
            function handleAIAnalysisRequest() { /* ... */ }
            function parseDurationString(durationStr) { /* ... */ }
            function parseTriggeredDateTime(dateTimeStr) { /* ... */ }
            function parseNewRawData(rawText) { /* ... */ }
            function parseGadgetUIData(rawText) { /* ... */ }
            function visualizeData() { /* ... */ }
            function clearChartCanvas(canvasId) { /* ... */ }
            function processAlertDataForDurationAndCount(alerts) { /* ... */ }
            function renderSummaryWidgets(summaryData) { /* ... */ }
            function getWeekStarts(datesArray) { /* ... */ }
            function getMonday(date) { /* ... */ }
            function formatDateRange(startDateStringYYYYMMDD) { /* ... */ }
            function generateDistinctColors(count) { /* ... */ }
            function getLevelColor(levelName) { /* ... */ }

            // Mantengo le implementazioni delle funzioni JS come nella versione precedente (v3)
            // per brevità, ma con le correzioni a parseDurationString e parseTriggeredDateTime
            // e i log diagnostici discussi.
            // Le funzioni di rendering dei grafici ora avranno responsive: false.

            // (Copiare qui le implementazioni complete delle funzioni JS dalla versione precedente, 
            //  assicurandosi che parseDurationString e parseTriggeredDateTime siano quelle corrette
            //  e che le opzioni dei grafici abbiano responsive: false)


            // --- Funzioni JS (con correzioni e log, e responsive:false per i grafici) ---
            // (Le funzioni non modificate per questo test sono abbreviate con /* ... */ per leggibilità qui,
            //  ma nel Canvas sono complete come nella versione precedente prom_alert_visualizer_v3,
            //  con le modifiche a parseDurationString, parseTriggeredDateTime e opzioni grafici)

            function showMessage(message, type = 'error') {
                messageBox.textContent = message;
                messageBox.className = `message-box ${type}`;
                messageBox.style.display = 'block';
                setTimeout(hideMessage, type === 'success' ? 4000 : 8000);
            }
            function hideMessage() { messageBox.style.display = 'none'; }

            function showAIResponse(response) {
                const aiResponseArea = document.getElementById('aiResponseArea');
                const aiResponseContent = document.getElementById('aiResponseContent');
                if (window.marked && typeof window.marked.parse === 'function') {
                    aiResponseContent.innerHTML = window.marked.parse(response);
                } else {
                    aiResponseContent.textContent = response;
                    console.warn("Libreria marked.js o marked.parse non trovata/funzione. Mostrando risposta AI come testo semplice.");
                }
                aiResponseArea.style.display = 'block';
            }
            function hideAIResponse() {
                const aiResponseArea = document.getElementById('aiResponseArea');
                if (aiResponseArea) {
                    aiResponseArea.style.display = 'none';
                    const aiResponseContent = document.getElementById('aiResponseContent');
                    if (aiResponseContent) aiResponseContent.innerHTML = '';
                }
            }
            async function analyzeProMDataWithGemini(rawDataToAnalyze, buttonElement) {
                buttonElement.textContent = 'Analisi in corso...';
                buttonElement.disabled = true;
                const originalBgColor = buttonElement.style.backgroundColor;
                buttonElement.style.backgroundColor = '#6b7280'; buttonElement.style.cursor = 'not-allowed';
                const loadingSpinner = document.createElement('span'); loadingSpinner.classList.add('loading-indicator');
                buttonElement.appendChild(loadingSpinner);
                hideAIResponse();
                try {
                    const payload = { prom_alert_raw_data: rawDataToAnalyze };
                    const response = await fetch(BACKEND_URL_AI, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        let errorMsg = 'Errore sconosciuto dal backend.';
                        try { const errorBody = await response.json(); errorMsg = errorBody.error || errorBody.message || errorMsg; } catch (e) { errorMsg = response.statusText; }
                        throw new Error(`Errore dal Backend: ${response.status} - ${errorMsg}`);
                    }
                    const data = await response.json();
                    if (data && data.analysis) { showAIResponse(data.analysis); } else { showAIResponse("Risposta AI non valida o vuota ricevuta."); }
                } catch (error) {
                    console.error("Errore durante la chiamata AI:", error);
                    showAIResponse(`Errore analisi AI: ${error.message || 'Problema di rete o backend.'}`);
                } finally {
                    buttonElement.textContent = 'Analizza Dati con AI'; buttonElement.disabled = false;
                    buttonElement.style.backgroundColor = originalBgColor; buttonElement.style.cursor = 'pointer';
                    const spinner = buttonElement.querySelector('.loading-indicator'); if (spinner) spinner.remove();
                }
            }
            function handleAIAnalysisRequest() {
                if (!currentRawDataForAI) { showMessage("Nessun dato da analizzare. Visualizza i dati prima.", "warning"); return; }
                analyzeProMDataWithGemini(currentRawDataForAI, aiAnalyzeButton);
            }

            function parseDurationString(durationStr) {
                console.log("parseDurationString IN:", durationStr);
                if (!durationStr) { console.log("parseDurationString OUT: 0 (input nullo)"); return 0; }
                durationStr = durationStr.trim().toLowerCase();
                let totalMilliseconds = 0;
                const durationParts = durationStr.match(/(\d+[\.,]?\d*)\s*(d|h|m|s)/g);
                if (durationParts) {
                    durationParts.forEach(part => {
                        const match = part.match(/(\d+[\.,]?\d*)\s*(d|h|m|s)/);
                        if (match) {
                            const value = parseFloat(match[1].replace(',', '.'));
                            const unit = match[2];
                            if (isNaN(value)) return;
                            if (unit === 'd') totalMilliseconds += value * 86400000;
                            else if (unit === 'h') totalMilliseconds += value * 3600000;
                            else if (unit === 'm') totalMilliseconds += value * 60000;
                            else if (unit === 's') totalMilliseconds += value * 1000;
                        }
                    });
                } else {
                    const singleValue = parseFloat(durationStr.replace(',', '.'));
                    if (!isNaN(singleValue) && /^\d+[\.,]?\d*$/.test(durationStr.trim())) {
                        console.warn("Durata stringa senza unità riconosciuta:", durationStr, "- interpretata come 0ms.");
                    } else { console.warn("Impossibile parsare la durata:", durationStr, "- interpretata come 0ms.");}
                }
                console.log("parseDurationString OUT:", totalMilliseconds, "ms");
                return totalMilliseconds;
            }

            function parseTriggeredDateTime(dateTimeStr) {
                console.log("parseTriggeredDateTime IN:", dateTimeStr);
                if (!dateTimeStr) { console.log("parseTriggeredDateTime OUT: Invalid Date (input nullo)"); return new Date(NaN); }
                const cleanedDateStr = dateTimeStr.replace(/\s*\(.*?\)$/, '').replace(/,(\s*\d{2}:\d{2})/, '$1');
                console.log("parseTriggeredDateTime - Stringa pulita per new Date():", cleanedDateStr);
                let d = new Date(cleanedDateStr);
                if (!isNaN(d.getTime())) {
                    console.log("parseTriggeredDateTime OUT (metodo generico):", d.toISOString());
                    return d;
                }
                console.warn("parseTriggeredDateTime - Metodo generico fallito per:", cleanedDateStr);
                const euFormatMatch = dateTimeStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2})(?::(\d{2}))?/);
                if (euFormatMatch) {
                    const day = parseInt(euFormatMatch[1], 10); const month = parseInt(euFormatMatch[2], 10) - 1;
                    const year = parseInt(euFormatMatch[3], 10); const hour = parseInt(euFormatMatch[4], 10);
                    const minute = parseInt(euFormatMatch[5], 10); const second = euFormatMatch[6] ? parseInt(euFormatMatch[6], 10) : 0;
                    d = new Date(year, month, day, hour, minute, second);
                    if (!isNaN(d.getTime())) { console.log("parseTriggeredDateTime OUT (formato EU):", d.toISOString()); return d; }
                    console.warn("parseTriggeredDateTime - Formato EU matchato ma data invalida:", euFormatMatch);
                }
                console.error("Fallimento parsing data (ProM) con tutti i metodi:", dateTimeStr);
                return new Date(NaN);
            }

            function parseNewRawData(rawText) { /* ... (come v3, usa le versioni corrette di parseDate/Duration) ... */
                console.log("Avvio parsing dati Proactive Monitoring Internal Portal...");
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) { showMessage("L'area di testo è vuota. Incolla prima i dati grezzi.", "warning"); return null; }
                const lines = rawText.replace(/^\[|\]$/g, '').split(/\r\n|\n/).map(l => l.trim()).filter(l => l.length > 0);
                if (lines.length < 2) { showMessage("Nessuna riga di dati trovata dopo gli header (Proactive Monitoring).", "warning"); return null; }
                const headers = lines[0].split('\t').map(h => h.trim());
                const headerMap = { 'Level': -1, 'Metric': -1, 'Triggered Date/Time': -1, 'Duration': -1 };
                headers.forEach((h, i) => { const k = Object.keys(headerMap).find(key => key.toLowerCase() === h.toLowerCase()); if (k) headerMap[k] = i; });
                const requiredHeadersForProM = ['Level', 'Metric', 'Triggered Date/Time', 'Duration'];
                const missing = requiredHeadersForProM.filter(k => headerMap[k] === -1);
                if (missing.length > 0) { showMessage(`Header richiesti mancanti per Proactive Monitoring: ${missing.join(', ')}.`, "error"); return null; }
                const maxIdx = Math.max(...Object.values(headerMap));
                for (let i = 1; i < lines.length; i++) {
                    const vals = lines[i].split('\t').map(v => v.trim());
                    if (vals.length < maxIdx + 1) { console.warn(`Riga ${i + 1} (ProM) saltata: numero di colonne incorretto.`); continue; }
                    const level = vals[headerMap.Level];
                    const metric = vals[headerMap.Metric];
                    const trigDateStr = vals[headerMap['Triggered Date/Time']];
                    const durStr = vals[headerMap.Duration];
                    const startDate = parseTriggeredDateTime(trigDateStr);
                    const durationMillis = parseDurationString(durStr);
                    if (startDate && !isNaN(startDate.getTime()) && durationMillis > 0 && metric && level) {
                        parsedAlerts.push({ alertName: metric, startDate, endDate: new Date(startDate.getTime() + durationMillis), status: level });
                    } else {
                        console.warn(`Riga ${i + 1} (ProM) saltata: dati non validi. StartDate valido: ${startDate && !isNaN(startDate.getTime())}, DurationMillis: ${durationMillis}, Metric: ${metric}, Level: ${level}`);
                    }
                }
                console.log('Parsing Dati ProM terminato. Alert validi:', parsedAlerts.length);
                if (parsedAlerts.length === 0 && lines.length > 1) showMessage("Nessun alert valido trovato nei dati ProM.", "warning");
                return (lines.length <=1 && parsedAlerts.length === 0 && !rawText.trim()) ? null : parsedAlerts;
            }
            function parseGadgetUIData(rawText) { /* ... (come v3, usa le versioni corrette di parseDate/Duration) ... */
                console.log("Avvio parsing dati Gadget-UI Portal...");
                const parsedAlerts = [];
                if (!rawText || rawText.trim().length === 0) { showMessage("L'area di testo è vuota per Gadget-UI. Incolla prima i dati grezzi.", "warning"); return null; }
                const lines = rawText.split(/\r\n|\n/).map(l => l.trim()).filter(l => l.length > 0);
                if (lines.length < 2) { showMessage("Nessuna riga di dati trovata dopo gli header (Gadget-UI).", "warning"); return null; }
                const rawHeaderCells = lines[0].split('\t');
                const headerMap = {'Alert Name':-1,'Organization ID':-1,'Instance':-1,'Customer Name':-1,'Start Time(UTC)':-1,'End Time(UTC)':-1,'Status':-1,'Alert Age (hrs)':-1};
                const knownColNamesSorted = Object.keys(headerMap).sort((a,b) => b.length - a.length);
                rawHeaderCells.forEach((rawCell, idx) => {
                    for(const knownName of knownColNamesSorted) { if(rawCell.toLowerCase().includes(knownName.toLowerCase()) && headerMap[knownName] === -1) { headerMap[knownName] = idx; break; } }
                });
                const reqCoreH = ['Alert Name','Start Time(UTC)','Status'];
                const missingCore = reqCoreH.filter(h => headerMap[h] === -1);
                if(missingCore.length > 0) { showMessage(`Gadget-UI: Header fondamentali mancanti: ${missingCore.join(', ')}.`, "error"); return null; }
                if(headerMap['End Time(UTC)'] === -1 && headerMap['Alert Age (hrs)'] === -1) { showMessage(`Gadget-UI: Mancano sia 'End Time(UTC)' sia 'Alert Age (hrs)'.`, "error");return null; }
                const highestCoreIdx = Math.max(headerMap['Alert Name'], headerMap['Start Time(UTC)'], headerMap['Status']);
                for(let i = 1; i < lines.length; i++) {
                    const vals = lines[i].split('\t').map(v=>v.trim());
                    if(vals.length < highestCoreIdx + 1) { console.warn(`Gadget-UI: Riga ${i+1} saltata: colonne insuff.`); continue; }
                    let alertNameRaw = vals[headerMap['Alert Name']], alertName = alertNameRaw.replace(/\(https:\/\/.*?\)/g,'').trim().replace(/\s*-\s*ProM$/i,'').trim();
                    if(!alertName) { console.warn(`Gadget-UI: Riga ${i+1} saltata: Alert Name vuoto.`); continue; }
                    const startTimeStr = vals[headerMap['Start Time(UTC)']];
                    let startDate = new Date(NaN);
                    const partsSt = startTimeStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2}):(\d{2})/);
                    if(partsSt) {
                        startDate = new Date(Date.UTC(parseInt(partsSt[3]), parseInt(partsSt[1])-1, parseInt(partsSt[2]), parseInt(partsSt[4]), parseInt(partsSt[5]), parseInt(partsSt[6])));
                    } else { console.warn(`Gadget-UI: Riga ${i+1} saltata: StartTime non parsabile: "${startTimeStr}"`); continue; }
                    if(isNaN(startDate.getTime())) { console.warn(`Gadget-UI: Riga ${i+1} saltata: StartDate non valida: "${startTimeStr}"`); continue; }
                    let endDate = new Date(NaN), durMillis = 0;
                    if(headerMap['End Time(UTC)'] !== -1 && vals[headerMap['End Time(UTC)']]) {
                        const endTimeStr = vals[headerMap['End Time(UTC)']];
                        const partsEnd = endTimeStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2}):(\d{2})/);
                        if(partsEnd) endDate = new Date(Date.UTC(parseInt(partsEnd[3]), parseInt(partsEnd[1])-1, parseInt(partsEnd[2]), parseInt(partsEnd[4]), parseInt(partsEnd[5]), parseInt(partsEnd[6])));
                        if(isNaN(endDate.getTime())) console.warn(`Gadget-UI: EndDate non valida: "${endTimeStr}"`);
                    }
                    if(headerMap['Alert Age (hrs)'] !== -1 && vals[headerMap['Alert Age (hrs)']]) {
                        const ageHrs = parseFloat(vals[headerMap['Alert Age (hrs)']].replace(',','.'));
                        if(!isNaN(ageHrs) && ageHrs > 0) durMillis = ageHrs * 3600000;
                    }
                    if(!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && endDate.getTime() > startDate.getTime()) {
                        durMillis = Math.max(durMillis, endDate.getTime() - startDate.getTime());
                    }
                    if(isNaN(endDate.getTime()) && durMillis > 0) endDate = new Date(startDate.getTime() + durMillis);
                    const status = vals[headerMap.Status];
                    if(!status) { console.warn(`Gadget-UI: Riga ${i+1} saltata: Status vuoto.`); continue; }
                    if(durMillis <= 0) { console.warn(`Gadget-UI: Riga ${i+1} saltata: Durata zero/negativa.`); continue; }
                    if(isNaN(endDate.getTime()) || endDate.getTime() <= startDate.getTime()) { console.warn(`Gadget-UI: Riga ${i+1} saltata: intervallo date non valido.`); continue; }
                    parsedAlerts.push({alertName, startDate, endDate, status});
                }
                console.log('Parsing Dati Gadget-UI terminato. Alert validi:', parsedAlerts.length);
                if(parsedAlerts.length === 0 && lines.length > 1) showMessage("Nessun alert valido trovato nei dati Gadget-UI.", "warning");
                return (lines.length <=1 && parsedAlerts.length === 0 && !rawText.trim()) ? null : parsedAlerts;
            }

            function visualizeData() {
                hideMessage(); hideAIResponse();
                aiAnalyzeButton.style.display = 'none'; aiAnalyzeButton.disabled = true;
                currentRawDataForAI = "";
                if (alertCountChartInstance) { alertCountChartInstance.destroy(); alertCountChartInstance = null; }
                if (totalDurationChartInstance) { totalDurationChartInstance.destroy(); totalDurationChartInstance = null; }
                totalAlertCountWidget.textContent = '0'; levelBreakdownWidget.innerHTML = ''; topMetricsListWidget.innerHTML = '';
                alertCountChartTitleElement.textContent = 'Timeline degli alert ProM';
                const rawText = alertDataTextarea.value.trim(); currentRawDataForAI = rawText;
                if (!rawText) { showMessage("L'area di testo è vuota.", "warning"); return; }
                const srcType = document.querySelector('input[name="dataSourceType"]:checked').value;
                let alerts;
                try { alerts = (srcType === 'proactiveMonitoring') ? parseNewRawData(rawText) : parseGadgetUIData(rawText); }
                catch (e) { console.error("Errore critico parsing:", e); showMessage(`Errore parsing: ${e.message}`, "error"); alerts = null; }
                if (alerts === null) return;
                if (alerts.length === 0) {
                    if (!messageBox.textContent || !messageBox.textContent.includes("Nessun alert valido")) { showMessage('Nessun alert valido creato.', 'warning'); }
                    renderSummaryWidgets({ totalAlertCountOverall:0, countByLevelOverall:{}, countByMetricOverall:{} });
                    renderAlertCountChart({ labels:[], datasets:[] }); renderTotalDurationChart({ labels:[], groupedDataByLevel:{}, alertLevelsList:[] }); return;
                }
                const processedData = processAlertDataForDurationAndCount(alerts);
                if (processedData) {
                    renderSummaryWidgets(processedData);
                    alertCountChartTitleElement.textContent = `Timeline (${processedData.totalAlertCountOverall || 0}) per periodo`;
                    if (processedData.labels && processedData.labels.length > 0) {
                        alertCountChartInstance = renderAlertCountChart(processedData);
                        totalDurationChartInstance = renderTotalDurationChart(processedData);
                    } else if (processedData.totalAlertCountOverall > 0) {
                        console.warn("Dati processati, ma nessuna etichetta per timeline. Grafici non renderizzati.");
                        clearChartCanvas('alertCountChart'); clearChartCanvas('totalDurationChart');
                    } else { clearChartCanvas('alertCountChart'); clearChartCanvas('totalDurationChart'); }
                    if (processedData.totalAlertCountOverall > 0) {
                        showMessage('Dati visualizzati!', 'success');
                        aiAnalyzeButton.style.display = 'inline-block'; aiAnalyzeButton.disabled = false;
                    } else if (alerts.length > 0) { showMessage('Dati parsati, ma nessun item processabile.', 'warning');
                    } else { showMessage('Nessun dato da mostrare.', 'warning'); }
                } else { showMessage('Errore elaborazione dati alert.', 'error'); }
            }
            function clearChartCanvas(canvasId) { /* ... */
                 const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
            function processAlertDataForDurationAndCount(alerts) { /* ... (come v3) ... */
                if (!alerts || alerts.length === 0) return { labels:[], datasets:[], groupedData:{}, groupedDataByLevel:{}, alertMetricsList:[], alertLevelsList:[], totalAlertCountOverall:0, countByLevelOverall:{}, countByMetricOverall:{} };
                const items = [], metrics = new Set(), levels = new Set(), lvlCounts = {}, metCounts = {};
                let total = 0;
                alerts.forEach(a => {
                    if (a.startDate instanceof Date && !isNaN(a.startDate.getTime()) && a.endDate instanceof Date && !isNaN(a.endDate.getTime()) && a.endDate.getTime() > a.startDate.getTime() && a.alertName && a.status) {
                        const durHrs = (a.endDate.getTime() - a.startDate.getTime()) / 3600000;
                        if (isNaN(durHrs) || !isFinite(durHrs)) { console.warn("Durata calcolata non valida (NaN/Infinity) per alert:",a); return; }
                        items.push({ startDate: a.startDate, alertName: a.alertName, durationHours: durHrs, status: a.status });
                        total++; lvlCounts[a.status] = (lvlCounts[a.status] || 0) + 1;
                        metCounts[a.alertName] = (metCounts[a.alertName] || 0) + 1;
                        metrics.add(a.alertName); levels.add(a.status);
                    } else { console.warn("Alert saltato in processAlertData:", a); }
                });
                console.log("processAlertData - Totale alert validi post-filtro:", total);
                if (total === 0) return { labels:[], datasets:[], groupedData:{}, groupedDataByLevel:{}, alertMetricsList:[...metrics], alertLevelsList:[...levels], totalAlertCountOverall:0, countByLevelOverall:lvlCounts, countByMetricOverall:metCounts };

                const metricsList = [...metrics], levelsList = [...levels];
                console.log("processAlertData - Metriche uniche:", metricsList.length, "Livelli unici:", levelsList.length);
                const startDates = items.map(d => d.startDate);
                const weekStarts = getWeekStarts(startDates);
                console.log("processAlertData - WeekStarts generate:", weekStarts.length, weekStarts);

                if (weekStarts.length === 0 && items.length > 0) {
                    console.warn("Nessuna settimana valida per raggruppamento. Mostrando solo statistiche generali.");
                    return { labels:[], datasets:[], groupedData:{}, groupedDataByLevel:{}, alertMetricsList:metricsList, alertLevelsList:levelsList, totalAlertCountOverall:total, countByLevelOverall:lvlCounts, countByMetricOverall:metCounts };
                }
                if (weekStarts.length === 0) {
                     return { labels:[], datasets:[], groupedData:{}, groupedDataByLevel:{}, alertMetricsList:metricsList, alertLevelsList:levelsList, totalAlertCountOverall:total, countByLevelOverall:lvlCounts, countByMetricOverall:metCounts };
                }

                const labels = weekStarts.map(formatDateRange);
                const groupedData = {}; const groupedDataByLvl = {};
                labels.forEach(lbl => {
                    groupedData[lbl] = {}; metricsList.forEach(m => groupedData[lbl][m] = { totalDuration: 0, count: 0 });
                    groupedDataByLvl[lbl] = {}; levelsList.forEach(l => groupedDataByLvl[lbl][l] = { totalDuration: 0, count: 0 });
                });
                items.forEach(item => {
                    for (let i = 0; i < weekStarts.length; i++) {
                        const weekStartObj = new Date(weekStarts[i] + 'T00:00:00.000Z');
                        const weekEndObj = new Date(weekStartObj);
                        weekEndObj.setUTCDate(weekEndObj.getUTCDate() + 6); weekEndObj.setUTCHours(23, 59, 59, 999);
                        if (item.startDate.getTime() >= weekStartObj.getTime() && item.startDate.getTime() <= weekEndObj.getTime()) {
                            const currentLabel = labels[i];
                            if (groupedData[currentLabel]?.[item.alertName]) { groupedData[currentLabel][item.alertName].count++; }
                            if (groupedDataByLvl[currentLabel]?.[item.status]) {
                                groupedDataByLvl[currentLabel][item.status].totalDuration += item.durationHours;
                                groupedDataByLvl[currentLabel][item.status].count++;
                            }
                            break;
                        }
                    }
                });
                const datasetsForAlertCountChart = metricsList.map((metricName, index) => ({
                    label: metricName,
                    data: labels.map(label => groupedData[label]?.[metricName]?.count || 0),
                    backgroundColor: generateDistinctColors(metricsList.length)[index % generateDistinctColors(metricsList.length).length]
                }));
                return { labels, datasets: datasetsForAlertCountChart, groupedData, groupedDataByLevel: groupedDataByLvl, alertMetricsList: metricsList, alertLevelsList: levelsList, totalAlertCountOverall: total, countByLevelOverall: lvlCounts, countByMetricOverall: metCounts };
            }
            function renderSummaryWidgets(summaryData) { /* ... (come v3) ... */
                totalAlertCountWidget.textContent = summaryData.totalAlertCountOverall || 0;
                levelBreakdownWidget.innerHTML = '';
                const lvlCounts = summaryData.countByLevelOverall || {}, totalAlerts = summaryData.totalAlertCountOverall || 0;
                const levels = Object.keys(lvlCounts).sort((a, b) => lvlCounts[b] - lvlCounts[a]);
                if (levels.length === 0 && totalAlerts === 0) { const li = document.createElement('li'); li.textContent = "Nessun dato livelli."; levelBreakdownWidget.appendChild(li); }
                else if (levels.length === 0 && totalAlerts > 0) { const li = document.createElement('li'); li.textContent = "Dettaglio livelli non disp."; levelBreakdownWidget.appendChild(li); }
                else { levels.forEach(lName => { const cnt = lvlCounts[lName], pct = totalAlerts > 0 ? (cnt / totalAlerts) * 100 : 0, li = document.createElement('li'); const lClass = lName.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]/g, ''); let bClass = 'other'; if (['warning', 'critical', 'exhausted', 'info', 'cleared'].includes(lClass)) bClass = lClass; li.innerHTML = `<span class="level-name">${lName}</span><div class="level-bar"><div class="level-bar-inner ${bClass}" style="width:${pct.toFixed(1)}%;"></div></div><span class="level-count">${cnt}</span>`; levelBreakdownWidget.appendChild(li); }); }
                topMetricsListWidget.innerHTML = '';
                const metCounts = summaryData.countByMetricOverall || {};
                const sortedMets = Object.keys(metCounts).map(mName => ({ name: mName, count: metCounts[mName] })).sort((a, b) => b.count - a.count).slice(0, 5);
                if (sortedMets.length === 0 && totalAlerts === 0) { const li = document.createElement('li'); li.textContent = "Nessun dato metriche."; topMetricsListWidget.appendChild(li); }
                else if (sortedMets.length === 0 && totalAlerts > 0) { const li = document.createElement('li'); li.textContent = "Dettaglio metriche non disp."; topMetricsListWidget.appendChild(li); }
                else { sortedMets.forEach(m => { const li = document.createElement('li'); li.innerHTML = `<span class="metric-name" title="${m.name}">${m.name}</span><span class="metric-count">${m.count}</span>`; topMetricsListWidget.appendChild(li); }); }
            }
            function getWeekStarts(datesArray) { /* ... (come v3) ... */
                if (!datesArray || datesArray.length === 0) return [];
                const validDates = datesArray.filter(d => d instanceof Date && !isNaN(d.getTime()) && isFinite(d.getTime()));
                if (validDates.length === 0) { console.warn("getWeekStarts: Nessuna data valida (finita) fornita."); return []; }
                const sortedDates = validDates.sort((a, b) => a.getTime() - b.getTime());
                console.log("getWeekStarts - Data minima valida:", sortedDates[0]?.toISOString(), "Data massima valida:", sortedDates[sortedDates.length - 1]?.toISOString());
                let currentMonday = getMonday(sortedDates[0]);
                if (isNaN(currentMonday.getTime())) { console.error("getWeekStarts: currentMonday iniziale è NaN per data:", sortedDates[0]); return []; }
                const maxMonday = getMonday(sortedDates[sortedDates.length - 1]);
                if (isNaN(maxMonday.getTime())) { console.error("getWeekStarts: maxMonday è NaN per data:", sortedDates[sortedDates.length - 1]); return []; }
                console.log("getWeekStarts - Primo lunedì:", currentMonday.toISOString(), "Ultimo lunedì:", maxMonday.toISOString());
                const weekStartsSet = new Set(); let safetyCounter = 0; const MAX_WEEKS_LIMIT = 5 * 52;
                let iterMonday = new Date(currentMonday.getTime());
                while (iterMonday.getTime() <= maxMonday.getTime()) {
                    weekStartsSet.add(iterMonday.toISOString().slice(0, 10));
                    iterMonday.setUTCDate(iterMonday.getUTCDate() + 7);
                    if (isNaN(iterMonday.getTime())) { console.error("getWeekStarts: iterMonday è diventato NaN nel loop."); break; }
                    safetyCounter++;
                    if (safetyCounter > MAX_WEEKS_LIMIT) { console.warn(`getWeekStarts: Raggiunto limite sicurezza ${MAX_WEEKS_LIMIT} settimane.`); break; }
                }
                console.log(`getWeekStarts - Settimane generate: ${weekStartsSet.size} (Safety counter: ${safetyCounter})`);
                return [...weekStartsSet];
            }
            function getMonday(date) { /* ... (come v3) ... */
                if (!(date instanceof Date) || isNaN(date.getTime())) { console.warn("getMonday ha ricevuto una data non valida:", date); return new Date(NaN); }
                const d = new Date(date.getTime()); d.setUTCHours(0,0,0,0);
                const dayOfWeek = d.getUTCDay(); const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                d.setUTCDate(d.getUTCDate() + diffToMonday);
                if (isNaN(d.getTime())) { console.error("getMonday ha prodotto NaN da input:", date, "con diff:", diffToMonday); }
                return d;
            }
            function formatDateRange(startDateStringYYYYMMDD) { /* ... (come v3) ... */
                if (!startDateStringYYYYMMDD) return '';
                try {
                    const startDate = new Date(startDateStringYYYYMMDD + 'T00:00:00.000Z');
                    const endDate = new Date(startDate); endDate.setUTCDate(endDate.getUTCDate() + 6);
                    const pad = (n) => String(n).padStart(2, '0');
                    return `${pad(startDate.getUTCDate())}/${pad(startDate.getUTCMonth() + 1)} - ${pad(endDate.getUTCDate())}/${pad(endDate.getUTCMonth() + 1)}`;
                } catch (e) { console.error("Errore formattazione range data:", startDateStringYYYYMMDD, e); return 'Data Invalida'; }
            }
            function generateDistinctColors(count) { /* ... (come v3) ... */
                if (count <= 0) return ['rgba(54, 162, 235, 0.8)'];
                const colors = []; const s = 0.7; const l = 0.6; const hueStep = count > 1 ? 360 / count : 0;
                for (let i = 0; i < count; i++) { colors.push(`hsla(${(i * hueStep + 200) % 360}, ${s * 100}%, ${l * 100}%, 0.8)`); }
                return colors;
            }
            function getLevelColor(levelName) { /* ... (come v3) ... */
                if (!levelName) return 'rgba(107, 114, 128, 0.8)';
                const cleanedLevel = levelName.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                switch (cleanedLevel) {
                    case 'warning': return 'rgba(252, 211, 77, 0.8)'; case 'critical': return 'rgba(239, 68, 68, 0.8)';
                    case 'exhausted': return 'rgba(167, 139, 250, 0.8)'; case 'info': return 'rgba(56, 178, 172, 0.8)';
                    case 'cleared': return 'rgba(52, 211, 153, 0.8)'; default: return 'rgba(156, 163, 175, 0.8)';
                }
            }

            function renderAlertCountChart(processedChartData) {
                const { labels = [], datasets = [] } = processedChartData || {};
                const canvas = document.getElementById('alertCountChart');
                const ctx = canvas.getContext('2d');
                if (alertCountChartInstance) { alertCountChartInstance.destroy(); alertCountChartInstance = null; }
                console.log("Dati per AlertCountChart:", JSON.parse(JSON.stringify({ labels, datasets })));
                if (labels.length === 0 || !datasets.some(ds => ds.data && ds.data.some(val => val > 0))) {
                     console.warn("Grafico Conteggio Alert: Nessun dato valido da visualizzare.");
                     ctx.clearRect(0, 0, canvas.width, canvas.height); return null;
                }
                const MAX_DATASETS_CHART = 20;
                let finalDatasets = datasets;
                if (datasets.length > MAX_DATASETS_CHART) {
                    console.warn(`Grafico Conteggio Alert: Troppi dataset (${datasets.length}). Visualizzo i primi ${MAX_DATASETS_CHART}.`);
                    finalDatasets = datasets.slice(0, MAX_DATASETS_CHART);
                }
                try {
                    alertCountChartInstance = new Chart(ctx, {
                        type: 'bar', data: { labels, datasets: finalDatasets },
                        options: {
                            responsive: false, // MODIFICATO PER DEBUG
                            // maintainAspectRatio: false, // Commentato per ora con responsive:false
                            animation: false,
                            scales: { x: { stacked: true, title: { display: true, text: 'Settimana Inizio Alert (Lun-Dom)' } },
                                      y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Numero di Alert' }, ticks: { precision: 0, callback: (v) => Number.isInteger(v) ? v : null } } },
                            plugins: {
                                legend: { position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle', padding: 20 } },
                                tooltip: { mode: 'index', intersect: false, callbacks: { label: (ti) => `${ti.dataset.label || ''}: ${ti.parsed.y} alert${ti.parsed.y === 1 ? '' : 's'}` } },
                                // Temporaneamente commentato per debug:
                                // datalabels: { display: (ctx) => ctx.dataset.data[ctx.dataIndex] > 0, color: 'white', anchor: 'center', align: 'center', font: { weight: 'bold', size: 10 }, formatter: (v) => v, textStrokeColor: 'rgba(0,0,0,0.7)', textStrokeWidth: 1.5 }
                            }
                        }
                    }); return alertCountChartInstance;
                } catch (e) { console.error('Errore rendering Grafico Conteggio Alert:', e); showMessage('Errore rendering Grafico Conteggio Alert.', 'error'); return null; }
            }

            function renderTotalDurationChart(processedChartData) {
                const { labels = [], groupedDataByLevel = {}, alertLevelsList = [] } = processedChartData || {};
                const canvas = document.getElementById('totalDurationChart');
                const ctx = canvas.getContext('2d');
                if (totalDurationChartInstance) { totalDurationChartInstance.destroy(); totalDurationChartInstance = null; }
                console.log("Dati per TotalDurationChart:", JSON.parse(JSON.stringify({ labels, groupedDataByLevel, alertLevelsList })));
                if (labels.length === 0 || alertLevelsList.length === 0) { console.warn("Grafico Durata Totale: Nessun dato (etichette/livelli)."); ctx.clearRect(0, 0, canvas.width, canvas.height); return null; }
                const levelOrder = ['Critical', 'Warning', 'Exhausted', 'Info', 'Cleared'];
                const sortedLevels = [...new Set([...levelOrder.filter(l => alertLevelsList.includes(l)), ...alertLevelsList])];
                const datasets = sortedLevels.map(lName => ({
                    label: lName, data: labels.map(lbl => groupedDataByLevel?.[lbl]?.[lName]?.totalDuration || 0),
                    backgroundColor: getLevelColor(lName), borderColor: getLevelColor(lName).replace(',0.8)', ',1)'), borderWidth: 1
                }));
                if (!datasets.some(ds => ds.data && ds.data.some(val => val > 0.01))) { console.warn("Grafico Durata Totale: Nessuna durata significativa."); ctx.clearRect(0, 0, canvas.width, canvas.height); return null; }
                let yAxisMax = Math.max(0, ...labels.map(lbl => sortedLevels.reduce((s, lName) => s + (groupedDataByLevel?.[lbl]?.[lName]?.totalDuration || 0), 0))) * 1.15 || 10;
                if (!isFinite(yAxisMax)) { console.error("yAxisMax per TotalDurationChart è non finito!", yAxisMax); yAxisMax = 100; }
                console.log("Y-Axis Max per TotalDurationChart:", yAxisMax);
                try {
                    totalDurationChartInstance = new Chart(ctx, {
                        type: 'bar', data: { labels, datasets },
                        options: {
                            responsive: false, // MODIFICATO PER DEBUG
                            // maintainAspectRatio: false, // Commentato per ora con responsive:false
                            animation: false,
                            scales: { x: { stacked: true, title: { display: true, text: 'Settimana Inizio Alert (Lun-Dom)' } },
                                      y: { stacked: true, beginAtZero: true, max: yAxisMax, title: { display: true, text: 'Somma Durate (ore)' }, ticks: { precision: 1 } } },
                            plugins: {
                                legend: { display: true, position: 'bottom', labels: { usePointStyle: true, pointStyle: 'circle', padding: 20 } },
                                tooltip: { mode: 'index', intersect: false, callbacks: { label: (ti) => `${ti.dataset.label || ''}: ${ti.parsed.y.toFixed(1)} ore`, footer: (tis) => `Totale: ${tis.reduce((s, i) => s + i.parsed.y, 0).toFixed(1)} ore` } },
                                // Temporaneamente commentato per debug:
                                // datalabels: { display: (ctx) => ctx.dataset.data[ctx.dataIndex] > 0.1, anchor: 'center', align: 'center', color: 'white', font: { weight: 'bold', size: 10 }, formatter: (v) => v < 0.1 ? '' : v.toFixed(v >= 1 ? 1 : 1), textStrokeColor: 'rgba(0,0,0,0.7)', textStrokeWidth: 1.5 }
                            }
                        }
                    }); return totalDurationChartInstance;
                } catch (e) { console.error('Errore rendering Grafico Durata Totale:', e); showMessage('Errore rendering Grafico Durata Totale.', 'error'); return null; }
            }
        });
    </script>
</body>
</html>
