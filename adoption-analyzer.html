<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Adoption Analyzer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --primary: #0ea5e9;
      --primary-dark: #0284c7;
      --success: #15803d;
      --warning: #b45309;
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #64748b;
      --border: rgba(148, 163, 184, 0.35);
      --shadow: 0 24px 48px rgba(15, 23, 42, 0.1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    body {
      background: linear-gradient(160deg, #e2e8f0, #f8fafc 45%, #ffffff 100%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    a {
      color: var(--primary);
    }

    .page-header {
      padding: 3rem 5vw 1.5rem;
      display: grid;
      gap: 1.25rem;
      max-width: 1300px;
      margin: 0 auto;
    }

    .page-header h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 700;
    }

    .page-header p {
      color: var(--muted);
      max-width: 880px;
      line-height: 1.6;
      font-size: 1rem;
    }

    .status-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--muted);
      font-size: 0.9rem;
      background: rgba(14, 165, 233, 0.12);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      width: fit-content;
    }

    main {
      padding: 0 5vw;
      display: grid;
      gap: 2rem;
      max-width: 1300px;
      margin: 0 auto;
    }

    .panel {
      background: var(--surface);
      border-radius: 1.25rem;
      padding: 1.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      display: grid;
      gap: 1.25rem;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .panel-header h2 {
      font-size: 1.35rem;
      font-weight: 700;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      background: var(--surface-alt);
      color: var(--muted);
      font-weight: 600;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
    }

    .helper-text {
      color: var(--muted);
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .data-loader {
      display: grid;
      gap: 1.25rem;
    }

    .form-grid {
      display: grid;
      gap: 1.25rem;
    }

    @media (min-width: 720px) {
      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: end;
      }
    }

    .form-group {
      display: grid;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text);
    }

    .form-group select,
    .form-group input[type="file"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .form-group input[type="file"] {
      padding: 0.55rem 1rem;
    }

    .load-button {
      justify-self: start;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    .load-button:disabled {
      background: var(--surface-alt);
      color: var(--muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    .summary-grid {
      display: grid;
      gap: 1rem;
      overflow-x: auto;
    }

    .license-chart-section {
      display: grid;
      gap: 1.25rem;
      border-top: 1px solid var(--border);
      padding-top: 1.75rem;
      margin-top: 1.75rem;
    }

    .license-chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .license-chart-controls {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .license-chart-add-button {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.2rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 24px rgba(14, 165, 233, 0.35);
    }

    .license-chart-add-button:hover,
    .license-chart-add-button:focus {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(14, 165, 233, 0.45);
    }

    .license-chart-grid {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    @media (max-width: 1080px) {
      .license-chart-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      .license-chart-grid {
        grid-template-columns: 1fr;
      }
    }

    .license-chart-card {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      display: grid;
      gap: 1.25rem;
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.12);
      position: relative;
      min-width: 0;
    }

    .license-chart-card-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 1.1rem;
      font-weight: 600;
      line-height: 1;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 999px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .license-chart-card-close:hover,
    .license-chart-card-close:focus {
      background: rgba(15, 23, 42, 0.08);
      color: var(--text);
    }

    .license-chart-card-header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      word-break: break-word;
    }

    .license-chart-card-header h3 {
      font-size: 1.15rem;
      font-weight: 700;
      color: var(--text);
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .license-chart-meta {
      color: var(--muted);
      font-size: 0.9rem;
      word-break: break-word;
      white-space: normal;
    }

    .license-chart-figure {
      position: relative;
      height: 220px;
    }

    .license-chart-figure canvas {
      position: absolute;
      inset: 0;
    }

    .license-chart-metrics {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .license-chart-metric {
      display: grid;
      gap: 0.25rem;
    }

    .license-chart-metric-label {
      font-size: 0.8rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .license-chart-metric-value {
      font-size: 1.35rem;
      font-weight: 700;
      color: var(--text);
    }

    .summary-controls {
      display: flex;
      justify-content: flex-end;
    }

    .summary-controls input[type="search"] {
      width: min(100%, 320px);
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.55rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .summary-controls input[type="search"]::placeholder {
      color: var(--muted);
    }

    .summary-accordion {
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 0.85rem 1rem;
      background: var(--surface-alt);
      max-width: 100%;
      min-width: 0;
    }

    .summary-accordion+.summary-accordion {
      margin-top: 0.75rem;
    }

    .summary-accordion>summary {
      cursor: pointer;
      list-style: none;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .summary-accordion>summary::-webkit-details-marker {
      display: none;
    }

    .summary-accordion>summary::after {
      content: '▾';
      font-size: 0.8rem;
      color: var(--muted);
      transition: transform 0.2s ease;
    }

    .summary-accordion[open]>summary::after {
      transform: rotate(180deg);
    }

    .summary-accordion.level2 {
      margin-top: 0.75rem;
      background: var(--surface);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    .summary-accordion.level2>summary {
      font-weight: 500;
      font-size: 0.95rem;
    }

    .summary-count {
      color: var(--muted);
      font-size: 0.85rem;
      font-weight: 500;
    }

    .summary-accordion .summary-table {
      margin-top: 0.75rem;
    }

    .summary-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px;
    }

    .summary-table thead {
      background: var(--surface-alt);
    }

    .summary-table th,
    .summary-table td {
      text-align: left;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.9rem;
    }

    .summary-table td:not(.summary-action-cell) {
      word-break: break-word;
      white-space: normal;
      max-width: 240px;
    }

    .summary-action-cell {
      white-space: nowrap;
      word-break: keep-all;
      max-width: none;
    }

    .summary-action-button {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.45rem 0.95rem;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 6px 16px rgba(14, 165, 233, 0.25);
    }

    .summary-action-button:hover,
    .summary-action-button:focus {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(14, 165, 233, 0.35);
    }

    .summary-table th {
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.8rem;
    }

    .summary-table tbody tr:hover {
      background: rgba(14, 165, 233, 0.08);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .filters select,
    .filters input[type="search"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.55rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .filters input[type="search"]::placeholder {
      color: var(--muted);
    }

    .table-wrapper {
      overflow-x: auto;
      border-radius: 1rem;
      border: 1px solid var(--border);
    }

    table.data-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px;
    }

    table.data-table thead th {
      background: var(--surface-alt);
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    table.data-table tbody td {
      padding: 0.85rem 1rem;
      border-top: 1px solid var(--border);
      font-size: 0.95rem;
    }

    table.data-table tbody tr:nth-child(even) {
      background: rgba(148, 163, 184, 0.08);
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.95rem;
      padding: 1rem 0;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
    }

    .badge.up {
      color: var(--success);
      background: rgba(21, 128, 61, 0.12);
    }

    .badge.down {
      color: var(--danger);
      background: rgba(185, 28, 28, 0.12);
    }

    .timeline-table {
      min-width: 640px;
    }

    @media (max-width: 640px) {

      .page-header,
      main {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }
  </style>
</head>

<body>
  <header class="page-header">
    <div>
      <h1>Adoption Analyzer</h1>
      <p>
        Upload an adoption workbook exported from Customer Success Score to explore activation, usage, and messaging
        metrics across every Salesforce organization. Use the selectors to focus on the snapshot, tenant, and account
        you want to investigate.
      </p>
    </div>
    <div class="status-chips">
      <span class="status-chip">Snapshot: <strong id="selectedSnapshot">Not selected</strong></span>
      <span class="status-chip">Tenant: <strong id="selectedTenant">Not selected</strong></span>
      <span class="status-chip">Account: <strong id="selectedAccount">Not selected</strong></span>
      <span class="status-chip">Account ID: <strong id="selectedAccountId">Not selected</strong></span>
      <span class="status-chip">Org ID: <strong id="selectedOrgId">Not selected</strong></span>
    </div>
  </header>

  <main>
    <section class="panel" id="dataLoaderPanel">
      <h2>Load adoption workbook</h2>
      <div class="data-loader">
        <div class="form-grid">
          <div class="form-group">
            <label for="snapshotSelect">Snapshot date</label>
            <select id="snapshotSelect" disabled>
              <option value="" disabled selected>Upload a workbook to populate dates</option>
            </select>
          </div>
          <div class="form-group">
            <label for="tenantSelect">Tenant</label>
            <select id="tenantSelect" disabled>
              <option value="" disabled selected>Select a snapshot first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="accountSelect">Account</label>
            <select id="accountSelect" disabled>
              <option value="" disabled selected>Select a snapshot first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="adoptionUpload">Upload adoption workbook</label>
            <input type="file" id="adoptionUpload"
              accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
          </div>
        </div>
        <button class="load-button" type="button" id="loadWorkbookBtn" disabled>Load data</button>
        <p class="helper-text" id="uploadStatus">Upload an adoption workbook to begin the analysis.</p>
      </div>
    </section>

    <section class="panel" id="summarySection">
      <div class="panel-header">
        <h2>Snapshot summary</h2>
        <span class="pill" id="snapshotPill">Snapshot not selected</span>
      </div>
      <div class="summary-controls">
        <input type="search" id="summarySearch" placeholder="Search summary data" disabled />
      </div>
      <p class="helper-text" id="summaryStatus">Upload an adoption workbook to begin the analysis.</p>
      <div class="summary-grid" id="summaryCards" hidden></div>
      <div class="license-chart-section" id="licenseChartSection" hidden>
        <div class="license-chart-header">
          <h3>License adoption overview</h3>
          <div class="license-chart-controls">
            <button type="button" class="license-chart-add-button" id="manualChartButton">Add manually</button>
            <span class="pill" id="licenseChartCount">--</span>
          </div>
        </div>
        <p class="helper-text" id="licenseChartStatus">Upload an adoption workbook to begin the analysis.</p>
        <div class="license-chart-grid" id="licenseChartRoot"></div>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>Adoption metrics by SKU</h2>
        <span class="pill" id="adoptionCountPill">--</span>
      </div>
      <p class="helper-text">
        Review provisioning, activation, and usage metrics for every license and account. Apply the filters to focus on
        specific groups, product types, or APM levels.
      </p>
      <div class="filters">
        <input type="search" id="adoptionSearch" placeholder="Search by account, org, group, or SKU" />
        <select id="groupFilter" disabled>
          <option value="" disabled selected>No groups available</option>
        </select>
        <select id="typeFilter" disabled>
          <option value="" disabled selected>No types available</option>
        </select>
        <select id="apmFilter" disabled>
          <option value="" disabled selected>No APM levels available</option>
        </select>
      </div>
      <p class="helper-text" id="adoptionResultsLabel"></p>
      <div class="table-wrapper">
        <table class="data-table" id="adoptionTable">
          <thead>
            <tr>
              <th>Group</th>
              <th>Type</th>
              <th>Provisioned</th>
              <th>Activated</th>
              <th>Used</th>
              <th>EU</th>
              <th>MAU Penetration</th>
              <th>Shelfware</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>Adoption scorecard</h2>
        <span class="pill" id="scorecardCountPill">--</span>
      </div>
      <p class="helper-text">
        The scorecard summarizes KPIs from the executive dashboards. Track trends and month-over-month changes across
        each cloud.
      </p>
      <div class="filters">
        <input type="search" id="scorecardSearch" placeholder="Search metrics or accounts" />
        <select id="cloudFilter" disabled>
          <option value="all">Cloud: all</option>
        </select>
      </div>
      <div class="table-wrapper">
        <table class="data-table" id="scorecardTable">
          <thead>
            <tr>
              <th>Cloud</th>
              <th>Metric Name</th>
              <th>Metric Value</th>
              <th>MoM %</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>MCMU messaging</h2>
        <span class="pill" id="mcmuCountPill">--</span>
      </div>
      <p class="helper-text">
        Review historical super message and contact provisioning to correlate Marketing Cloud activity with adoption
        metrics.
      </p>
      <div class="table-wrapper">
        <table class="data-table timeline-table" id="mcmuTable">
          <thead>
            <tr>
              <th>Snapshot Date</th>
              <th>Account</th>
              <th>Super Messages Provisioned</th>
              <th>Super Messages Used</th>
              <th>Contacts Provisioned</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    const DEFAULT_FILTERS = {
      adoptionSearch: '',
      group: 'all',
      type: 'all',
      apm: 'all',
      scorecardSearch: '',
      cloud: 'all',
      summarySearch: '',
    };

    const LICENSE_CHART_COLORS = {
      provisioned: '#3b82f6',
      activated: '#60a5fa',
      used: '#fcd34d',
    };

    const state = {
      adoption: [],
      adoptionAll: [],
      scorecard: [],
      scorecardAll: [],
      mcmu: [],
      mcmuAll: [],
      core: [],
      coreAll: [],
      coreHeaders: [],
      licenseChartInstances: [],
      licenseChartAggregates: new Map(),
      licenseChartCards: new Map(),
      filters: { ...DEFAULT_FILTERS },
      selection: { snapshot: '', tenant: 'all', account: 'all', accountId: '', orgId: '' },
      datasetLoaded: false,
    };

    const dom = {
      selectedSnapshot: document.getElementById('selectedSnapshot'),
      selectedTenant: document.getElementById('selectedTenant'),
      selectedAccount: document.getElementById('selectedAccount'),
      selectedAccountId: document.getElementById('selectedAccountId'),
      selectedOrgId: document.getElementById('selectedOrgId'),
      snapshotSelect: document.getElementById('snapshotSelect'),
      tenantSelect: document.getElementById('tenantSelect'),
      accountSelect: document.getElementById('accountSelect'),
      uploadInput: document.getElementById('adoptionUpload'),
      loadButton: document.getElementById('loadWorkbookBtn'),
      uploadStatus: document.getElementById('uploadStatus'),
      snapshotPill: document.getElementById('snapshotPill'),
      summaryStatus: document.getElementById('summaryStatus'),
      summaryCards: document.getElementById('summaryCards'),
      summarySearch: document.getElementById('summarySearch'),
      licenseChartSection: document.getElementById('licenseChartSection'),
      licenseChartRoot: document.getElementById('licenseChartRoot'),
      licenseChartStatus: document.getElementById('licenseChartStatus'),
      licenseChartCount: document.getElementById('licenseChartCount'),
      manualChartButton: document.getElementById('manualChartButton'),
      adoptionTableBody: document.querySelector('#adoptionTable tbody'),
      adoptionResultsLabel: document.getElementById('adoptionResultsLabel'),
      adoptionCountPill: document.getElementById('adoptionCountPill'),
      adoptionSearch: document.getElementById('adoptionSearch'),
      groupFilter: document.getElementById('groupFilter'),
      typeFilter: document.getElementById('typeFilter'),
      apmFilter: document.getElementById('apmFilter'),
      scorecardTableBody: document.querySelector('#scorecardTable tbody'),
      scorecardCountPill: document.getElementById('scorecardCountPill'),
      scorecardSearch: document.getElementById('scorecardSearch'),
      cloudFilter: document.getElementById('cloudFilter'),
      mcmuTableBody: document.querySelector('#mcmuTable tbody'),
      mcmuCountPill: document.getElementById('mcmuCountPill'),
    };

    const isBlank = (value) =>
      value === null || value === undefined || (typeof value === 'string' && value.trim() === '');

    const parseSheet = (workbook, sheetName) => {
      const sheet = workbook.Sheets[sheetName];
      if (!sheet) return { headers: [], rows: [] };
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });
      const headerIndex = raw.findIndex((row) => Array.isArray(row) && row.some((cell) => !isBlank(cell)));
      if (headerIndex === -1) return { headers: [], rows: [] };
      const headers = raw[headerIndex].map((cell) => (isBlank(cell) ? '' : String(cell).trim()));
      const rows = [];
      for (let i = headerIndex + 1; i < raw.length; i += 1) {
        const row = raw[i];
        if (!Array.isArray(row) || row.every((cell) => isBlank(cell))) {
          continue;
        }
        const entry = {};
        headers.forEach((header, index) => {
          if (!header) return;
          entry[header] = index < row.length ? row[index] : null;
        });
        rows.push(entry);
      }
      return { headers, rows };
    };

    const normalizeNumber = (value) => {
      if (value === null || value === undefined || value === '') return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      const sanitized = String(value)
        .replace(/[^0-9.,-]/g, '')
        .replace(/,(?=\d{3}\b)/g, '');
      const normalized = sanitized.replace(/,/g, '.');
      const parsed = Number(normalized);
      return Number.isFinite(parsed) ? parsed : null;
    };

    const formatNumber = (value, options = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatter = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: options.maximumFractionDigits ?? 0,
        minimumFractionDigits: options.minimumFractionDigits ?? 0,
      });
      return formatter.format(value);
    };

    const formatPercent = (value, options = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatter = new Intl.NumberFormat('en-US', {
        style: 'percent',
        maximumFractionDigits: options.maximumFractionDigits ?? 1,
        minimumFractionDigits: options.minimumFractionDigits ?? 0,
      });
      return formatter.format(value);
    };

    const formatEngagement = (value) => {
      const numeric = normalizeNumber(value);
      if (!Number.isFinite(numeric)) return '—';
      if (numeric <= 1) {
        return formatPercent(numeric, { maximumFractionDigits: 1, minimumFractionDigits: 0 });
      }
      return formatNumber(numeric);
    };

    const updateLicenseChartStatus = (overrideMessage) => {
      const cardCount = state.licenseChartCards instanceof Map ? state.licenseChartCards.size : 0;
      const hasAggregates = state.licenseChartAggregates instanceof Map && state.licenseChartAggregates.size > 0;

      if (dom.licenseChartCount) {
        if (!state.datasetLoaded) {
          dom.licenseChartCount.textContent = '--';
        } else {
          dom.licenseChartCount.textContent = cardCount ? formatNumber(cardCount) : '0';
        }
      }

      if (dom.licenseChartStatus) {
        if (overrideMessage) {
          dom.licenseChartStatus.textContent = overrideMessage;
        } else if (!state.datasetLoaded && cardCount === 0) {
          dom.licenseChartStatus.textContent = 'Upload an adoption workbook to begin the analysis.';
        } else if (cardCount === 0) {
          dom.licenseChartStatus.textContent = hasAggregates
            ? 'Select “Chart” on any summary or adoption row to visualize license metrics, or add one manually.'
            : 'No license metrics available for the selected filters.';
        } else {
          dom.licenseChartStatus.textContent = 'License metrics for selected summary or adoption rows.';
        }
      }
    };

    const parseDate = (value) => {
      if (value instanceof Date && !Number.isNaN(value.getTime())) {
        return value;
      }
      const numeric = normalizeNumber(value);
      if (Number.isFinite(numeric) && numeric > 40000) {
        const parsed = XLSX.SSF.parse_date_code(numeric);
        if (parsed) {
          return new Date(parsed.y, (parsed.m || 1) - 1, parsed.d || 1, parsed.H || 0, parsed.M || 0, parsed.S || 0);
        }
      }
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    };

    const formatDate = (value) => {
      if (!(value instanceof Date) || Number.isNaN(value.getTime())) {
        return '';
      }
      const options = { year: 'numeric', month: 'short', day: '2-digit' };
      return new Intl.DateTimeFormat('en-US', options).format(value);
    };

    const toIsoString = (date) => {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
      return date.toISOString();
    };

    const SUMMARY_HIDDEN_COLUMNS = new Set([
      'Account Name',
      'Account Name (Local)',
      'ACCOUNT ID',
      'ORG ID',
      'Total Provisioned',
      'Entitlement Utilization',
      'SNAPSHOT_DT',
    ]);
    const SUMMARY_LEVEL_COLUMNS = ['Level 1 Cloud', 'Level 2 Cloud'];
    const SUMMARY_PERCENT_COLUMNS = new Set(['License Activation', 'True Login Percentage']);

    const getLicenseTypeLabel = (row) => {
      if (!row || typeof row !== 'object') return 'Not specified';
      const rawType = !isBlank(row.Type) ? row.Type : row[' Type'];
      return !isBlank(rawType) ? String(rawType) : 'Not specified';
    };

    const getSummaryCellValue = (header, row) => {
      if (header === 'SNAPSHOT_DT') {
        const dateValue = parseDate(row[header]) || row.__snapshotDate;
        if (dateValue instanceof Date && !Number.isNaN(dateValue.getTime())) {
          return formatDate(dateValue);
        }
      }
      const rawValue = row[header];
      if (rawValue === null || rawValue === undefined || rawValue === '') {
        return '';
      }
      if (SUMMARY_PERCENT_COLUMNS.has(header)) {
        const numeric = normalizeNumber(rawValue);
        if (Number.isFinite(numeric)) {
          const ratio = numeric > 1 ? numeric / 100 : numeric;
          return formatPercent(ratio, { maximumFractionDigits: 1, minimumFractionDigits: 0 });
        }
        return '';
      }
      return String(rawValue);
    };

    const createSummaryTable = (headers, rows) => {
      if (!headers.length || !rows.length) return null;

      const table = document.createElement('table');
      table.className = 'summary-table';

      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      headers.forEach((header) => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.append(th);
      });
      const actionsTh = document.createElement('th');
      actionsTh.textContent = 'Actions';
      headerRow.append(actionsTh);
      thead.append(headerRow);
      table.append(thead);

      const tbody = document.createElement('tbody');
      rows.forEach((row) => {
        const tr = document.createElement('tr');
        headers.forEach((header) => {
          const td = document.createElement('td');
          const value = getSummaryCellValue(header, row);
          td.textContent = value || '—';
          tr.append(td);
        });
        const actionCell = document.createElement('td');
        actionCell.className = 'summary-action-cell';
        const chartButton = document.createElement('button');
        chartButton.type = 'button';
        chartButton.className = 'summary-action-button';
        chartButton.textContent = 'Chart';
        chartButton.addEventListener('click', () => {
          handleSummaryChartRequest(row);
        });
        actionCell.append(chartButton);
        tr.append(actionCell);
        tbody.append(tr);
      });

      table.append(tbody);
      return table;
    };

    const resetSelect = (select, placeholder) => {
      if (!select) return;
      select.innerHTML = `<option value="" disabled selected>${placeholder}</option>`;
      select.disabled = true;
    };

    const destroyLicenseCharts = () => {
      if (Array.isArray(state.licenseChartInstances) && state.licenseChartInstances.length) {
        state.licenseChartInstances.forEach((chart) => {
          if (chart && typeof chart.destroy === 'function') {
            chart.destroy();
          }
        });
      }
      state.licenseChartInstances = [];
      if (state.licenseChartCards instanceof Map) {
        state.licenseChartCards.clear();
      }
      state.licenseChartAggregates = new Map();
      if (dom.licenseChartRoot) {
        dom.licenseChartRoot.innerHTML = '';
      }
    };

    const clearVisualizations = (message) => {
      if (dom.summaryCards) {
        dom.summaryCards.hidden = true;
        dom.summaryCards.innerHTML = '';
      }
      if (dom.summarySearch) {
        dom.summarySearch.value = '';
        dom.summarySearch.disabled = true;
      }
      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = message;
      }
      if (dom.adoptionTableBody) {
        dom.adoptionTableBody.innerHTML = `<tr><td colspan="9" class="empty-state">${message}</td></tr>`;
      }
      if (dom.adoptionResultsLabel) {
        dom.adoptionResultsLabel.textContent = '';
      }
      if (dom.adoptionCountPill) {
        dom.adoptionCountPill.textContent = '--';
      }
      if (dom.scorecardTableBody) {
        dom.scorecardTableBody.innerHTML = `<tr><td colspan="5" class="empty-state">${message}</td></tr>`;
      }
      if (dom.scorecardCountPill) {
        dom.scorecardCountPill.textContent = '--';
      }
      if (dom.mcmuTableBody) {
        dom.mcmuTableBody.innerHTML = `<tr><td colspan="5" class="empty-state">${message}</td></tr>`;
      }
      if (dom.mcmuCountPill) {
        dom.mcmuCountPill.textContent = '--';
      }
      if (dom.snapshotPill) {
        dom.snapshotPill.textContent = 'Snapshot not selected';
      }
      destroyLicenseCharts();
      updateLicenseChartStatus(message);
      if (dom.licenseChartSection) {
        dom.licenseChartSection.hidden = true;
      }
    };

    const updateSelectionLabels = ({ snapshotText, tenantText, accountText, accountIdText, orgIdText } = {}) => {
      if (dom.selectedSnapshot) {
        if (snapshotText) {
          dom.selectedSnapshot.textContent = snapshotText;
        } else if (state.selection.snapshot) {
          const date = new Date(state.selection.snapshot);
          dom.selectedSnapshot.textContent = formatDate(date) || state.selection.snapshot;
        } else {
          dom.selectedSnapshot.textContent = 'Not selected';
        }
      }
      if (dom.selectedTenant) {
        if (tenantText) {
          dom.selectedTenant.textContent = tenantText;
        } else if (state.selection.snapshot) {
          dom.selectedTenant.textContent =
            state.selection.tenant === 'all' ? 'All tenants' : state.selection.tenant || 'Not specified';
        } else {
          dom.selectedTenant.textContent = 'Not selected';
        }
      }
      if (dom.selectedAccount) {
        if (accountText) {
          dom.selectedAccount.textContent = accountText;
        } else if (state.selection.snapshot) {
          if (state.selection.account === 'all') {
            dom.selectedAccount.textContent = 'All accounts';
          } else {
            const match = state.adoptionAll.find((row) => row.__accountKey === state.selection.account);
            dom.selectedAccount.textContent = match?.__accountLabel || state.selection.account;
          }
        } else {
          dom.selectedAccount.textContent = 'Not selected';
        }
      }
      if (dom.selectedAccountId) {
        if (accountIdText) {
          dom.selectedAccountId.textContent = accountIdText;
        } else if (state.selection.snapshot) {
          if (state.selection.account === 'all') {
            dom.selectedAccountId.textContent = 'All accounts';
          } else if (state.selection.accountId) {
            dom.selectedAccountId.textContent = state.selection.accountId;
          } else {
            dom.selectedAccountId.textContent = 'Not specified';
          }
        } else {
          dom.selectedAccountId.textContent = 'Not selected';
        }
      }
      if (dom.selectedOrgId) {
        if (orgIdText) {
          dom.selectedOrgId.textContent = orgIdText;
        } else if (state.selection.snapshot) {
          if (state.selection.account === 'all') {
            dom.selectedOrgId.textContent = 'All orgs';
          } else if (state.selection.orgId) {
            dom.selectedOrgId.textContent = state.selection.orgId;
          } else {
            dom.selectedOrgId.textContent = 'Not specified';
          }
        } else {
          dom.selectedOrgId.textContent = 'Not selected';
        }
      }
    };

    const collectSnapshots = () => {
      const snapshotMap = new Map();
      const addSnapshot = (iso, date) => {
        if (!iso) return;
        if (!snapshotMap.has(iso)) {
          const parsed = date instanceof Date && !Number.isNaN(date.getTime()) ? date : new Date(iso);
          snapshotMap.set(iso, parsed);
        }
      };
      [state.adoptionAll, state.scorecardAll, state.mcmuAll, state.coreAll].forEach((rows) => {
        rows.forEach((row) => addSnapshot(row.__snapshot, row.__snapshotDate));
      });
      return Array.from(snapshotMap.entries())
        .map(([iso, date]) => ({ iso, date }))
        .sort((a, b) => {
          const aTime = a.date instanceof Date && !Number.isNaN(a.date.getTime()) ? a.date.getTime() : 0;
          const bTime = b.date instanceof Date && !Number.isNaN(b.date.getTime()) ? b.date.getTime() : 0;
          return bTime - aTime;
        });
    };

    const populateSnapshotOptions = () => {
      if (!dom.snapshotSelect) return;
      const snapshots = collectSnapshots();
      if (!snapshots.length) {
        dom.snapshotSelect.innerHTML = '<option value="" disabled selected>Upload a workbook to populate dates</option>';
        dom.snapshotSelect.disabled = true;
        return;
      }
      dom.snapshotSelect.innerHTML = '<option value="" disabled selected>-- Select snapshot date --</option>';
      snapshots.forEach(({ iso, date }) => {
        const option = document.createElement('option');
        option.value = iso;
        option.textContent = date instanceof Date && !Number.isNaN(date.getTime()) ? formatDate(date) : iso;
        dom.snapshotSelect.append(option);
      });
      dom.snapshotSelect.disabled = false;

      // Auto-select the first snapshot if available
      if (dom.snapshotSelect.options.length > 1) {
        dom.snapshotSelect.selectedIndex = 1;
        dom.snapshotSelect.dispatchEvent(new Event('change'));
      }
    };

    const populateTenantOptions = (snapshot) => {
      if (!dom.tenantSelect) return;
      if (!snapshot) {
        resetSelect(dom.tenantSelect, state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate tenants');
        resetSelect(
          dom.accountSelect,
          state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate accounts'
        );
        updateLoadButtonState();
        return;
      }
      const tenants = new Set();
      state.adoptionAll.forEach((row) => {
        if (row.__snapshot === snapshot) {
          tenants.add(row.__tenant || 'Not specified');
        }
      });
      if (!tenants.size) {
        dom.tenantSelect.innerHTML = '<option value="" disabled selected>No tenants for the selected snapshot</option>';
        dom.tenantSelect.disabled = true;
        resetSelect(dom.accountSelect, 'No accounts for the selected filters');
        updateLoadButtonState();
        return;
      }
      dom.tenantSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'All tenants';
      dom.tenantSelect.append(allOption);
      Array.from(tenants)
        .sort((a, b) => a.localeCompare(b))
        .forEach((tenant) => {
          const option = document.createElement('option');
          option.value = tenant;
          option.textContent = tenant;
          dom.tenantSelect.append(option);
        });
      dom.tenantSelect.disabled = false;

      // const forceTenantOption = Array.from(dom.tenantSelect.options).find(
      //   (option) => option.value.toLowerCase() === 'force.com'
      // );
      // Auto-select the first available option to keep the dropdown in sync with the snapshot
      if (dom.tenantSelect.options.length > 0) {
        dom.tenantSelect.selectedIndex = 0;
        dom.tenantSelect.dispatchEvent(new Event('change'));
      }

      populateAccountOptions(snapshot, 'all');
    };

    const populateAccountOptions = (snapshot, tenant = 'all') => {
      if (!dom.accountSelect) return;
      if (!snapshot) {
        resetSelect(dom.accountSelect, state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate accounts');
        updateLoadButtonState();
        return;
      }
      const accounts = new Map();
      state.adoptionAll.forEach((row) => {
        if (row.__snapshot !== snapshot) return;
        const tenantLabel = row.__tenant || 'Not specified';
        if (tenant !== 'all' && tenantLabel !== tenant) return;
        const key = row.__accountKey || row.__accountId || row.__accountLabel;
        if (!key) return;
        if (!accounts.has(key)) {
          accounts.set(key, row.__accountLabel || row.__accountName || key);
        }
      });
      if (!accounts.size) {
        dom.accountSelect.innerHTML = '<option value="" disabled selected>No accounts for the selected filters</option>';
        dom.accountSelect.disabled = true;
        updateLoadButtonState();
        return;
      }
      dom.accountSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'All accounts';
      dom.accountSelect.append(allOption);
      Array.from(accounts.entries())
        .sort((a, b) => a[1].localeCompare(b[1]))
        .forEach(([key, label]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = label;
          dom.accountSelect.append(option);
        });
      dom.accountSelect.disabled = false;
      dom.accountSelect.value = 'all';
      updateLoadButtonState();
    };

    const updateLoadButtonState = () => {
      if (!dom.loadButton) return;
      const hasDataset = state.datasetLoaded;
      const snapshotSelected = Boolean(dom.snapshotSelect && dom.snapshotSelect.value);
      const accountSelected =
        dom.accountSelect && !dom.accountSelect.disabled && Boolean(dom.accountSelect.value);
      dom.loadButton.disabled = !(hasDataset && snapshotSelected && accountSelected);
    };
    const parseWorkbookData = (arrayBuffer) => {
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const adoptionSheet = parseSheet(workbook, 'Adoption Metrics');
      const scorecardSheet = parseSheet(workbook, 'Adoption Scorecard');
      const mcmuSheet = parseSheet(workbook, 'MCMU Report');
      const coreSheet = parseSheet(workbook, 'Core By OrgID');

      const snapshotByOrg = new Map();
      const snapshotByAccount = new Map();
      const snapshotSet = new Set();

      const coreRows = coreSheet.rows.map((row) => {
        const snapshotDate = parseDate(row.SNAPSHOT_DT);
        const snapshotIso = toIsoString(snapshotDate);
        if (snapshotIso) snapshotSet.add(snapshotIso);
        const accountId = !isBlank(row['ACCOUNT ID']) ? String(row['ACCOUNT ID']) : '';
        const accountName = row['Account Name'] || row['Account Name (Local)'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const augmented = {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountId || accountName || 'unknown-account',
          __tenant: 'Not specified',
        };
        const orgId = !isBlank(row['ORG ID']) ? String(row['ORG ID']) : null;
        if (orgId && snapshotIso) snapshotByOrg.set(orgId, snapshotIso);
        if (accountId && snapshotIso) snapshotByAccount.set(accountId, snapshotIso);
        return augmented;
      });

      const tenantByAccount = new Map();

      const adoptionRows = adoptionSheet.rows.map((row, index) => {
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const orgId = !isBlank(row['Org ID']) ? String(row['Org ID']) : '';
        const tenant = !isBlank(row['Company Name']) ? String(row['Company Name']) : 'Not specified';
        const accountName = row['Account Name'] || row['Account Local Name'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const snapshotIso = snapshotByOrg.get(orgId) || snapshotByAccount.get(accountId) || null;
        const snapshotDate = snapshotIso ? new Date(snapshotIso) : null;
        const accountKey = accountId || accountName || orgId || `unknown-account-${index}`;
        if (accountId) tenantByAccount.set(accountId, tenant);
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      const scorecardRows = scorecardSheet.rows.map((row, index) => {
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const orgId = !isBlank(row['Org ID']) ? String(row['Org ID']) : '';
        const tenant = tenantByAccount.get(accountId) || 'Not specified';
        const accountName = row['Account Local Name'] || row['Account ID'] || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const snapshotIso = snapshotByOrg.get(orgId) || snapshotByAccount.get(accountId) || null;
        const snapshotDate = snapshotIso ? new Date(snapshotIso) : null;
        const accountKey = accountId || accountName || orgId || `scorecard-account-${index}`;
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      const mcmuRows = mcmuSheet.rows.map((row, index) => {
        const snapshotDate = parseDate(row['Snapshot Date']);
        const snapshotIso = toIsoString(snapshotDate);
        if (snapshotIso) snapshotSet.add(snapshotIso);
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const tenantFromAccount = tenantByAccount.get(accountId);
        const tenantColumn = !isBlank(row['Enterprise Name and Tenant'])
          ? String(row['Enterprise Name and Tenant'])
          : null;
        const tenant = tenantFromAccount || tenantColumn || 'Not specified';
        const accountName = row['Account Name'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const accountKey = accountId || accountName || `mcmu-account-${index}`;
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      if (snapshotSet.size === 1) {
        const [onlySnapshot] = Array.from(snapshotSet);
        const referenceDate = coreRows.find((row) => row.__snapshot === onlySnapshot)?.__snapshotDate || new Date(onlySnapshot);
        const assignSnapshot = (row) => {
          if (!row.__snapshot) {
            row.__snapshot = onlySnapshot;
            row.__snapshotDate =
              referenceDate instanceof Date && !Number.isNaN(referenceDate.getTime())
                ? referenceDate
                : new Date(onlySnapshot);
          }
        };
        adoptionRows.forEach(assignSnapshot);
        scorecardRows.forEach(assignSnapshot);
      }

      coreRows.forEach((row) => {
        const tenant = tenantByAccount.get(row.__accountId) || 'Not specified';
        row.__tenant = tenant;
      });

      return { adoptionRows, scorecardRows, mcmuRows, coreRows, coreHeaders: coreSheet.headers };
    };

    const renderLicenseCharts = () => {
      if (
        !dom.licenseChartRoot ||
        !dom.licenseChartSection ||
        !dom.licenseChartStatus ||
        !dom.licenseChartCount
      ) {
        return;
      }

      destroyLicenseCharts();
      if (!state.datasetLoaded) {
        dom.licenseChartSection.hidden = true;
        updateLicenseChartStatus();
        return;
      }

      dom.licenseChartSection.hidden = false;

      const rows = state.core;

      if (!rows.length) {
        updateLicenseChartStatus();
        return;
      }

      if (typeof Chart === 'undefined') {
        state.licenseChartAggregates = new Map();
        updateLicenseChartStatus('Unable to render charts because the charting library failed to load.');
        return;
      }

      const aggregates = new Map();
      const getNumericValue = (row, keys) => {
        for (const key of keys) {
          if (!Object.prototype.hasOwnProperty.call(row, key)) continue;
          const numeric = normalizeNumber(row[key]);
          if (Number.isFinite(numeric)) {
            return numeric;
          }
        }
        return null;
      };

      rows.forEach((row) => {
        const level1 = !isBlank(row['Level 1 Cloud']) ? String(row['Level 1 Cloud']) : 'Not specified';
        const level2 = !isBlank(row['Level 2 Cloud']) ? String(row['Level 2 Cloud']) : level1;
        const type = getLicenseTypeLabel(row);
        const key = `${level1}__${level2}__${type}`;
        if (!aggregates.has(key)) {
          aggregates.set(key, {
            key,
            level1,
            level2,
            type,
            provisioned: null,
            activated: null,
            used: null,
            recordCount: 0,
          });
        }
        const aggregate = aggregates.get(key);
        aggregate.recordCount += 1;

        const provisioned = getNumericValue(row, ['Provisioned', 'Total Provisioned']);
        if (provisioned !== null) {
          aggregate.provisioned = aggregate.provisioned === null ? provisioned : aggregate.provisioned + provisioned;
        }
        const activated = getNumericValue(row, ['Activated']);
        if (activated !== null) {
          aggregate.activated = aggregate.activated === null ? activated : aggregate.activated + activated;
        }
        const used = getNumericValue(row, ['Used']);
        if (used !== null) {
          aggregate.used = aggregate.used === null ? used : aggregate.used + used;
        }
      });

      const entries = Array.from(aggregates.values()).filter((entry) =>
        [entry.provisioned, entry.activated, entry.used].some((value) => Number.isFinite(value))
      );

      if (!entries.length) {
        state.licenseChartAggregates = new Map();
        updateLicenseChartStatus();
        return;
      }

      entries.sort((a, b) => {
        if (a.level1 === b.level1) {
          if (a.level2 === b.level2) {
            if (a.type === b.type) return 0;
            if (a.type === 'Not specified') return 1;
            if (b.type === 'Not specified') return -1;
            return a.type.localeCompare(b.type, undefined, { sensitivity: 'base' });
          }
          if (a.level2 === 'Not specified') return 1;
          if (b.level2 === 'Not specified') return -1;
          return a.level2.localeCompare(b.level2, undefined, { sensitivity: 'base' });
        }
        if (a.level1 === 'Not specified') return 1;
        if (b.level1 === 'Not specified') return -1;
        return a.level1.localeCompare(b.level1, undefined, { sensitivity: 'base' });
      });

      const aggregateMap = new Map();
      entries.forEach((entry) => {
        aggregateMap.set(entry.key, entry);
      });

      state.licenseChartAggregates = aggregateMap;
      updateLicenseChartStatus();
    };

    const createLicenseChartCard = (aggregate, sourceRow = {}) => {
      if (!aggregate || !dom.licenseChartRoot) return;

      let key = aggregate.key;
      if (!(state.licenseChartCards instanceof Map)) {
        state.licenseChartCards = new Map();
      }

      if (state.licenseChartCards.has(key)) {
        key = `${key}__${state.licenseChartCards.size + 1}`;
      }

      if (typeof Chart === 'undefined') {
        updateLicenseChartStatus('Unable to render charts because the charting library failed to load.');
        return;
      }

      const labels = [];
      const data = [];
      const colors = [];

      if (Number.isFinite(aggregate.provisioned)) {
        labels.push('Provisioned');
        data.push(aggregate.provisioned);
        colors.push(LICENSE_CHART_COLORS.provisioned);
      }
      if (Number.isFinite(aggregate.activated)) {
        labels.push('Activated');
        data.push(aggregate.activated);
        colors.push(LICENSE_CHART_COLORS.activated);
      }
      if (Number.isFinite(aggregate.used)) {
        labels.push('Used');
        data.push(aggregate.used);
        colors.push(LICENSE_CHART_COLORS.used);
      }

      if (!labels.length) {
        updateLicenseChartStatus('No license metrics available for the selected row.');
        return;
      }

      if (dom.licenseChartSection) {
        dom.licenseChartSection.hidden = false;
      }

      const card = document.createElement('article');
      card.className = 'license-chart-card';
      card.dataset.chartKey = key;

      const closeButton = document.createElement('button');
      closeButton.type = 'button';
      closeButton.className = 'license-chart-card-close';
      closeButton.setAttribute('aria-label', 'Remove chart');
      closeButton.textContent = '×';

      const header = document.createElement('div');
      header.className = 'license-chart-card-header';

      const title = document.createElement('h3');
      const groupLabel = !isBlank(sourceRow['Group']) ? String(sourceRow['Group']) : '';
      const typeLabel = getLicenseTypeLabel(sourceRow);
      const level2Label = !isBlank(sourceRow['Level 2 Cloud']) ? String(sourceRow['Level 2 Cloud']) : '';
      const titleParts = [level2Label, groupLabel, typeLabel].filter(Boolean);
      title.textContent = titleParts.length ? titleParts.join(' - ') : 'License metrics';
      header.append(title);

      card.append(closeButton, header);

      const figure = document.createElement('div');
      figure.className = 'license-chart-figure';
      const canvas = document.createElement('canvas');
      figure.append(canvas);
      card.append(figure);

      const rootStyles = getComputedStyle(document.documentElement);
      const mutedColor = (rootStyles.getPropertyValue('--muted') || '#64748b').trim() || '#64748b';

      const chart = new Chart(canvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              data,
              backgroundColor: colors,
              borderWidth: 0,
              borderRadius: 10,
              barPercentage: 0.6,
              categoryPercentage: 0.8,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          scales: {
            x: {
              beginAtZero: true,
              grid: {
                color: 'rgba(148, 163, 184, 0.2)',
              },
              ticks: {
                color: mutedColor,
                callback: (value) => formatNumber(Number(value)),
              },
            },
            y: {
              grid: {
                display: false,
              },
              ticks: {
                color: mutedColor,
              },
            },
          },
          plugins: {
            legend: {
              display: false,
            },
            tooltip: {
              callbacks: {
                label(context) {
                  const value = context.parsed.x ?? context.parsed;
                  return `${context.label}: ${formatNumber(Number(value))}`;
                },
              },
            },
          },
        },
      });

      card.chartInstance = chart;
      state.licenseChartInstances.push(chart);

      let adoptionRate = null;
      if (Number.isFinite(aggregate.provisioned) && aggregate.provisioned > 0) {
        if (Number.isFinite(aggregate.used) && aggregate.used > 0) {
          adoptionRate = aggregate.used / aggregate.provisioned;
        } else if (Number.isFinite(aggregate.activated)) {
          adoptionRate = aggregate.activated / aggregate.provisioned;
        }
      }
      const utilizationRate =
        Number.isFinite(aggregate.activated) && aggregate.activated > 0 && Number.isFinite(aggregate.used)
          ? aggregate.used / aggregate.activated
          : null;

      const metricsWrapper = document.createElement('div');
      metricsWrapper.className = 'license-chart-metrics';

      const metrics = [
        {
          label: 'Provisioned',
          value: Number.isFinite(aggregate.provisioned) ? formatNumber(aggregate.provisioned) : '—',
        },
        {
          label: 'Activated',
          value: Number.isFinite(aggregate.activated) ? formatNumber(aggregate.activated) : '—',
        },
        {
          label: 'Used',
          value: Number.isFinite(aggregate.used) ? formatNumber(aggregate.used) : '—',
        },
      ];

      if (Number.isFinite(adoptionRate)) {
        metrics.push({
          label: 'Adoption rate',
          value: formatPercent(adoptionRate, { maximumFractionDigits: 1, minimumFractionDigits: 0 }),
        });
      }

      if (Number.isFinite(utilizationRate)) {
        metrics.push({
          label: 'Utilization rate',
          value: formatPercent(utilizationRate, { maximumFractionDigits: 1, minimumFractionDigits: 0 }),
        });
      }

      metrics.forEach((metric) => {
        const metricEl = document.createElement('div');
        metricEl.className = 'license-chart-metric';
        const labelEl = document.createElement('span');
        labelEl.className = 'license-chart-metric-label';
        labelEl.textContent = metric.label;
        const valueEl = document.createElement('span');
        valueEl.className = 'license-chart-metric-value';
        valueEl.textContent = metric.value;
        metricEl.append(labelEl, valueEl);
        metricsWrapper.append(metricEl);
      });

      card.append(metricsWrapper);

      const removeCard = () => {
        const chartInstance = card.chartInstance;
        if (chartInstance && typeof chartInstance.destroy === 'function') {
          chartInstance.destroy();
        }
        state.licenseChartInstances = state.licenseChartInstances.filter((instance) => instance !== chartInstance);
        if (state.licenseChartCards instanceof Map) {
          state.licenseChartCards.delete(key);
        }
        card.chartInstance = null;
        card.remove();
        updateLicenseChartStatus();
      };

      closeButton.addEventListener('click', removeCard);

      dom.licenseChartRoot.append(card);
      state.licenseChartCards.set(key, { card, chart });
      updateLicenseChartStatus();
    };

    const handleSummaryChartRequest = (row) => {
      if (!row) return;

      if (typeof Chart === 'undefined') {
        updateLicenseChartStatus('Unable to render charts because the charting library failed to load.');
        return;
      }

      if (!(state.licenseChartAggregates instanceof Map) || !state.licenseChartAggregates.size) {
        updateLicenseChartStatus('No license metrics available for the selected row.');
        return;
      }

      const level1 = !isBlank(row['Level 1 Cloud']) ? String(row['Level 1 Cloud']) : 'Not specified';
      const level2 = !isBlank(row['Level 2 Cloud']) ? String(row['Level 2 Cloud']) : level1;
      const type = getLicenseTypeLabel(row);
      const key = `${level1}__${level2}__${type}`;
      const aggregate = state.licenseChartAggregates.get(key);

      if (!aggregate) {
        updateLicenseChartStatus('No license metrics available for the selected row.');
        return;
      }

      createLicenseChartCard(aggregate, row);
    };

    const applySelection = (snapshot, tenant, account, labels = {}) => {
      const accountIdValue = account === 'all' ? 'All accounts' : labels.accountIdText || '';
      const orgIdValue = account === 'all' ? 'All orgs' : labels.orgIdText || '';
      state.selection = { snapshot, tenant, account, accountId: accountIdValue, orgId: orgIdValue };
      state.filters = { ...DEFAULT_FILTERS };

      if (dom.adoptionSearch) dom.adoptionSearch.value = '';
      if (dom.scorecardSearch) dom.scorecardSearch.value = '';
      if (dom.summarySearch) dom.summarySearch.value = '';
      if (dom.cloudFilter) dom.cloudFilter.value = 'all';

      const matchesSelection = (row) => {
        if (!row) return false;
        if (snapshot) {
          if (row.__snapshot && row.__snapshot !== snapshot) return false;
          if (!row.__snapshot) return false;
        }
        if (tenant && tenant !== 'all') {
          const rowTenant = row.__tenant || 'Not specified';
          if (rowTenant !== tenant) return false;
        }
        if (account && account !== 'all') {
          const rowAccount = row.__accountKey || row.__accountId || row.__accountLabel;
          if (rowAccount !== account) return false;
        }
        return true;
      };

      state.adoption = state.adoptionAll.filter((row) => matchesSelection(row));
      state.scorecard = state.scorecardAll.filter((row) => matchesSelection(row));
      state.mcmu = state.mcmuAll.filter((row) => matchesSelection(row));
      state.core = state.coreAll.filter((row) => matchesSelection(row));

      updateAdoptionFilters();
      renderAdoptionTable();
      updateScorecardFilters();
      renderScorecardTable();
      renderMcmuTable();
      updateSummary();
      renderLicenseCharts();
      updateSnapshotPill();
      updateSelectionLabels(labels);
    };
    const updateSummary = () => {
      const rows = state.core;
      if (!rows.length) {
        if (dom.summarySearch) {
          dom.summarySearch.disabled = true;
        }
        if (dom.summaryStatus) {
          dom.summaryStatus.textContent = state.datasetLoaded
            ? 'No core records match the current selection.'
            : 'No rows loaded from the “Core By OrgID” sheet.';
        }
        if (dom.summaryCards) {
          dom.summaryCards.hidden = true;
          dom.summaryCards.innerHTML = '';
        }
        return;
      }

      const rawHeaders = state.coreHeaders && state.coreHeaders.length
        ? state.coreHeaders
        : Object.keys(rows[0] || {});
      const headers = rawHeaders.filter((header) => !isBlank(header) && !header.startsWith('__'));
      const visibleHeaders = headers.filter((header) => !SUMMARY_HIDDEN_COLUMNS.has(header));

      if (!visibleHeaders.length) {
        if (dom.summaryStatus) {
          dom.summaryStatus.textContent = 'No visible columns available for the "Core By OrgID" summary.';
        }
        if (dom.summaryCards) {
          dom.summaryCards.hidden = true;
          dom.summaryCards.innerHTML = '';
        }
        if (dom.summarySearch) {
          dom.summarySearch.disabled = true;
        }
        return;
      }

      const tableHeaders = visibleHeaders.filter((header) => !SUMMARY_LEVEL_COLUMNS.includes(header));
      const searchableHeaders = new Set([
        ...tableHeaders,
        ...SUMMARY_LEVEL_COLUMNS.filter((header) => headers.includes(header)),
      ]);

      const query = state.filters.summarySearch.trim().toLowerCase();
      const filteredRows = query
        ? rows.filter((row) => {
          if (!searchableHeaders.size) return false;
          for (const header of searchableHeaders) {
            let value = '';
            if (SUMMARY_LEVEL_COLUMNS.includes(header)) {
              value = !isBlank(row[header]) ? String(row[header]) : '';
            } else {
              value = getSummaryCellValue(header, row);
            }
            if (value && value.toLowerCase().includes(query)) {
              return true;
            }
          }
          return false;
        })
        : rows;

      if (!filteredRows.length) {
        if (dom.summaryStatus) {
          dom.summaryStatus.textContent = 'No summary rows match the current search.';
        }
        if (dom.summaryCards) {
          dom.summaryCards.hidden = true;
          dom.summaryCards.innerHTML = '';
        }
        if (dom.summarySearch) {
          dom.summarySearch.disabled = false;
        }
        return;
      }

      if (!tableHeaders.length) {
        if (dom.summaryStatus) {
          dom.summaryStatus.textContent = 'No visible columns available after applying summary exclusions.';
        }
        if (dom.summaryCards) {
          dom.summaryCards.hidden = true;
          dom.summaryCards.innerHTML = '';
        }
        if (dom.summarySearch) {
          dom.summarySearch.disabled = false;
        }
        return;
      }

      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = '';
      }
      if (dom.summaryCards) {
        dom.summaryCards.hidden = false;
      }
      if (dom.summarySearch) {
        dom.summarySearch.disabled = false;
        dom.summarySearch.value = state.filters.summarySearch;
      }

      const level1Key = SUMMARY_LEVEL_COLUMNS[0];
      const level2Key = SUMMARY_LEVEL_COLUMNS[1];
      const groupMap = new Map();

      const getLabel = (value) => (!isBlank(value) ? String(value) : 'Not specified');

      filteredRows.forEach((row) => {
        const level1Label = headers.includes(level1Key) ? getLabel(row[level1Key]) : 'All records';
        const level2Label = headers.includes(level2Key) ? getLabel(row[level2Key]) : 'All records';
        if (!groupMap.has(level1Label)) {
          groupMap.set(level1Label, new Map());
        }
        const level2Map = groupMap.get(level1Label);
        if (!level2Map.has(level2Label)) {
          level2Map.set(level2Label, []);
        }
        level2Map.get(level2Label).push(row);
      });

      const sortEntries = (entries) =>
        entries.sort((a, b) => {
          if (a[0] === b[0]) return 0;
          if (a[0] === 'Not specified') return 1;
          if (b[0] === 'Not specified') return -1;
          return a[0].localeCompare(b[0], undefined, { sensitivity: 'base' });
        });

      const fragment = document.createDocumentFragment();
      const level1Entries = sortEntries(Array.from(groupMap.entries()));

      level1Entries.forEach(([level1Label, level2Map]) => {
        const level1Details = document.createElement('details');
        level1Details.className = 'summary-accordion level1';

        const level1Summary = document.createElement('summary');
        const level1Text = document.createElement('span');
        level1Text.textContent = level1Label;
        const level1Count = Array.from(level2Map.values()).reduce((total, rowsForLevel2) => total + rowsForLevel2.length, 0);
        const level1CountEl = document.createElement('span');
        level1CountEl.className = 'summary-count';
        level1CountEl.textContent = `${level1Count} ${level1Count === 1 ? 'record' : 'records'}`;
        level1Summary.append(level1Text, level1CountEl);
        level1Details.append(level1Summary);

        const level2Entries = sortEntries(Array.from(level2Map.entries()));
        level2Entries.forEach(([level2Label, level2Rows]) => {
          const level2Details = document.createElement('details');
          level2Details.className = 'summary-accordion level2';

          const level2Summary = document.createElement('summary');
          const level2Text = document.createElement('span');
          level2Text.textContent = level2Label;
          const level2CountEl = document.createElement('span');
          level2CountEl.className = 'summary-count';
          level2CountEl.textContent = `${level2Rows.length} ${level2Rows.length === 1 ? 'record' : 'records'}`;
          level2Summary.append(level2Text, level2CountEl);
          level2Details.append(level2Summary);

          const table = createSummaryTable(tableHeaders, level2Rows);
          if (table) {
            level2Details.append(table);
          }

          level1Details.append(level2Details);
        });

        fragment.append(level1Details);
      });

      if (dom.summaryCards) {
        dom.summaryCards.innerHTML = '';
        dom.summaryCards.append(fragment);
      }
    };

    const updateTypeFilterOptions = () => {
      if (!dom.typeFilter) return;
      const { adoption, filters } = state;
      if (!adoption.length) {
        dom.typeFilter.innerHTML = '<option value="" disabled selected>No types available</option>';
        dom.typeFilter.disabled = true;
        return;
      }

      const types = new Set();
      adoption.forEach((row) => {
        if (filters.group !== 'all' && String(row.Group) !== filters.group) return;
        if (!isBlank(row.Type)) types.add(String(row.Type));
      });

      dom.typeFilter.innerHTML = '<option value="all">Type: all</option>';
      Array.from(types)
        .sort((a, b) => a.localeCompare(b))
        .forEach((type) => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          dom.typeFilter.append(option);
        });

      if (!types.has(state.filters.type)) {
        state.filters.type = 'all';
      }
      dom.typeFilter.value = state.filters.type;
      dom.typeFilter.disabled = dom.typeFilter.options.length <= 1;
    };

    const updateAdoptionFilters = () => {
      if (!dom.groupFilter || !dom.apmFilter) return;
      const { adoption } = state;

      if (!adoption.length) {
        dom.groupFilter.innerHTML = '<option value="" disabled selected>No groups available</option>';
        dom.groupFilter.disabled = true;
        dom.typeFilter.innerHTML = '<option value="" disabled selected>No types available</option>';
        dom.typeFilter.disabled = true;
        dom.apmFilter.innerHTML = '<option value="" disabled selected>No APM levels available</option>';
        dom.apmFilter.disabled = true;
        return;
      }

      const groups = new Set();
      const apmLevels = new Set();
      adoption.forEach((row) => {
        if (!isBlank(row.Group)) groups.add(String(row.Group));
        if (!isBlank(row['APM Level 1'])) apmLevels.add(String(row['APM Level 1']));
      });

      dom.groupFilter.innerHTML = '<option value="all">Group: all</option>';
      Array.from(groups)
        .sort((a, b) => a.localeCompare(b))
        .forEach((group) => {
          const option = document.createElement('option');
          option.value = group;
          option.textContent = group;
          dom.groupFilter.append(option);
        });
      if (!groups.has(state.filters.group)) {
        state.filters.group = 'all';
      }
      dom.groupFilter.value = state.filters.group;
      dom.groupFilter.disabled = false;

      updateTypeFilterOptions();

      dom.apmFilter.innerHTML = '<option value="all">APM Level 1: all</option>';
      Array.from(apmLevels)
        .sort((a, b) => a.localeCompare(b))
        .forEach((item) => {
          const option = document.createElement('option');
          option.value = item;
          option.textContent = item;
          dom.apmFilter.append(option);
        });
      if (!apmLevels.has(state.filters.apm)) {
        state.filters.apm = 'all';
      }
      dom.apmFilter.value = state.filters.apm;
      dom.apmFilter.disabled = dom.apmFilter.options.length <= 1;
    };

    const handleAdoptionChartRequest = (row) => {
      if (!row) return;

      if (typeof Chart === 'undefined') {
        updateLicenseChartStatus('Unable to render charts because the charting library failed to load.');
        return;
      }

      const provisioned = normalizeNumber(row.PROVISIONED);
      const activated = normalizeNumber(row.ACTIVATED);
      const used = normalizeNumber(row.USED);

      if (![provisioned, activated, used].some((value) => Number.isFinite(value))) {
        updateLicenseChartStatus('No license metrics available for the selected row.');
        return;
      }

      const groupLabel = !isBlank(row.Group) ? String(row.Group) : 'Not specified';
      const typeLabel = !isBlank(row.Type) ? String(row.Type) : groupLabel;

      const keyParts = [
        row.__accountKey || row.__accountId || row.__accountLabel || row['Org ID'] || row['ORG ID'] || '',
        row.Group || '',
        row.Type || '',
        row.SKU || row['SKU Name'] || row['Product Name'] || '',
      ];

      const keyBase = keyParts
        .filter((value) => !isBlank(value))
        .map((value) => String(value).trim().toLowerCase().replace(/\s+/g, '_'))
        .join('__');

      const aggregate = {
        key: keyBase ? `adoption__${keyBase}` : `adoption__${Date.now()}_${Math.random().toString(36).slice(2)}`,
        level1: groupLabel,
        level2: typeLabel,
        provisioned: Number.isFinite(provisioned) ? provisioned : null,
        activated: Number.isFinite(activated) ? activated : null,
        used: Number.isFinite(used) ? used : null,
        recordCount: 1,
      };

      const sourceRow = { ...row };
      if (isBlank(sourceRow['Level 1 Cloud'])) sourceRow['Level 1 Cloud'] = groupLabel;
      if (isBlank(sourceRow['Level 2 Cloud'])) sourceRow['Level 2 Cloud'] = typeLabel;

      createLicenseChartCard(aggregate, sourceRow);
    };

    const handleManualChartAdd = () => {
      if (typeof Chart === 'undefined') {
        updateLicenseChartStatus('Unable to render charts because the charting library failed to load.');
        return;
      }

      const titleInput = window.prompt('Enter a title for the manual chart:');
      if (titleInput === null) return;
      const title = titleInput.trim();
      if (!title) return;

      const requestNumber = (message) => {
        const input = window.prompt(message);
        if (input === null) return { cancelled: true };
        if (isBlank(input)) return { value: null };
        const numeric = normalizeNumber(input);
        if (!Number.isFinite(numeric)) {
          window.alert('Value must be numeric. Manual chart creation cancelled.');
          return { error: true };
        }
        return { value: numeric };
      };

      const provisionedResult = requestNumber('Provisioned quantity (leave blank to skip):');
      if (provisionedResult?.cancelled || provisionedResult?.error) return;
      const activatedResult = requestNumber('Activated quantity (leave blank to skip):');
      if (activatedResult?.cancelled || activatedResult?.error) return;
      const usedResult = requestNumber('Used quantity (leave blank to skip):');
      if (usedResult?.cancelled || usedResult?.error) return;

      const provisioned = provisionedResult?.value ?? null;
      const activated = activatedResult?.value ?? null;
      const used = usedResult?.value ?? null;

      if (![provisioned, activated, used].some((value) => Number.isFinite(value))) {
        window.alert('At least one metric is required to create a chart.');
        return;
      }

      const aggregate = {
        key: `manual__${Date.now()}_${Math.random().toString(36).slice(2)}`,
        level1: title,
        level2: title,
        provisioned: Number.isFinite(provisioned) ? provisioned : null,
        activated: Number.isFinite(activated) ? activated : null,
        used: Number.isFinite(used) ? used : null,
        recordCount: 1,
      };

      const sourceRow = {
        'Level 1 Cloud': title,
        'Level 2 Cloud': title,
        __manual: true,
      };

      createLicenseChartCard(aggregate, sourceRow);
    };

    const renderAdoptionTable = () => {
      if (!dom.adoptionTableBody) return;
      const { adoption, filters } = state;
      const query = filters.adoptionSearch.trim().toLowerCase();

      const filtered = adoption.filter((row) => {
        if (filters.group !== 'all' && String(row.Group) !== filters.group) return false;
        if (filters.type !== 'all' && String(row.Type) !== filters.type) return false;
        if (filters.apm !== 'all' && String(row['APM Level 1']) !== filters.apm) return false;
        if (query) {
          const haystack = [row['Account Name'], row['Account Local Name'], row['Org ID'], row.Type, row.Group]
            .filter((value) => !isBlank(value))
            .map((value) => String(value).toLowerCase())
            .join(' ');
          if (!haystack.includes(query)) return false;
        }
        return true;
      });

      dom.adoptionTableBody.innerHTML = '';
      if (filtered.length === 0) {
        dom.adoptionTableBody.innerHTML =
          '<tr><td colspan="9" class="empty-state">No adoption metrics for the selected filters.</td></tr>';
      } else {
        filtered.forEach((row) => {
          const tr = document.createElement('tr');
          const cells = [
            row.Group || '—',
            row.Type || '—',
            formatNumber(normalizeNumber(row.PROVISIONED)),
            formatNumber(normalizeNumber(row.ACTIVATED)),
            formatNumber(normalizeNumber(row.USED)),
            formatEngagement(row.EU),
            formatEngagement(row['MAU Penetration']),
            formatNumber(normalizeNumber(row.Shelfware)),
          ];
          cells.forEach((text) => {
            const td = document.createElement('td');
            td.textContent = text;
            tr.append(td);
          });

          const actionCell = document.createElement('td');
          actionCell.className = 'summary-action-cell';
          const chartButton = document.createElement('button');
          chartButton.type = 'button';
          chartButton.className = 'summary-action-button';
          chartButton.textContent = 'Chart';
          chartButton.addEventListener('click', () => {
            handleAdoptionChartRequest(row);
          });
          actionCell.append(chartButton);
          tr.append(actionCell);

          dom.adoptionTableBody.append(tr);
        });
      }

      if (dom.adoptionResultsLabel) {
        dom.adoptionResultsLabel.textContent = adoption.length
          ? `${filtered.length} rows out of ${adoption.length}`
          : '';
      }
      if (dom.adoptionCountPill) {
        dom.adoptionCountPill.textContent = adoption.length
          ? `${filtered.length} SKU visible`
          : '--';
      }
    };
    const renderScorecardTable = () => {
      if (!dom.scorecardTableBody) return;
      const { scorecard, filters } = state;
      const query = filters.scorecardSearch.trim().toLowerCase();

      const filtered = scorecard.filter((row) => {
        if (filters.cloud !== 'all' && String(row.Cloud) !== filters.cloud) return false;
        if (query) {
          const haystack = [row['Account Local Name'], row['Metric Name'], row.Cloud]
            .filter((value) => !isBlank(value))
            .map((value) => String(value).toLowerCase())
            .join(' ');
          if (!haystack.includes(query)) return false;
        }
        return true;
      });

      dom.scorecardTableBody.innerHTML = '';
      if (!filtered.length) {
        dom.scorecardTableBody.innerHTML =
          '<tr><td colspan="4" class="empty-state">No scorecard metrics match the current filters.</td></tr>';
      } else {
        filtered.forEach((row) => {
          const tr = document.createElement('tr');
          const mom = normalizeNumber(row['Month over Month Pct']);
          const momBadge = document.createElement('span');
          const badgeClass = mom > 0 ? 'badge up' : mom < 0 ? 'badge down' : 'badge';
          momBadge.className = badgeClass;
          momBadge.textContent = Number.isFinite(mom) ? `${(mom * 100).toFixed(1)}%` : '—';

          const cells = [
            row.Cloud || '—',
            row['Metric Name'] || '—',
            formatNumber(normalizeNumber(row['Metric Value'])),
            momBadge,
          ];

          cells.forEach((content, index) => {
            const td = document.createElement('td');
            if (index === cells.length - 1 && content instanceof HTMLElement) {
              td.append(content);
            } else {
              td.textContent = content;
            }
            tr.append(td);
          });
          dom.scorecardTableBody.append(tr);
        });
      }

      if (dom.scorecardCountPill) {
        dom.scorecardCountPill.textContent = `${filtered.length} metrics`;
      }
    };

    const updateScorecardFilters = () => {
      if (!dom.cloudFilter) return;
      const clouds = new Set();
      state.scorecard.forEach((row) => {
        if (!isBlank(row.Cloud)) clouds.add(String(row.Cloud));
      });
      dom.cloudFilter.innerHTML = '<option value="all">Cloud: all</option>';
      Array.from(clouds)
        .sort((a, b) => a.localeCompare(b))
        .forEach((cloud) => {
          const option = document.createElement('option');
          option.value = cloud;
          option.textContent = cloud;
          dom.cloudFilter.append(option);
        });
      dom.cloudFilter.disabled = dom.cloudFilter.options.length <= 1;
      dom.cloudFilter.value = 'all';
    };

    const renderMcmuTable = () => {
      if (!dom.mcmuTableBody) return;
      const rows = state.mcmu;
      dom.mcmuTableBody.innerHTML = '';
      if (!rows.length) {
        dom.mcmuTableBody.innerHTML =
          '<tr><td colspan="5" class="empty-state">No MCMU records available for the current selection.</td></tr>';
        if (dom.mcmuCountPill) dom.mcmuCountPill.textContent = '--';
        return;
      }

      const sorted = [...rows]
        .map((row) => ({
          ...row,
          __date: row.__snapshotDate instanceof Date && !Number.isNaN(row.__snapshotDate.getTime())
            ? row.__snapshotDate
            : parseDate(row['Snapshot Date']),
        }))
        .sort((a, b) => {
          const aTime = a.__date instanceof Date && !Number.isNaN(a.__date.getTime()) ? a.__date.getTime() : 0;
          const bTime = b.__date instanceof Date && !Number.isNaN(b.__date.getTime()) ? b.__date.getTime() : 0;
          return bTime - aTime;
        });

      sorted.forEach((row) => {
        const tr = document.createElement('tr');
        const date = row.__date instanceof Date && !Number.isNaN(row.__date.getTime())
          ? formatDate(row.__date)
          : row['Snapshot Date'] || '—';
        const cells = [
          date,
          row['Account Name'] || row['Account ID'] || '—',
          formatNumber(normalizeNumber(row['Super Messages Provisioned'])),
          formatNumber(normalizeNumber(row['Super Messages Used'])),
          formatNumber(normalizeNumber(row['Contacts Provisioned'])),
        ];
        cells.forEach((text) => {
          const td = document.createElement('td');
          td.textContent = text;
          tr.append(td);
        });
        dom.mcmuTableBody.append(tr);
      });

      if (dom.mcmuCountPill) {
        dom.mcmuCountPill.textContent = `${rows.length} records`;
      }
    };

    const updateSnapshotPill = () => {
      if (!dom.snapshotPill) return;
      if (!state.selection.snapshot) {
        dom.snapshotPill.textContent = 'Snapshot not selected';
        return;
      }
      const date = new Date(state.selection.snapshot);
      dom.snapshotPill.textContent = Number.isNaN(date.getTime())
        ? `Snapshot: ${state.selection.snapshot}`
        : `Snapshot: ${formatDate(date)}`;
    };
    const resetDashboard = (message) => {
      state.adoption = [];
      state.adoptionAll = [];
      state.scorecard = [];
      state.scorecardAll = [];
      state.mcmu = [];
      state.mcmuAll = [];
      state.core = [];
      state.coreAll = [];
      state.coreHeaders = [];
      state.licenseChartInstances = [];
      state.filters = { ...DEFAULT_FILTERS };
      state.selection = { snapshot: '', tenant: 'all', account: 'all', accountId: '', orgId: '' };
      state.datasetLoaded = false;

      if (dom.uploadInput) dom.uploadInput.value = '';
      populateSnapshotOptions();
      resetSelect(dom.tenantSelect, 'Upload a workbook to populate tenants');
      resetSelect(dom.accountSelect, 'Upload a workbook to populate accounts');
      if (dom.cloudFilter) {
        dom.cloudFilter.innerHTML = '<option value="all">Cloud: all</option>';
        dom.cloudFilter.disabled = true;
        dom.cloudFilter.value = 'all';
      }
      if (dom.adoptionSearch) dom.adoptionSearch.value = '';
      if (dom.scorecardSearch) dom.scorecardSearch.value = '';
      updateSelectionLabels({
        snapshotText: 'Not selected',
        tenantText: 'Not selected',
        accountText: 'Not selected',
        accountIdText: 'Not selected',
        orgIdText: 'Not selected',
      });
      clearVisualizations(message);
      updateLoadButtonState();
      if (dom.uploadStatus) {
        dom.uploadStatus.textContent = message;
      }
    };

    const handleWorkbookFile = (file) => {
      if (!file) {
        resetDashboard('Upload an adoption workbook to begin the analysis.');
        return;
      }
      if (!/\.xlsx$/i.test(file.name)) {
        alert('Please upload an XLSX file exported from the adoption dashboard.');
        resetDashboard('Upload an adoption workbook to begin the analysis.');
        return;
      }

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const dataset = parseWorkbookData(event.target.result);
          state.datasetLoaded = true;
          state.adoptionAll = dataset.adoptionRows;
          state.scorecardAll = dataset.scorecardRows;
          state.mcmuAll = dataset.mcmuRows;
          state.coreAll = dataset.coreRows;
          state.coreHeaders = Array.isArray(dataset.coreHeaders) ? dataset.coreHeaders.filter((header) => !isBlank(header)) : [];
          state.selection = { snapshot: '', tenant: 'all', account: 'all', accountId: '', orgId: '' };
          state.filters = { ...DEFAULT_FILTERS };

          resetSelect(dom.tenantSelect, 'Select a snapshot first');
          resetSelect(dom.accountSelect, 'Select a snapshot first');
          populateSnapshotOptions();
          updateSelectionLabels({
            snapshotText: 'Not selected',
            tenantText: 'Not selected',
            accountText: 'Not selected',
            accountIdText: 'Not selected',
            orgIdText: 'Not selected',
          });
          clearVisualizations('Select a snapshot, tenant, and account, then click "Load data".');
          if (dom.uploadStatus) {
            dom.uploadStatus.textContent = `Loaded ${file.name}. Select a snapshot to continue.`;
          }
        } catch (error) {
          console.error('Unable to parse adoption workbook', error);
          alert('The uploaded file is not a valid adoption workbook.');
          resetDashboard('Upload an adoption workbook to begin the analysis.');
        }
        updateLoadButtonState();
      };
      reader.onerror = () => {
        alert('Unable to read the selected file.');
        resetDashboard('Upload an adoption workbook to begin the analysis.');
      };
      reader.readAsArrayBuffer(file);
    };

    const handleSnapshotChange = () => {
      const snapshot = dom.snapshotSelect ? dom.snapshotSelect.value : '';
      populateTenantOptions(snapshot);
      updateLoadButtonState();
    };

    const handleTenantChange = () => {
      const snapshot = dom.snapshotSelect ? dom.snapshotSelect.value : '';
      const tenantValue = dom.tenantSelect && !dom.tenantSelect.disabled ? dom.tenantSelect.value || 'all' : 'all';
      populateAccountOptions(snapshot, tenantValue);
    };

    const handleAccountChange = () => {
      updateLoadButtonState();
    };

    const handleLoadClick = () => {
      if (!dom.snapshotSelect || !dom.accountSelect) return;
      const snapshot = dom.snapshotSelect.value;
      if (!snapshot) return;
      if (dom.accountSelect.disabled || !dom.accountSelect.value) return;
      const tenantValue = dom.tenantSelect && !dom.tenantSelect.disabled ? dom.tenantSelect.value || 'all' : 'all';
      const accountValue = dom.accountSelect.value;
      const snapshotLabel = dom.snapshotSelect.options[dom.snapshotSelect.selectedIndex]?.textContent || 'Not selected';
      const tenantLabel =
        tenantValue === 'all'
          ? 'All tenants'
          : dom.tenantSelect?.options[dom.tenantSelect.selectedIndex]?.textContent || tenantValue;
      const accountLabel =
        accountValue === 'all'
          ? 'All accounts'
          : dom.accountSelect?.options[dom.accountSelect.selectedIndex]?.textContent || accountValue;

      const resolveRowValue = (row, keys) => {
        if (!row) return '';
        for (const key of keys) {
          if (!key) continue;
          const value = row[key];
          if (!isBlank(value)) {
            return String(value);
          }
        }
        return '';
      };

      let accountIdLabel = '';
      let orgIdLabel = '';
      if (accountValue === 'all') {
        accountIdLabel = 'All accounts';
        orgIdLabel = 'All orgs';
      } else {
        const datasets = [state.adoptionAll, state.scorecardAll, state.coreAll, state.mcmuAll];
        let matchedRow = null;
        for (const rows of datasets) {
          if (!Array.isArray(rows)) continue;
          matchedRow = rows.find((row) => {
            if (!row) return false;
            if (snapshot && row.__snapshot && row.__snapshot !== snapshot) return false;
            const key = row.__accountKey || row.__accountId || row.__accountLabel;
            return key === accountValue;
          });
          if (matchedRow) break;
        }
        const accountIdValue = resolveRowValue(matchedRow, [
          '__accountId',
          'Account ID',
          'ACCOUNT ID',
          'Account Id',
          'Account id',
          'AccountID',
          'ACCOUNTID',
        ]);
        const orgIdValue = resolveRowValue(matchedRow, [
          'Org Id',
          'Org ID',
          'ORG ID',
          'OrgId',
          'OrgID',
          'ORGID',
        ]);
        accountIdLabel = accountIdValue || 'Not specified';
        orgIdLabel = orgIdValue || 'Not specified';
      }

      applySelection(snapshot, tenantValue, accountValue, {
        snapshotText: snapshotLabel,
        tenantText: tenantLabel,
        accountText: accountLabel,
        accountIdText: accountIdLabel,
        orgIdText: orgIdLabel,
      });

      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = '';
      }
      if (dom.uploadStatus) {
        dom.uploadStatus.textContent = `Showing data for ${snapshotLabel} · ${tenantLabel} · ${accountLabel}`;
      }
    };

    const attachEventListeners = () => {
      if (dom.uploadInput) {
        dom.uploadInput.addEventListener('change', (event) => {
          const [file] = event.target.files || [];
          handleWorkbookFile(file);
        });
      }

      if (dom.snapshotSelect) {
        dom.snapshotSelect.addEventListener('change', handleSnapshotChange);
      }

      if (dom.tenantSelect) {
        dom.tenantSelect.addEventListener('change', handleTenantChange);
      }

      if (dom.accountSelect) {
        dom.accountSelect.addEventListener('change', handleAccountChange);
      }

      if (dom.loadButton) {
        dom.loadButton.addEventListener('click', handleLoadClick);
      }

      if (dom.summarySearch) {
        dom.summarySearch.addEventListener('input', (event) => {
          state.filters.summarySearch = event.target.value;
          updateSummary();
        });
      }

      if (dom.manualChartButton) {
        dom.manualChartButton.addEventListener('click', handleManualChartAdd);
      }

      if (dom.adoptionSearch) {
        dom.adoptionSearch.addEventListener('input', (event) => {
          state.filters.adoptionSearch = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.groupFilter) {
        dom.groupFilter.addEventListener('change', (event) => {
          state.filters.group = event.target.value;
          state.filters.type = 'all';
          updateTypeFilterOptions();
          renderAdoptionTable();
        });
      }

      if (dom.typeFilter) {
        dom.typeFilter.addEventListener('change', (event) => {
          state.filters.type = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.apmFilter) {
        dom.apmFilter.addEventListener('change', (event) => {
          state.filters.apm = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.scorecardSearch) {
        dom.scorecardSearch.addEventListener('input', (event) => {
          state.filters.scorecardSearch = event.target.value;
          renderScorecardTable();
        });
      }

      if (dom.cloudFilter) {
        dom.cloudFilter.addEventListener('change', (event) => {
          state.filters.cloud = event.target.value;
          renderScorecardTable();
        });
      }
    };

    attachEventListeners();
    resetDashboard('Upload an adoption workbook to begin the analysis.');
  </script>
</body>

</html>