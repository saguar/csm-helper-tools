<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Adoption Analyzer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --primary: #0ea5e9;
      --primary-dark: #0284c7;
      --success: #15803d;
      --warning: #b45309;
      --danger: #b91c1c;
      --text: #0f172a;
      --muted: #64748b;
      --border: rgba(148, 163, 184, 0.35);
      --shadow: 0 24px 48px rgba(15, 23, 42, 0.1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    body {
      background: linear-gradient(160deg, #e2e8f0, #f8fafc 45%, #ffffff 100%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    a {
      color: var(--primary);
    }

    .page-header {
      padding: 3rem 5vw 1.5rem;
      display: grid;
      gap: 1.25rem;
      max-width: 1300px;
      margin: 0 auto;
    }

    .page-header h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 700;
    }

    .page-header p {
      color: var(--muted);
      max-width: 880px;
      line-height: 1.6;
      font-size: 1rem;
    }

    .status-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--muted);
      font-size: 0.9rem;
      background: rgba(14, 165, 233, 0.12);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      width: fit-content;
    }

    main {
      padding: 0 5vw;
      display: grid;
      gap: 2rem;
      max-width: 1300px;
      margin: 0 auto;
    }

    .panel {
      background: var(--surface);
      border-radius: 1.25rem;
      padding: 1.75rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      display: grid;
      gap: 1.25rem;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .panel-header h2 {
      font-size: 1.35rem;
      font-weight: 700;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      background: var(--surface-alt);
      color: var(--muted);
      font-weight: 600;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
    }

    .helper-text {
      color: var(--muted);
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .data-loader {
      display: grid;
      gap: 1.25rem;
    }

    .form-grid {
      display: grid;
      gap: 1.25rem;
    }

    @media (min-width: 720px) {
      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        align-items: end;
      }
    }

    .form-group {
      display: grid;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 600;
      color: var(--text);
    }

    .form-group select,
    .form-group input[type="file"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.65rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .form-group input[type="file"] {
      padding: 0.55rem 1rem;
    }

    .load-button {
      justify-self: start;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    .load-button:disabled {
      background: var(--surface-alt);
      color: var(--muted);
      cursor: not-allowed;
      box-shadow: none;
    }

    .summary-grid {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 720px) {
      .summary-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
    }

    .summary-card {
      border-radius: 1.15rem;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.12), rgba(148, 163, 184, 0.08));
      padding: 1.25rem;
      display: grid;
      gap: 0.65rem;
    }

    .summary-card strong {
      font-size: 2rem;
      font-weight: 700;
    }

    .summary-card span {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .breakdown-grid {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 960px) {
      .breakdown-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
    }

    .breakdown-card {
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      padding: 1.1rem 1.25rem;
      display: grid;
      gap: 0.35rem;
    }

    .breakdown-card h3 {
      font-size: 1rem;
      font-weight: 600;
    }

    .breakdown-metric {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .filters select,
    .filters input[type="search"] {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 0.85rem;
      padding: 0.55rem 1rem;
      color: var(--text);
      font-size: 0.95rem;
    }

    .filters input[type="search"]::placeholder {
      color: var(--muted);
    }

    .table-wrapper {
      overflow-x: auto;
      border-radius: 1rem;
      border: 1px solid var(--border);
    }

    table.data-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px;
    }

    table.data-table thead th {
      background: var(--surface-alt);
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    table.data-table tbody td {
      padding: 0.85rem 1rem;
      border-top: 1px solid var(--border);
      font-size: 0.95rem;
    }

    table.data-table tbody tr:nth-child(even) {
      background: rgba(148, 163, 184, 0.08);
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      font-size: 0.95rem;
      padding: 1rem 0;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
    }

    .badge.up {
      color: var(--success);
      background: rgba(21, 128, 61, 0.12);
    }

    .badge.down {
      color: var(--danger);
      background: rgba(185, 28, 28, 0.12);
    }

    .scorecard-highlights {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 900px) {
      .scorecard-highlights {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }

    .highlight-card {
      border-radius: 1.1rem;
      border: 1px solid rgba(14, 165, 233, 0.2);
      background: linear-gradient(160deg, rgba(14, 165, 233, 0.18), rgba(15, 23, 42, 0.06));
      padding: 1.25rem;
      display: grid;
      gap: 0.65rem;
    }

    .highlight-card h3 {
      font-size: 1rem;
      font-weight: 600;
    }

    .highlight-card strong {
      font-size: 1.8rem;
      font-weight: 700;
    }

    .timeline-table {
      min-width: 640px;
    }

    @media (max-width: 640px) {
      .page-header,
      main {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <div>
      <h1>Adoption Analyzer</h1>
      <p>
        Upload an adoption workbook exported from Customer Success Score to explore activation, usage, and messaging
        metrics across every Salesforce organization. Use the selectors to focus on the snapshot, tenant, and account
        you want to investigate.
      </p>
    </div>
    <div class="status-chips">
      <span class="status-chip">Snapshot: <strong id="selectedSnapshot">Not selected</strong></span>
      <span class="status-chip">Tenant: <strong id="selectedTenant">Not selected</strong></span>
      <span class="status-chip">Account: <strong id="selectedAccount">Not selected</strong></span>
    </div>
  </header>

  <main>
    <section class="panel" id="dataLoaderPanel">
      <h2>Load adoption workbook</h2>
      <div class="data-loader">
        <div class="form-grid">
          <div class="form-group">
            <label for="snapshotSelect">Snapshot date</label>
            <select id="snapshotSelect" disabled>
              <option value="" disabled selected>Upload a workbook to populate dates</option>
            </select>
          </div>
          <div class="form-group">
            <label for="tenantSelect">Tenant</label>
            <select id="tenantSelect" disabled>
              <option value="" disabled selected>Select a snapshot first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="accountSelect">Account</label>
            <select id="accountSelect" disabled>
              <option value="" disabled selected>Select a snapshot first</option>
            </select>
          </div>
          <div class="form-group">
            <label for="adoptionUpload">Upload adoption workbook</label>
            <input
              type="file"
              id="adoptionUpload"
              accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            />
          </div>
        </div>
        <button class="load-button" type="button" id="loadWorkbookBtn" disabled>Load data</button>
        <p class="helper-text" id="uploadStatus">Upload an adoption workbook to begin the analysis.</p>
      </div>
    </section>

    <section class="panel" id="summarySection">
      <div class="panel-header">
        <h2>Snapshot summary</h2>
        <span class="pill" id="snapshotPill">Snapshot not selected</span>
      </div>
      <p class="helper-text" id="summaryStatus">Upload an adoption workbook to begin the analysis.</p>
      <div class="summary-grid" id="summaryCards" hidden></div>
      <div class="breakdown-grid" id="groupBreakdown" hidden></div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>Adoption metrics by SKU</h2>
        <span class="pill" id="adoptionCountPill">--</span>
      </div>
      <p class="helper-text">
        Review provisioning, activation, and usage metrics for every license and account. Apply the filters to focus on
        specific groups, product types, or APM levels.
      </p>
      <div class="filters">
        <input type="search" id="adoptionSearch" placeholder="Search by account, org, group, or SKU" />
        <select id="groupFilter" disabled>
          <option value="" disabled selected>No groups available</option>
        </select>
        <select id="typeFilter" disabled>
          <option value="" disabled selected>No types available</option>
        </select>
        <select id="apmFilter" disabled>
          <option value="" disabled selected>No APM levels available</option>
        </select>
      </div>
      <p class="helper-text" id="adoptionResultsLabel"></p>
      <div class="table-wrapper">
        <table class="data-table" id="adoptionTable">
          <thead>
            <tr>
              <th>Account</th>
              <th>Org ID</th>
              <th>Group</th>
              <th>Type</th>
              <th>Provisioned</th>
              <th>Activated</th>
              <th>Used</th>
              <th>EU</th>
              <th>MAU Penetration</th>
              <th>Shelfware</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>Adoption scorecard</h2>
        <span class="pill" id="scorecardCountPill">--</span>
      </div>
      <p class="helper-text">
        The scorecard summarizes KPIs from the executive dashboards. Track trends and month-over-month changes across
        each cloud.
      </p>
      <div class="filters">
        <input type="search" id="scorecardSearch" placeholder="Search metrics or accounts" />
        <select id="cloudFilter" disabled>
          <option value="all">Cloud: all</option>
        </select>
      </div>
      <div class="scorecard-highlights" id="scorecardHighlights" hidden></div>
      <div class="table-wrapper">
        <table class="data-table" id="scorecardTable">
          <thead>
            <tr>
              <th>Account</th>
              <th>Cloud</th>
              <th>Metric Name</th>
              <th>Metric Value</th>
              <th>MoM %</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <h2>MCMU messaging</h2>
        <span class="pill" id="mcmuCountPill">--</span>
      </div>
      <p class="helper-text">
        Review historical super message and contact provisioning to correlate Marketing Cloud activity with adoption
        metrics.
      </p>
      <div class="table-wrapper">
        <table class="data-table timeline-table" id="mcmuTable">
          <thead>
            <tr>
              <th>Snapshot Date</th>
              <th>Account</th>
              <th>Super Messages Provisioned</th>
              <th>Super Messages Used</th>
              <th>Contacts Provisioned</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    const DEFAULT_FILTERS = {
      adoptionSearch: '',
      group: 'all',
      type: 'all',
      apm: 'all',
      scorecardSearch: '',
      cloud: 'all',
    };

    const state = {
      adoption: [],
      adoptionAll: [],
      scorecard: [],
      scorecardAll: [],
      mcmu: [],
      mcmuAll: [],
      core: [],
      coreAll: [],
      filters: { ...DEFAULT_FILTERS },
      selection: { snapshot: '', tenant: 'all', account: 'all' },
      datasetLoaded: false,
    };

    const dom = {
      selectedSnapshot: document.getElementById('selectedSnapshot'),
      selectedTenant: document.getElementById('selectedTenant'),
      selectedAccount: document.getElementById('selectedAccount'),
      snapshotSelect: document.getElementById('snapshotSelect'),
      tenantSelect: document.getElementById('tenantSelect'),
      accountSelect: document.getElementById('accountSelect'),
      uploadInput: document.getElementById('adoptionUpload'),
      loadButton: document.getElementById('loadWorkbookBtn'),
      uploadStatus: document.getElementById('uploadStatus'),
      snapshotPill: document.getElementById('snapshotPill'),
      summaryStatus: document.getElementById('summaryStatus'),
      summaryCards: document.getElementById('summaryCards'),
      groupBreakdown: document.getElementById('groupBreakdown'),
      adoptionTableBody: document.querySelector('#adoptionTable tbody'),
      adoptionResultsLabel: document.getElementById('adoptionResultsLabel'),
      adoptionCountPill: document.getElementById('adoptionCountPill'),
      adoptionSearch: document.getElementById('adoptionSearch'),
      groupFilter: document.getElementById('groupFilter'),
      typeFilter: document.getElementById('typeFilter'),
      apmFilter: document.getElementById('apmFilter'),
      scorecardTableBody: document.querySelector('#scorecardTable tbody'),
      scorecardHighlights: document.getElementById('scorecardHighlights'),
      scorecardCountPill: document.getElementById('scorecardCountPill'),
      scorecardSearch: document.getElementById('scorecardSearch'),
      cloudFilter: document.getElementById('cloudFilter'),
      mcmuTableBody: document.querySelector('#mcmuTable tbody'),
      mcmuCountPill: document.getElementById('mcmuCountPill'),
    };

    const isBlank = (value) =>
      value === null || value === undefined || (typeof value === 'string' && value.trim() === '');

    const parseSheet = (workbook, sheetName) => {
      const sheet = workbook.Sheets[sheetName];
      if (!sheet) return { headers: [], rows: [] };
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });
      const headerIndex = raw.findIndex((row) => Array.isArray(row) && row.some((cell) => !isBlank(cell)));
      if (headerIndex === -1) return { headers: [], rows: [] };
      const headers = raw[headerIndex].map((cell) => (isBlank(cell) ? '' : String(cell).trim()));
      const rows = [];
      for (let i = headerIndex + 1; i < raw.length; i += 1) {
        const row = raw[i];
        if (!Array.isArray(row) || row.every((cell) => isBlank(cell))) {
          continue;
        }
        const entry = {};
        headers.forEach((header, index) => {
          if (!header) return;
          entry[header] = index < row.length ? row[index] : null;
        });
        rows.push(entry);
      }
      return { headers, rows };
    };

    const normalizeNumber = (value) => {
      if (value === null || value === undefined || value === '') return null;
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
      }
      const sanitized = String(value)
        .replace(/[^0-9.,-]/g, '')
        .replace(/,(?=\d{3}\b)/g, '');
      const normalized = sanitized.replace(/,/g, '.');
      const parsed = Number(normalized);
      return Number.isFinite(parsed) ? parsed : null;
    };

    const sumColumn = (rows, key) =>
      rows.reduce((acc, row) => {
        const value = normalizeNumber(row[key]);
        return acc + (Number.isFinite(value) ? value : 0);
      }, 0);

    const averageColumn = (rows, key) => {
      let total = 0;
      let count = 0;
      rows.forEach((row) => {
        const value = normalizeNumber(row[key]);
        if (Number.isFinite(value)) {
          total += value;
          count += 1;
        }
      });
      return count > 0 ? total / count : null;
    };

    const formatNumber = (value, options = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatter = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: options.maximumFractionDigits ?? 0,
        minimumFractionDigits: options.minimumFractionDigits ?? 0,
      });
      return formatter.format(value);
    };

    const formatPercent = (value, options = {}) => {
      if (!Number.isFinite(value)) return '—';
      const formatter = new Intl.NumberFormat('en-US', {
        style: 'percent',
        maximumFractionDigits: options.maximumFractionDigits ?? 1,
        minimumFractionDigits: options.minimumFractionDigits ?? 0,
      });
      return formatter.format(value);
    };

    const formatEngagement = (value) => {
      const numeric = normalizeNumber(value);
      if (!Number.isFinite(numeric)) return '—';
      if (numeric <= 1) {
        return formatPercent(numeric, { maximumFractionDigits: 1, minimumFractionDigits: 0 });
      }
      return formatNumber(numeric);
    };

    const parseDate = (value) => {
      if (value instanceof Date && !Number.isNaN(value.getTime())) {
        return value;
      }
      const numeric = normalizeNumber(value);
      if (Number.isFinite(numeric) && numeric > 40000) {
        const parsed = XLSX.SSF.parse_date_code(numeric);
        if (parsed) {
          return new Date(parsed.y, (parsed.m || 1) - 1, parsed.d || 1, parsed.H || 0, parsed.M || 0, parsed.S || 0);
        }
      }
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    };

    const formatDate = (value) => {
      if (!(value instanceof Date) || Number.isNaN(value.getTime())) {
        return '';
      }
      const options = { year: 'numeric', month: 'short', day: '2-digit' };
      return new Intl.DateTimeFormat('en-US', options).format(value);
    };

    const toIsoString = (date) => {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
      return date.toISOString();
    };

    const resetSelect = (select, placeholder) => {
      if (!select) return;
      select.innerHTML = `<option value="" disabled selected>${placeholder}</option>`;
      select.disabled = true;
    };

    const clearVisualizations = (message) => {
      if (dom.summaryCards) {
        dom.summaryCards.hidden = true;
        dom.summaryCards.innerHTML = '';
      }
      if (dom.groupBreakdown) {
        dom.groupBreakdown.hidden = true;
        dom.groupBreakdown.innerHTML = '';
      }
      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = message;
      }
      if (dom.adoptionTableBody) {
        dom.adoptionTableBody.innerHTML = `<tr><td colspan="10" class="empty-state">${message}</td></tr>`;
      }
      if (dom.adoptionResultsLabel) {
        dom.adoptionResultsLabel.textContent = '';
      }
      if (dom.adoptionCountPill) {
        dom.adoptionCountPill.textContent = '--';
      }
      if (dom.scorecardTableBody) {
        dom.scorecardTableBody.innerHTML = `<tr><td colspan="5" class="empty-state">${message}</td></tr>`;
      }
      if (dom.scorecardHighlights) {
        dom.scorecardHighlights.hidden = true;
        dom.scorecardHighlights.innerHTML = '';
      }
      if (dom.scorecardCountPill) {
        dom.scorecardCountPill.textContent = '--';
      }
      if (dom.mcmuTableBody) {
        dom.mcmuTableBody.innerHTML = `<tr><td colspan="5" class="empty-state">${message}</td></tr>`;
      }
      if (dom.mcmuCountPill) {
        dom.mcmuCountPill.textContent = '--';
      }
      if (dom.snapshotPill) {
        dom.snapshotPill.textContent = 'Snapshot not selected';
      }
    };

    const updateSelectionLabels = ({ snapshotText, tenantText, accountText } = {}) => {
      if (dom.selectedSnapshot) {
        if (snapshotText) {
          dom.selectedSnapshot.textContent = snapshotText;
        } else if (state.selection.snapshot) {
          const date = new Date(state.selection.snapshot);
          dom.selectedSnapshot.textContent = formatDate(date) || state.selection.snapshot;
        } else {
          dom.selectedSnapshot.textContent = 'Not selected';
        }
      }
      if (dom.selectedTenant) {
        if (tenantText) {
          dom.selectedTenant.textContent = tenantText;
        } else if (state.selection.snapshot) {
          dom.selectedTenant.textContent =
            state.selection.tenant === 'all' ? 'All tenants' : state.selection.tenant || 'Not specified';
        } else {
          dom.selectedTenant.textContent = 'Not selected';
        }
      }
      if (dom.selectedAccount) {
        if (accountText) {
          dom.selectedAccount.textContent = accountText;
        } else if (state.selection.snapshot) {
          if (state.selection.account === 'all') {
            dom.selectedAccount.textContent = 'All accounts';
          } else {
            const match = state.adoptionAll.find((row) => row.__accountKey === state.selection.account);
            dom.selectedAccount.textContent = match?.__accountLabel || state.selection.account;
          }
        } else {
          dom.selectedAccount.textContent = 'Not selected';
        }
      }
    };

    const collectSnapshots = () => {
      const snapshotMap = new Map();
      const addSnapshot = (iso, date) => {
        if (!iso) return;
        if (!snapshotMap.has(iso)) {
          const parsed = date instanceof Date && !Number.isNaN(date.getTime()) ? date : new Date(iso);
          snapshotMap.set(iso, parsed);
        }
      };
      [state.adoptionAll, state.scorecardAll, state.mcmuAll, state.coreAll].forEach((rows) => {
        rows.forEach((row) => addSnapshot(row.__snapshot, row.__snapshotDate));
      });
      return Array.from(snapshotMap.entries())
        .map(([iso, date]) => ({ iso, date }))
        .sort((a, b) => {
          const aTime = a.date instanceof Date && !Number.isNaN(a.date.getTime()) ? a.date.getTime() : 0;
          const bTime = b.date instanceof Date && !Number.isNaN(b.date.getTime()) ? b.date.getTime() : 0;
          return bTime - aTime;
        });
    };

    const populateSnapshotOptions = () => {
      if (!dom.snapshotSelect) return;
      const snapshots = collectSnapshots();
      if (!snapshots.length) {
        dom.snapshotSelect.innerHTML = '<option value="" disabled selected>Upload a workbook to populate dates</option>';
        dom.snapshotSelect.disabled = true;
        return;
      }
      dom.snapshotSelect.innerHTML = '<option value="" disabled selected>-- Select snapshot date --</option>';
      snapshots.forEach(({ iso, date }) => {
        const option = document.createElement('option');
        option.value = iso;
        option.textContent = date instanceof Date && !Number.isNaN(date.getTime()) ? formatDate(date) : iso;
        dom.snapshotSelect.append(option);
      });
      dom.snapshotSelect.disabled = false;
    };

    const populateTenantOptions = (snapshot) => {
      if (!dom.tenantSelect) return;
      if (!snapshot) {
        resetSelect(dom.tenantSelect, state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate tenants');
        resetSelect(
          dom.accountSelect,
          state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate accounts'
        );
        updateLoadButtonState();
        return;
      }
      const tenants = new Set();
      state.adoptionAll.forEach((row) => {
        if (row.__snapshot === snapshot) {
          tenants.add(row.__tenant || 'Not specified');
        }
      });
      if (!tenants.size) {
        dom.tenantSelect.innerHTML = '<option value="" disabled selected>No tenants for the selected snapshot</option>';
        dom.tenantSelect.disabled = true;
        resetSelect(dom.accountSelect, 'No accounts for the selected filters');
        updateLoadButtonState();
        return;
      }
      dom.tenantSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'All tenants';
      dom.tenantSelect.append(allOption);
      Array.from(tenants)
        .sort((a, b) => a.localeCompare(b))
        .forEach((tenant) => {
          const option = document.createElement('option');
          option.value = tenant;
          option.textContent = tenant;
          dom.tenantSelect.append(option);
        });
      dom.tenantSelect.disabled = false;
      dom.tenantSelect.value = 'all';
      populateAccountOptions(snapshot, 'all');
    };

    const populateAccountOptions = (snapshot, tenant = 'all') => {
      if (!dom.accountSelect) return;
      if (!snapshot) {
        resetSelect(dom.accountSelect, state.datasetLoaded ? 'Select a snapshot first' : 'Upload a workbook to populate accounts');
        updateLoadButtonState();
        return;
      }
      const accounts = new Map();
      state.adoptionAll.forEach((row) => {
        if (row.__snapshot !== snapshot) return;
        const tenantLabel = row.__tenant || 'Not specified';
        if (tenant !== 'all' && tenantLabel !== tenant) return;
        const key = row.__accountKey || row.__accountId || row.__accountLabel;
        if (!key) return;
        if (!accounts.has(key)) {
          accounts.set(key, row.__accountLabel || row.__accountName || key);
        }
      });
      if (!accounts.size) {
        dom.accountSelect.innerHTML = '<option value="" disabled selected>No accounts for the selected filters</option>';
        dom.accountSelect.disabled = true;
        updateLoadButtonState();
        return;
      }
      dom.accountSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'All accounts';
      dom.accountSelect.append(allOption);
      Array.from(accounts.entries())
        .sort((a, b) => a[1].localeCompare(b[1]))
        .forEach(([key, label]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = label;
          dom.accountSelect.append(option);
        });
      dom.accountSelect.disabled = false;
      dom.accountSelect.value = 'all';
      updateLoadButtonState();
    };

    const updateLoadButtonState = () => {
      if (!dom.loadButton) return;
      const hasDataset = state.datasetLoaded;
      const snapshotSelected = Boolean(dom.snapshotSelect && dom.snapshotSelect.value);
      const accountSelected =
        dom.accountSelect && !dom.accountSelect.disabled && Boolean(dom.accountSelect.value);
      dom.loadButton.disabled = !(hasDataset && snapshotSelected && accountSelected);
    };
    const parseWorkbookData = (arrayBuffer) => {
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const adoptionSheet = parseSheet(workbook, 'Adoption Metrics');
      const scorecardSheet = parseSheet(workbook, 'Adoption Scorecard');
      const mcmuSheet = parseSheet(workbook, 'MCMU Report');
      const coreSheet = parseSheet(workbook, 'Core By OrgID');

      const snapshotByOrg = new Map();
      const snapshotByAccount = new Map();
      const snapshotSet = new Set();

      const coreRows = coreSheet.rows.map((row) => {
        const snapshotDate = parseDate(row.SNAPSHOT_DT);
        const snapshotIso = toIsoString(snapshotDate);
        if (snapshotIso) snapshotSet.add(snapshotIso);
        const accountId = !isBlank(row['ACCOUNT ID']) ? String(row['ACCOUNT ID']) : '';
        const accountName = row['Account Name'] || row['Account Name (Local)'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const augmented = {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountId || accountName || 'unknown-account',
          __tenant: 'Not specified',
        };
        const orgId = !isBlank(row['ORG ID']) ? String(row['ORG ID']) : null;
        if (orgId && snapshotIso) snapshotByOrg.set(orgId, snapshotIso);
        if (accountId && snapshotIso) snapshotByAccount.set(accountId, snapshotIso);
        return augmented;
      });

      const tenantByAccount = new Map();

      const adoptionRows = adoptionSheet.rows.map((row, index) => {
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const orgId = !isBlank(row['Org ID']) ? String(row['Org ID']) : '';
        const tenant = !isBlank(row['Company Name']) ? String(row['Company Name']) : 'Not specified';
        const accountName = row['Account Name'] || row['Account Local Name'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const snapshotIso = snapshotByOrg.get(orgId) || snapshotByAccount.get(accountId) || null;
        const snapshotDate = snapshotIso ? new Date(snapshotIso) : null;
        const accountKey = accountId || accountName || orgId || `unknown-account-${index}`;
        if (accountId) tenantByAccount.set(accountId, tenant);
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      const scorecardRows = scorecardSheet.rows.map((row, index) => {
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const orgId = !isBlank(row['Org ID']) ? String(row['Org ID']) : '';
        const tenant = tenantByAccount.get(accountId) || 'Not specified';
        const accountName = row['Account Local Name'] || row['Account ID'] || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const snapshotIso = snapshotByOrg.get(orgId) || snapshotByAccount.get(accountId) || null;
        const snapshotDate = snapshotIso ? new Date(snapshotIso) : null;
        const accountKey = accountId || accountName || orgId || `scorecard-account-${index}`;
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      const mcmuRows = mcmuSheet.rows.map((row, index) => {
        const snapshotDate = parseDate(row['Snapshot Date']);
        const snapshotIso = toIsoString(snapshotDate);
        if (snapshotIso) snapshotSet.add(snapshotIso);
        const accountId = !isBlank(row['Account ID']) ? String(row['Account ID']) : '';
        const tenantFromAccount = tenantByAccount.get(accountId);
        const tenantColumn = !isBlank(row['Enterprise Name and Tenant'])
          ? String(row['Enterprise Name and Tenant'])
          : null;
        const tenant = tenantFromAccount || tenantColumn || 'Not specified';
        const accountName = row['Account Name'] || accountId || '';
        const accountLabel = accountName || accountId || 'Not specified';
        const accountKey = accountId || accountName || `mcmu-account-${index}`;
        return {
          ...row,
          __snapshot: snapshotIso,
          __snapshotDate: snapshotDate,
          __tenant: tenant,
          __accountId: accountId,
          __accountName: accountName,
          __accountLabel: accountLabel,
          __accountKey: accountKey,
        };
      });

      if (snapshotSet.size === 1) {
        const [onlySnapshot] = Array.from(snapshotSet);
        const referenceDate = coreRows.find((row) => row.__snapshot === onlySnapshot)?.__snapshotDate || new Date(onlySnapshot);
        const assignSnapshot = (row) => {
          if (!row.__snapshot) {
            row.__snapshot = onlySnapshot;
            row.__snapshotDate =
              referenceDate instanceof Date && !Number.isNaN(referenceDate.getTime())
                ? referenceDate
                : new Date(onlySnapshot);
          }
        };
        adoptionRows.forEach(assignSnapshot);
        scorecardRows.forEach(assignSnapshot);
      }

      coreRows.forEach((row) => {
        const tenant = tenantByAccount.get(row.__accountId) || 'Not specified';
        row.__tenant = tenant;
      });

      return { adoptionRows, scorecardRows, mcmuRows, coreRows };
    };

    const applySelection = (snapshot, tenant, account, labels = {}) => {
      state.selection = { snapshot, tenant, account };
      state.filters = { ...DEFAULT_FILTERS };

      if (dom.adoptionSearch) dom.adoptionSearch.value = '';
      if (dom.scorecardSearch) dom.scorecardSearch.value = '';
      if (dom.cloudFilter) dom.cloudFilter.value = 'all';

      const matchesSelection = (row) => {
        if (!row) return false;
        if (snapshot) {
          if (row.__snapshot && row.__snapshot !== snapshot) return false;
          if (!row.__snapshot) return false;
        }
        if (tenant && tenant !== 'all') {
          const rowTenant = row.__tenant || 'Not specified';
          if (rowTenant !== tenant) return false;
        }
        if (account && account !== 'all') {
          const rowAccount = row.__accountKey || row.__accountId || row.__accountLabel;
          if (rowAccount !== account) return false;
        }
        return true;
      };

      state.adoption = state.adoptionAll.filter((row) => matchesSelection(row));
      state.scorecard = state.scorecardAll.filter((row) => matchesSelection(row));
      state.mcmu = state.mcmuAll.filter((row) => matchesSelection(row));
      state.core = state.coreAll.filter((row) => matchesSelection(row));

      updateAdoptionFilters();
      renderAdoptionTable();
      updateScorecardFilters();
      renderScorecardTable();
      renderMcmuTable();
      updateSummary();
      updateSnapshotPill();
      updateSelectionLabels(labels);
    };
    const updateSummary = () => {
      const rows = state.adoption;
      if (!rows.length) {
        if (dom.summaryStatus) {
          dom.summaryStatus.textContent = state.datasetLoaded
            ? 'No adoption metrics match the current selection.'
            : 'No rows loaded from the “Adoption Metrics” sheet.';
        }
        if (dom.summaryCards) dom.summaryCards.hidden = true;
        if (dom.groupBreakdown) dom.groupBreakdown.hidden = true;
        return;
      }

      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = '';
      }
      if (dom.summaryCards) dom.summaryCards.hidden = false;

      const totalProvisioned = sumColumn(rows, 'PROVISIONED');
      const totalActivated = sumColumn(rows, 'ACTIVATED');
      const totalUsed = sumColumn(rows, 'USED');
      const totalShelfware = sumColumn(rows, 'Shelfware');
      const avgMauPenetration = averageColumn(rows, 'MAU Penetration');
      const avgEu = averageColumn(rows, 'EU');

      const uniqueAccounts = new Set();
      const uniqueOrgs = new Set();
      rows.forEach((row) => {
        if (!isBlank(row['Account ID'])) uniqueAccounts.add(row['Account ID']);
        if (!isBlank(row['Org ID'])) uniqueOrgs.add(row['Org ID']);
      });

      const activationRate = totalProvisioned > 0 ? totalActivated / totalProvisioned : null;
      const utilizationRate = totalProvisioned > 0 ? totalUsed / totalProvisioned : null;

      const summaryData = [
        {
          label: 'Provisioned licenses',
          value: formatNumber(totalProvisioned),
          meta: `${uniqueAccounts.size} accounts • ${uniqueOrgs.size} orgs`,
        },
        {
          label: 'Activated licenses',
          value: formatNumber(totalActivated),
          meta: activationRate !== null ? `${formatPercent(activationRate)} activation rate` : '—',
        },
        {
          label: 'Used licenses',
          value: formatNumber(totalUsed),
          meta: utilizationRate !== null ? `${formatPercent(utilizationRate)} utilization` : '—',
        },
        {
          label: 'Total shelfware',
          value: formatNumber(totalShelfware),
          meta: 'Licenses not activated or not used',
        },
        {
          label: 'Average EU',
          value: formatEngagement(avgEu),
          meta: 'EU = Entitlement Utilization',
        },
        {
          label: 'Average MAU penetration',
          value: formatEngagement(avgMauPenetration),
          meta: 'Share of monthly active users',
        },
      ];

      if (dom.summaryCards) {
        dom.summaryCards.innerHTML = '';
        summaryData.forEach((item) => {
          const card = document.createElement('div');
          card.className = 'summary-card';
          const label = document.createElement('span');
          label.textContent = item.label;
          const value = document.createElement('strong');
          value.textContent = item.value;
          const meta = document.createElement('span');
          meta.textContent = item.meta;
          card.append(label, value, meta);
          dom.summaryCards.append(card);
        });
      }

      renderGroupBreakdown(rows);
    };

    const renderGroupBreakdown = (rows) => {
      if (!dom.groupBreakdown) return;
      if (!rows.length) {
        dom.groupBreakdown.hidden = true;
        dom.groupBreakdown.innerHTML = '';
        return;
      }
      dom.groupBreakdown.hidden = false;
      const groupMetrics = new Map();
      rows.forEach((row) => {
        const key = isBlank(row.Group) ? 'Not specified' : String(row.Group);
        if (!groupMetrics.has(key)) {
          groupMetrics.set(key, {
            provisioned: 0,
            activated: 0,
            used: 0,
            shelfware: 0,
            types: new Set(),
          });
        }
        const metrics = groupMetrics.get(key);
        metrics.provisioned += normalizeNumber(row.PROVISIONED) || 0;
        metrics.activated += normalizeNumber(row.ACTIVATED) || 0;
        metrics.used += normalizeNumber(row.USED) || 0;
        metrics.shelfware += normalizeNumber(row.Shelfware) || 0;
        if (!isBlank(row.Type)) metrics.types.add(String(row.Type));
      });

      const sorted = Array.from(groupMetrics.entries())
        .map(([group, metrics]) => ({ group, ...metrics }))
        .sort((a, b) => b.used - a.used || b.activated - a.activated);

      dom.groupBreakdown.innerHTML = '';
      sorted.slice(0, 6).forEach((item) => {
        const card = document.createElement('div');
        card.className = 'breakdown-card';
        const title = document.createElement('h3');
        title.textContent = item.group;
        const types = document.createElement('span');
        types.className = 'helper-text';
        types.textContent = `${item.types.size} SKUs`;

        const metrics = [
          { label: 'Provisioned', value: formatNumber(item.provisioned) },
          { label: 'Activated', value: formatNumber(item.activated) },
          { label: 'Used', value: formatNumber(item.used) },
          { label: 'Shelfware', value: formatNumber(item.shelfware) },
        ];

        card.append(title, types);
        metrics.forEach((metric) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'breakdown-metric';
          const label = document.createElement('span');
          label.textContent = metric.label;
          const value = document.createElement('span');
          value.textContent = metric.value;
          rowEl.append(label, value);
          card.append(rowEl);
        });
        dom.groupBreakdown.append(card);
      });
    };

    const updateTypeFilterOptions = () => {
      if (!dom.typeFilter) return;
      const { adoption, filters } = state;
      if (!adoption.length) {
        dom.typeFilter.innerHTML = '<option value="" disabled selected>No types available</option>';
        dom.typeFilter.disabled = true;
        return;
      }

      const types = new Set();
      adoption.forEach((row) => {
        if (filters.group !== 'all' && String(row.Group) !== filters.group) return;
        if (!isBlank(row.Type)) types.add(String(row.Type));
      });

      dom.typeFilter.innerHTML = '<option value="all">Type: all</option>';
      Array.from(types)
        .sort((a, b) => a.localeCompare(b))
        .forEach((type) => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          dom.typeFilter.append(option);
        });

      if (!types.has(state.filters.type)) {
        state.filters.type = 'all';
      }
      dom.typeFilter.value = state.filters.type;
      dom.typeFilter.disabled = dom.typeFilter.options.length <= 1;
    };

    const updateAdoptionFilters = () => {
      if (!dom.groupFilter || !dom.apmFilter) return;
      const { adoption } = state;

      if (!adoption.length) {
        dom.groupFilter.innerHTML = '<option value="" disabled selected>No groups available</option>';
        dom.groupFilter.disabled = true;
        dom.typeFilter.innerHTML = '<option value="" disabled selected>No types available</option>';
        dom.typeFilter.disabled = true;
        dom.apmFilter.innerHTML = '<option value="" disabled selected>No APM levels available</option>';
        dom.apmFilter.disabled = true;
        return;
      }

      const groups = new Set();
      const apmLevels = new Set();
      adoption.forEach((row) => {
        if (!isBlank(row.Group)) groups.add(String(row.Group));
        if (!isBlank(row['APM Level 1'])) apmLevels.add(String(row['APM Level 1']));
      });

      dom.groupFilter.innerHTML = '<option value="all">Group: all</option>';
      Array.from(groups)
        .sort((a, b) => a.localeCompare(b))
        .forEach((group) => {
          const option = document.createElement('option');
          option.value = group;
          option.textContent = group;
          dom.groupFilter.append(option);
        });
      if (!groups.has(state.filters.group)) {
        state.filters.group = 'all';
      }
      dom.groupFilter.value = state.filters.group;
      dom.groupFilter.disabled = false;

      updateTypeFilterOptions();

      dom.apmFilter.innerHTML = '<option value="all">APM Level 1: all</option>';
      Array.from(apmLevels)
        .sort((a, b) => a.localeCompare(b))
        .forEach((item) => {
          const option = document.createElement('option');
          option.value = item;
          option.textContent = item;
          dom.apmFilter.append(option);
        });
      if (!apmLevels.has(state.filters.apm)) {
        state.filters.apm = 'all';
      }
      dom.apmFilter.value = state.filters.apm;
      dom.apmFilter.disabled = dom.apmFilter.options.length <= 1;
    };

    const renderAdoptionTable = () => {
      if (!dom.adoptionTableBody) return;
      const { adoption, filters } = state;
      const query = filters.adoptionSearch.trim().toLowerCase();

      const filtered = adoption.filter((row) => {
        if (filters.group !== 'all' && String(row.Group) !== filters.group) return false;
        if (filters.type !== 'all' && String(row.Type) !== filters.type) return false;
        if (filters.apm !== 'all' && String(row['APM Level 1']) !== filters.apm) return false;
        if (query) {
          const haystack = [row['Account Name'], row['Account Local Name'], row['Org ID'], row.Type, row.Group]
            .filter((value) => !isBlank(value))
            .map((value) => String(value).toLowerCase())
            .join(' ');
          if (!haystack.includes(query)) return false;
        }
        return true;
      });

      dom.adoptionTableBody.innerHTML = '';
      if (filtered.length === 0) {
        dom.adoptionTableBody.innerHTML =
          '<tr><td colspan="10" class="empty-state">No adoption metrics for the selected filters.</td></tr>';
      } else {
        filtered.forEach((row) => {
          const tr = document.createElement('tr');
          const cells = [
            row['Account Name'] || row['Account Local Name'] || '—',
            row['Org ID'] || '—',
            row.Group || '—',
            row.Type || '—',
            formatNumber(normalizeNumber(row.PROVISIONED)),
            formatNumber(normalizeNumber(row.ACTIVATED)),
            formatNumber(normalizeNumber(row.USED)),
            formatEngagement(row.EU),
            formatEngagement(row['MAU Penetration']),
            formatNumber(normalizeNumber(row.Shelfware)),
          ];
          cells.forEach((text) => {
            const td = document.createElement('td');
            td.textContent = text;
            tr.append(td);
          });
          dom.adoptionTableBody.append(tr);
        });
      }

      if (dom.adoptionResultsLabel) {
        dom.adoptionResultsLabel.textContent = adoption.length
          ? `${filtered.length} rows out of ${adoption.length}`
          : '';
      }
      if (dom.adoptionCountPill) {
        dom.adoptionCountPill.textContent = adoption.length
          ? `${filtered.length} SKU visible`
          : '--';
      }
    };
    const renderScorecardHighlights = (rows) => {
      if (!dom.scorecardHighlights) return;
      if (!rows.length) {
        dom.scorecardHighlights.hidden = true;
        dom.scorecardHighlights.innerHTML = '';
        return;
      }
      dom.scorecardHighlights.hidden = false;
      const byCloud = new Map();
      rows.forEach((row) => {
        const cloud = isBlank(row.Cloud) ? 'Not specified' : String(row.Cloud);
        if (!byCloud.has(cloud)) {
          byCloud.set(cloud, { totalValue: 0, metrics: 0, positive: 0, negative: 0 });
        }
        const entry = byCloud.get(cloud);
        const metricValue = normalizeNumber(row['Metric Value']);
        const momValue = normalizeNumber(row['Month over Month Pct']);
        if (Number.isFinite(metricValue)) {
          entry.totalValue += metricValue;
        }
        entry.metrics += 1;
        if (Number.isFinite(momValue)) {
          if (momValue > 0) entry.positive += 1;
          if (momValue < 0) entry.negative += 1;
        }
      });

      const sorted = Array.from(byCloud.entries())
        .map(([cloud, metrics]) => ({ cloud, ...metrics }))
        .sort((a, b) => b.totalValue - a.totalValue);

      dom.scorecardHighlights.innerHTML = '';
      sorted.slice(0, 6).forEach((item) => {
        const card = document.createElement('div');
        card.className = 'highlight-card';
        const title = document.createElement('h3');
        title.textContent = item.cloud;
        const value = document.createElement('strong');
        value.textContent = formatNumber(item.totalValue);
        const meta = document.createElement('span');
        meta.className = 'helper-text';
        meta.textContent = `${item.metrics} metrics · ${item.positive} ↑ · ${item.negative} ↓`;
        card.append(title, value, meta);
        dom.scorecardHighlights.append(card);
      });
    };

    const renderScorecardTable = () => {
      if (!dom.scorecardTableBody) return;
      const { scorecard, filters } = state;
      const query = filters.scorecardSearch.trim().toLowerCase();

      const filtered = scorecard.filter((row) => {
        if (filters.cloud !== 'all' && String(row.Cloud) !== filters.cloud) return false;
        if (query) {
          const haystack = [row['Account Local Name'], row['Metric Name'], row.Cloud]
            .filter((value) => !isBlank(value))
            .map((value) => String(value).toLowerCase())
            .join(' ');
          if (!haystack.includes(query)) return false;
        }
        return true;
      });

      dom.scorecardTableBody.innerHTML = '';
      if (!filtered.length) {
        dom.scorecardTableBody.innerHTML =
          '<tr><td colspan="5" class="empty-state">No scorecard metrics match the current filters.</td></tr>';
      } else {
        filtered.forEach((row) => {
          const tr = document.createElement('tr');
          const mom = normalizeNumber(row['Month over Month Pct']);
          const momBadge = document.createElement('span');
          const badgeClass = mom > 0 ? 'badge up' : mom < 0 ? 'badge down' : 'badge';
          momBadge.className = badgeClass;
          momBadge.textContent = Number.isFinite(mom) ? `${(mom * 100).toFixed(1)}%` : '—';

          const cells = [
            row['Account Local Name'] || row['Account ID'] || '—',
            row.Cloud || '—',
            row['Metric Name'] || '—',
            formatNumber(normalizeNumber(row['Metric Value'])),
            momBadge,
          ];

          cells.forEach((content, index) => {
            const td = document.createElement('td');
            if (index === cells.length - 1 && content instanceof HTMLElement) {
              td.append(content);
            } else {
              td.textContent = content;
            }
            tr.append(td);
          });
          dom.scorecardTableBody.append(tr);
        });
      }

      if (dom.scorecardCountPill) {
        dom.scorecardCountPill.textContent = `${filtered.length} metrics`;
      }
      renderScorecardHighlights(filtered);
    };

    const updateScorecardFilters = () => {
      if (!dom.cloudFilter) return;
      const clouds = new Set();
      state.scorecard.forEach((row) => {
        if (!isBlank(row.Cloud)) clouds.add(String(row.Cloud));
      });
      dom.cloudFilter.innerHTML = '<option value="all">Cloud: all</option>';
      Array.from(clouds)
        .sort((a, b) => a.localeCompare(b))
        .forEach((cloud) => {
          const option = document.createElement('option');
          option.value = cloud;
          option.textContent = cloud;
          dom.cloudFilter.append(option);
        });
      dom.cloudFilter.disabled = dom.cloudFilter.options.length <= 1;
      dom.cloudFilter.value = 'all';
    };

    const renderMcmuTable = () => {
      if (!dom.mcmuTableBody) return;
      const rows = state.mcmu;
      dom.mcmuTableBody.innerHTML = '';
      if (!rows.length) {
        dom.mcmuTableBody.innerHTML =
          '<tr><td colspan="5" class="empty-state">No MCMU records available for the current selection.</td></tr>';
        if (dom.mcmuCountPill) dom.mcmuCountPill.textContent = '--';
        return;
      }

      const sorted = [...rows]
        .map((row) => ({
          ...row,
          __date: row.__snapshotDate instanceof Date && !Number.isNaN(row.__snapshotDate.getTime())
            ? row.__snapshotDate
            : parseDate(row['Snapshot Date']),
        }))
        .sort((a, b) => {
          const aTime = a.__date instanceof Date && !Number.isNaN(a.__date.getTime()) ? a.__date.getTime() : 0;
          const bTime = b.__date instanceof Date && !Number.isNaN(b.__date.getTime()) ? b.__date.getTime() : 0;
          return bTime - aTime;
        });

      sorted.forEach((row) => {
        const tr = document.createElement('tr');
        const date = row.__date instanceof Date && !Number.isNaN(row.__date.getTime())
          ? formatDate(row.__date)
          : row['Snapshot Date'] || '—';
        const cells = [
          date,
          row['Account Name'] || row['Account ID'] || '—',
          formatNumber(normalizeNumber(row['Super Messages Provisioned'])),
          formatNumber(normalizeNumber(row['Super Messages Used'])),
          formatNumber(normalizeNumber(row['Contacts Provisioned'])),
        ];
        cells.forEach((text) => {
          const td = document.createElement('td');
          td.textContent = text;
          tr.append(td);
        });
        dom.mcmuTableBody.append(tr);
      });

      if (dom.mcmuCountPill) {
        dom.mcmuCountPill.textContent = `${rows.length} records`;
      }
    };

    const updateSnapshotPill = () => {
      if (!dom.snapshotPill) return;
      if (!state.selection.snapshot) {
        dom.snapshotPill.textContent = 'Snapshot not selected';
        return;
      }
      const date = new Date(state.selection.snapshot);
      dom.snapshotPill.textContent = Number.isNaN(date.getTime())
        ? `Snapshot: ${state.selection.snapshot}`
        : `Snapshot: ${formatDate(date)}`;
    };
    const resetDashboard = (message) => {
      state.adoption = [];
      state.adoptionAll = [];
      state.scorecard = [];
      state.scorecardAll = [];
      state.mcmu = [];
      state.mcmuAll = [];
      state.core = [];
      state.coreAll = [];
      state.filters = { ...DEFAULT_FILTERS };
      state.selection = { snapshot: '', tenant: 'all', account: 'all' };
      state.datasetLoaded = false;

      if (dom.uploadInput) dom.uploadInput.value = '';
      populateSnapshotOptions();
      resetSelect(dom.tenantSelect, 'Upload a workbook to populate tenants');
      resetSelect(dom.accountSelect, 'Upload a workbook to populate accounts');
      if (dom.cloudFilter) {
        dom.cloudFilter.innerHTML = '<option value="all">Cloud: all</option>';
        dom.cloudFilter.disabled = true;
        dom.cloudFilter.value = 'all';
      }
      if (dom.adoptionSearch) dom.adoptionSearch.value = '';
      if (dom.scorecardSearch) dom.scorecardSearch.value = '';
      updateSelectionLabels({
        snapshotText: 'Not selected',
        tenantText: 'Not selected',
        accountText: 'Not selected',
      });
      clearVisualizations(message);
      updateLoadButtonState();
      if (dom.uploadStatus) {
        dom.uploadStatus.textContent = message;
      }
    };

    const handleWorkbookFile = (file) => {
      if (!file) {
        resetDashboard('Upload an adoption workbook to begin the analysis.');
        return;
      }
      if (!/\.xlsx$/i.test(file.name)) {
        alert('Please upload an XLSX file exported from the adoption dashboard.');
        resetDashboard('Upload an adoption workbook to begin the analysis.');
        return;
      }

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const dataset = parseWorkbookData(event.target.result);
          state.datasetLoaded = true;
          state.adoptionAll = dataset.adoptionRows;
          state.scorecardAll = dataset.scorecardRows;
          state.mcmuAll = dataset.mcmuRows;
          state.coreAll = dataset.coreRows;
          state.selection = { snapshot: '', tenant: 'all', account: 'all' };
          state.filters = { ...DEFAULT_FILTERS };

          populateSnapshotOptions();
          resetSelect(dom.tenantSelect, 'Select a snapshot first');
          resetSelect(dom.accountSelect, 'Select a snapshot first');
          updateSelectionLabels({
            snapshotText: 'Not selected',
            tenantText: 'Not selected',
            accountText: 'Not selected',
          });
          clearVisualizations('Select a snapshot, tenant, and account, then click "Load data".');
          if (dom.uploadStatus) {
            dom.uploadStatus.textContent = `Loaded ${file.name}. Select a snapshot to continue.`;
          }
        } catch (error) {
          console.error('Unable to parse adoption workbook', error);
          alert('The uploaded file is not a valid adoption workbook.');
          resetDashboard('Upload an adoption workbook to begin the analysis.');
        }
        updateLoadButtonState();
      };
      reader.onerror = () => {
        alert('Unable to read the selected file.');
        resetDashboard('Upload an adoption workbook to begin the analysis.');
      };
      reader.readAsArrayBuffer(file);
    };

    const handleSnapshotChange = () => {
      const snapshot = dom.snapshotSelect ? dom.snapshotSelect.value : '';
      populateTenantOptions(snapshot);
      updateLoadButtonState();
    };

    const handleTenantChange = () => {
      const snapshot = dom.snapshotSelect ? dom.snapshotSelect.value : '';
      const tenantValue = dom.tenantSelect && !dom.tenantSelect.disabled ? dom.tenantSelect.value || 'all' : 'all';
      populateAccountOptions(snapshot, tenantValue);
    };

    const handleAccountChange = () => {
      updateLoadButtonState();
    };

    const handleLoadClick = () => {
      if (!dom.snapshotSelect || !dom.accountSelect) return;
      const snapshot = dom.snapshotSelect.value;
      if (!snapshot) return;
      if (dom.accountSelect.disabled || !dom.accountSelect.value) return;
      const tenantValue = dom.tenantSelect && !dom.tenantSelect.disabled ? dom.tenantSelect.value || 'all' : 'all';
      const accountValue = dom.accountSelect.value;
      const snapshotLabel = dom.snapshotSelect.options[dom.snapshotSelect.selectedIndex]?.textContent || 'Not selected';
      const tenantLabel =
        tenantValue === 'all'
          ? 'All tenants'
          : dom.tenantSelect?.options[dom.tenantSelect.selectedIndex]?.textContent || tenantValue;
      const accountLabel =
        accountValue === 'all'
          ? 'All accounts'
          : dom.accountSelect?.options[dom.accountSelect.selectedIndex]?.textContent || accountValue;

      applySelection(snapshot, tenantValue, accountValue, {
        snapshotText: snapshotLabel,
        tenantText: tenantLabel,
        accountText: accountLabel,
      });

      if (dom.summaryStatus) {
        dom.summaryStatus.textContent = '';
      }
      if (dom.uploadStatus) {
        dom.uploadStatus.textContent = `Showing data for ${snapshotLabel} · ${tenantLabel} · ${accountLabel}`;
      }
    };

    const attachEventListeners = () => {
      if (dom.uploadInput) {
        dom.uploadInput.addEventListener('change', (event) => {
          const [file] = event.target.files || [];
          handleWorkbookFile(file);
        });
      }

      if (dom.snapshotSelect) {
        dom.snapshotSelect.addEventListener('change', handleSnapshotChange);
      }

      if (dom.tenantSelect) {
        dom.tenantSelect.addEventListener('change', handleTenantChange);
      }

      if (dom.accountSelect) {
        dom.accountSelect.addEventListener('change', handleAccountChange);
      }

      if (dom.loadButton) {
        dom.loadButton.addEventListener('click', handleLoadClick);
      }

      if (dom.adoptionSearch) {
        dom.adoptionSearch.addEventListener('input', (event) => {
          state.filters.adoptionSearch = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.groupFilter) {
        dom.groupFilter.addEventListener('change', (event) => {
          state.filters.group = event.target.value;
          state.filters.type = 'all';
          updateTypeFilterOptions();
          renderAdoptionTable();
        });
      }

      if (dom.typeFilter) {
        dom.typeFilter.addEventListener('change', (event) => {
          state.filters.type = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.apmFilter) {
        dom.apmFilter.addEventListener('change', (event) => {
          state.filters.apm = event.target.value;
          renderAdoptionTable();
        });
      }

      if (dom.scorecardSearch) {
        dom.scorecardSearch.addEventListener('input', (event) => {
          state.filters.scorecardSearch = event.target.value;
          renderScorecardTable();
        });
      }

      if (dom.cloudFilter) {
        dom.cloudFilter.addEventListener('change', (event) => {
          state.filters.cloud = event.target.value;
          renderScorecardTable();
        });
      }
    };

    attachEventListeners();
    resetDashboard('Upload an adoption workbook to begin the analysis.');
  </script>
</body>
</html>
